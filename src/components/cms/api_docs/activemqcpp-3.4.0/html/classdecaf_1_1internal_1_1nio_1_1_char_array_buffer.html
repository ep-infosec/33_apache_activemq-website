<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::internal::nio::CharArrayBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>decaf::internal::nio::CharArrayBuffer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::internal::nio::CharArrayBuffer" --><!-- doxytag: inherits="decaf::nio::CharBuffer" -->
<p><code>#include &lt;<a class="el" href="_char_array_buffer_8h_source.html">src/main/decaf/internal/nio/CharArrayBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::internal::nio::CharArrayBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer__inherit__graph.png" border="0" usemap="#decaf_1_1internal_1_1nio_1_1_char_array_buffer_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1internal_1_1nio_1_1_char_array_buffer_inherit__map" id="decaf_1_1internal_1_1nio_1_1_char_array_buffer_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:" alt="" coords="345,85,516,115"/><area shape="rect" id="node4" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type." alt="" coords="80,5,221,35"/><area shape="rect" id="node6" href="classdecaf_1_1lang_1_1_char_sequence.html" title="A CharSequence is a readable sequence of char values." alt="" coords="48,59,253,88"/><area shape="rect" id="node8" href="classdecaf_1_1lang_1_1_appendable.html" title="An object to which char sequences and values can be appended." alt="" coords="59,112,243,141"/><area shape="rect" id="node10" href="classdecaf_1_1lang_1_1_comparable.html" title="decaf::lang::Comparable\&lt; CharBuffer \&gt;" alt="" coords="5,165,296,195"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a02363d5242435b69f8ca8e71abd585ac">CharArrayBuffer</a> (int size, bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted.  <a href="#a02363d5242435b69f8ca8e71abd585ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#acf23117e4d795a2ca00a2a2da479581a">CharArrayBuffer</a> (char *array, int size, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">offset</a>, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">length</a>, bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that wraps the given array.  <a href="#acf23117e4d795a2ca00a2a2da479581a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ab4a28845aa83dfe9c2c9e802006d47a8">CharArrayBuffer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt; &amp;array, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">offset</a>, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">length</a>, bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte buffer that wraps the passed ByteArrayAdapter and start at the given offset.  <a href="#ab4a28845aa83dfe9c2c9e802006d47a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a0e751518499478ef5da9ec29d8eea337">CharArrayBuffer</a> (const <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> that mirrors this one, meaning it shares a reference to this buffers ByteArrayAdapter and when changes are made to that data it is reflected in both.  <a href="#a0e751518499478ef5da9ec29d8eea337"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a780a85507dbdf2259d1acd7e5aadf1bd">~CharArrayBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a2a962ba127c31943dd075327142a8402">array</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character array that backs this buffer (optional operation).Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>the array that backs this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a2a962ba127c31943dd075327142a8402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ae6dabe5e2cc564bfe8a38de3f057ab3b">arrayOffset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing array of the first element of the buffer (optional operation).Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>The offset into the backing array where index zero starts.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ae6dabe5e2cc564bfe8a38de3f057ab3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CharBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a9ac96e6fac08527174b0702cab373a39">asReadOnlyBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, read-only char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.<dl class="return"><dt><b>Returns:</b></dt><dd>The new, read-only char buffer which the caller then owns.</dd></dl>
  <a href="#a9ac96e6fac08527174b0702cab373a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CharBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a69d68ff242c2619d90782d287206cfb3">compact</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts this buffer.The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>- If this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a69d68ff242c2619d90782d287206cfb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CharBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#acf2117fe9c621d2569aa6bf5880bdf8d">duplicate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>a new char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns.</dd></dl>
  <a href="#acf2117fe9c621d2569aa6bf5880bdf8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a22a5f51cf8da460d264e91afaad64813">get</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative get method.Reads the character at this buffer's current position, and then increments the position.<dl class="return"><dt><b>Returns:</b></dt><dd>the char at the current position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there no more data to return</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a22a5f51cf8da460d264e91afaad64813"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a5da481d2f474ac00496f458abf719fea">get</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.Reads the char at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the char is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit or is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a5da481d2f474ac00496f458abf719fea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a9e39462b5ed584c2556b686fd3c5e830">hasArray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is backed by an accessible char array.If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is backed by an array and is not read-only</dd></dl>
  <a href="#a9e39462b5ed584c2556b686fd3c5e830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a479f8f91fa141921980f2002e1ca39f6">isReadOnly</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is read-only.</dd></dl>
  <a href="#a479f8f91fa141921980f2002e1ca39f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CharBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac7000bacc913fbd14e1c957f80ec9b14">put</a> (char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given char into this buffer at the current position, and then increments the position.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ac7000bacc913fbd14e1c957f80ec9b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CharBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ad2d2a97ee0cd5061f7eb428f8238821c">put</a> (int index, char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given char into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The char to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ad2d2a97ee0cd5061f7eb428f8238821c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CharBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a50e69c403797e5d6e0c3491f0e34a8a4">slice</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> whose content is a shared subsequence of this buffer's content.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> which the caller owns.</dd></dl>
  <a href="#a50e69c403797e5d6e0c3491f0e34a8a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#aeb7ba1e4d009af1a76ba212f8fdc2dd3">subSequence</a> (int start, int end) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position.The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + start, and its limit will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + end. The new <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> will be read-only if, and only if, this buffer is read-only.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index, relative to the current position, of the first character in the subsequence; must be non-negative and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>. </td></tr>
    <tr><td class="paramname">end</td><td>The index, relative to the current position, of the character following the last character in the subsequence; must be no smaller than start and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new character buffer, caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions on start and end fail.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aeb7ba1e4d009af1a76ba212f8fdc2dd3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ad160fde41808391c1237a67aee9659be">setReadOnly</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> as Read-Only.  <a href="#ad160fde41808391c1237a67aee9659be"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a><br class="typebreak"/>
&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a177ea1ae3ce47a89e01a3daa6888fff6">_array</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">offset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">length</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02363d5242435b69f8ca8e71abd585ac"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::CharArrayBuffer" ref="a02363d5242435b69f8ca8e71abd585ac" args="(int size, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this buffer should be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if the capacity value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf23117e4d795a2ca00a2a2da479581a"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::CharArrayBuffer" ref="acf23117e4d795a2ca00a2a2da479581a" args="(char *array, int size, int offset, int length, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The actual array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given array. </td></tr>
    <tr><td class="paramname">offset</td><td>The position that is this buffers start position. </td></tr>
    <tr><td class="paramname">length</td><td>The limit of how many bytes into the array this Buffer can write. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this buffer should be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset is greater than array capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4a28845aa83dfe9c2c9e802006d47a8"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::CharArrayBuffer" ref="ab4a28845aa83dfe9c2c9e802006d47a8" args="(const decaf::lang::Pointer&lt; ByteArrayAdapter &gt; &amp;array, int offset, int length, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte buffer that wraps the passed ByteArrayAdapter and start at the given offset. </p>
<p>The capacity and limit of the new <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> will be that of the remaining capacity of the passed buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The ByteArrayAdapter to wrap. </td></tr>
    <tr><td class="paramname">offset</td><td>The position that is this buffers start position. </td></tr>
    <tr><td class="paramname">length</td><td>The limit of how many bytes into the array this Buffer can write. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this buffer should be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if array is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset + length is greater than array size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e751518499478ef5da9ec29d8eea337"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::CharArrayBuffer" ref="a0e751518499478ef5da9ec29d8eea337" args="(const CharArrayBuffer &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> that mirrors this one, meaning it shares a reference to this buffers ByteArrayAdapter and when changes are made to that data it is reflected in both. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> this one is to mirror. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a780a85507dbdf2259d1acd7e5aadf1bd"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::~CharArrayBuffer" ref="a780a85507dbdf2259d1acd7e5aadf1bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::nio::CharArrayBuffer::~CharArrayBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2a962ba127c31943dd075327142a8402"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::array" ref="a2a962ba127c31943dd075327142a8402" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* decaf::internal::nio::CharArrayBuffer::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the character array that backs this buffer (optional operation).Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>the array that backs this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#aeeedbd0a8bf248eb5435faf62da61e13">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae6dabe5e2cc564bfe8a38de3f057ab3b"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::arrayOffset" ref="ae6dabe5e2cc564bfe8a38de3f057ab3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::nio::CharArrayBuffer::arrayOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the offset within this buffer's backing array of the first element of the buffer (optional operation).Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>The offset into the backing array where index zero starts.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a86cffeecea297e1ea495cd99e4900c67">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a9ac96e6fac08527174b0702cab373a39"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::asReadOnlyBuffer" ref="a9ac96e6fac08527174b0702cab373a39" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CharBuffer* decaf::internal::nio::CharArrayBuffer::asReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new, read-only char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.<dl class="return"><dt><b>Returns:</b></dt><dd>The new, read-only char buffer which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a4fe36b72b26a5f5e5e1078fa764b408f">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a69d68ff242c2619d90782d287206cfb3"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::compact" ref="a69d68ff242c2619d90782d287206cfb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CharBuffer&amp; decaf::internal::nio::CharArrayBuffer::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compacts this buffer.The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>- If this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ad9986f7f6866aabf327f7b5454fd3a5e">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="acf2117fe9c621d2569aa6bf5880bdf8d"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::duplicate" ref="acf2117fe9c621d2569aa6bf5880bdf8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CharBuffer* decaf::internal::nio::CharArrayBuffer::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>a new char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a75c1941edd0a2c97a48c27c71f2c368b">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a22a5f51cf8da460d264e91afaad64813"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::get" ref="a22a5f51cf8da460d264e91afaad64813" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::nio::CharArrayBuffer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative get method.Reads the character at this buffer's current position, and then increments the position.<dl class="return"><dt><b>Returns:</b></dt><dd>the char at the current position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there no more data to return</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a2b97bd1d26c39d08f1f58c12d72c5b51">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a5da481d2f474ac00496f458abf719fea"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::get" ref="a5da481d2f474ac00496f458abf719fea" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::nio::CharArrayBuffer::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Absolute get method.Reads the char at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the char is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit or is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a473c75666831b132703413ee1ab96fb1">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a9e39462b5ed584c2556b686fd3c5e830"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::hasArray" ref="a9e39462b5ed584c2556b686fd3c5e830" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::nio::CharArrayBuffer::hasArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether or not this buffer is backed by an accessible char array.If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is backed by an array and is not read-only</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a72e3273f23313d1ceedaeee2ff1435e3">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a479f8f91fa141921980f2002e1ca39f6"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::isReadOnly" ref="a479f8f91fa141921980f2002e1ca39f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::nio::CharArrayBuffer::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether or not this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is read-only.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a3cb8f27f48cae4bf41443d0d67b9e972">decaf::nio::Buffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac7000bacc913fbd14e1c957f80ec9b14"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::put" ref="ac7000bacc913fbd14e1c957f80ec9b14" args="(char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CharBuffer&amp; decaf::internal::nio::CharArrayBuffer::put </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given char into this buffer at the current position, and then increments the position.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ad7f8e07c4c460376cbfec0f143c94caa">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad2d2a97ee0cd5061f7eb428f8238821c"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::put" ref="ad2d2a97ee0cd5061f7eb428f8238821c" args="(int index, char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CharBuffer&amp; decaf::internal::nio::CharArrayBuffer::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given char into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The char to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a39a42ad53cebf0c96a3e1b911193ed59">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad160fde41808391c1237a67aee9659be"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::setReadOnly" ref="ad160fde41808391c1237a67aee9659be" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::nio::CharArrayBuffer::setReadOnly </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets this <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> as Read-Only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Boolean value, true if this buffer is to be read-only, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50e69c403797e5d6e0c3491f0e34a8a4"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::slice" ref="a50e69c403797e5d6e0c3491f0e34a8a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CharBuffer* decaf::internal::nio::CharArrayBuffer::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> whose content is a shared subsequence of this buffer's content.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> which the caller owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a5d2d8c90d964c4968f8f350f5551f037">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aeb7ba1e4d009af1a76ba212f8fdc2dd3"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::subSequence" ref="aeb7ba1e4d009af1a76ba212f8fdc2dd3" args="(int start, int end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a>* decaf::internal::nio::CharArrayBuffer::subSequence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position.The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + start, and its limit will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + end. The new <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> will be read-only if, and only if, this buffer is read-only.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index, relative to the current position, of the first character in the subsequence; must be non-negative and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>. </td></tr>
    <tr><td class="paramname">end</td><td>The index, relative to the current position, of the character following the last character in the subsequence; must be no smaller than start and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new character buffer, caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions on start and end fail.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a1d31acb1522ee27f91e415874b9489cf">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a177ea1ae3ce47a89e01a3daa6888fff6"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::_array" ref="a177ea1ae3ce47a89e01a3daa6888fff6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt;<a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&gt; <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a177ea1ae3ce47a89e01a3daa6888fff6">decaf::internal::nio::CharArrayBuffer::_array</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af27acc91350dc6eee2796f299cd99e6a"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::length" ref="af27acc91350dc6eee2796f299cd99e6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">decaf::internal::nio::CharArrayBuffer::length</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dd0e76b88bb81045aff8af4b9795690"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::offset" ref="a4dd0e76b88bb81045aff8af4b9795690" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">decaf::internal::nio::CharArrayBuffer::offset</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2da0f1500b27e4cc79d54eb2fd8f522"></a><!-- doxytag: member="decaf::internal::nio::CharArrayBuffer::readOnly" ref="ac2da0f1500b27e4cc79d54eb2fd8f522" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">decaf::internal::nio::CharArrayBuffer::readOnly</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/nio/<a class="el" href="_char_array_buffer_8h_source.html">CharArrayBuffer.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1nio.html">nio</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
