<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::internal::net::ssl::openssl::OpenSSLSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::internal::net::ssl::openssl::OpenSSLSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::internal::net::ssl::openssl::OpenSSLSocket" --><!-- doxytag: inherits="decaf::net::ssl::SSLSocket" -->
<p>Wraps a a Normal Socket object and extends or overrides functions in that class to make use of the OpenSSL Socket API.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_open_s_s_l_socket_8h_source.html">src/main/decaf/internal/net/ssl/openssl/OpenSSLSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::internal::net::ssl::openssl::OpenSSLSocket:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket__inherit__graph.png" border="0" usemap="#decaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_inherit__map" id="decaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html" title="decaf::net::ssl::SSLSocket" alt="" coords="83,160,285,189"/><area shape="rect" id="node4" href="classdecaf_1_1net_1_1_socket.html" title="decaf::net::Socket" alt="" coords="109,83,259,112"/><area shape="rect" id="node6" href="classdecaf_1_1io_1_1_closeable.html" title="Interface for a class that implements the close method." alt="" coords="107,5,261,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a34750201d92b63947b20fb662c3065cd">OpenSSLSocket</a> (<a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *parameters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#ac7176824faf99ae2f14a4585dbd8855a">OpenSSLSocket</a> (<a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *parameters, const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *address, int port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#afe109277f3766a8562c505352a2e6187">OpenSSLSocket</a> (<a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *parameters, const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *address, int port, const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *localAddress, int localPort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#ac8895af7450b75e3f34b4193318f207d">OpenSSLSocket</a> (<a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *parameters, const std::string &amp;host, int port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#abecee7a3e252fc6740a7207bea0808b7">OpenSSLSocket</a> (<a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *parameters, const std::string &amp;host, int port, const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *localAddress, int localPort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a0d28819988be4e7419bb0a6dd8b4c498">~OpenSSLSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a270f74a706878f63a4e944e691f18e13">connect</a> (const std::string &amp;host, int port, int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the specified destination, with a specified timeout value.If a connection to the remote host is not established within the specified timeout interval than an <a class="el" href="classdecaf_1_1net_1_1_socket_timeout_exception.html">SocketTimeoutException</a> is thrown. A timeout value of zero is treated as an inifinite timeout.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host name or IP address of the remote host to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port on the remote host to connect to. </td></tr>
    <tr><td class="paramname">timeout</td><td>The number of Milliseconds to wait before treating the connection as failed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Thrown if a failure occurred in the connect. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_socket_timeout_exception.html">SocketTimeoutException</a></td><td>if the timeout for connection is exceeded. </td></tr>
    <tr><td class="paramname">IllegalArguementException</td><td>if the timeout value is negative or the endpoint is invalid.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a270f74a706878f63a4e944e691f18e13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a3d02b7d2155b48ea6d2838a3a62742e9">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.Once closed a <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> cannot be connected or otherwise operated upon, a new <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> instance must be created.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while closing the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a3d02b7d2155b48ea6d2838a3a62742e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a5911158d2c7e8527b5fb1775fc30bd17">getInputStream</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the InputStream for this socket if its connected.The pointer returned is the property of the associated <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> and should not be deleted by the caller.When the returned InputStream is performing a blocking operation and the underlying connection is closed or otherwise broker the read calls will normally throw an exception to indicate the failure.Closing the InputStream will also close the underlying <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>The InputStream for this socket.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an error occurs during creation of the InputStream, also if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is not connected or the input has been shutdown previously.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a5911158d2c7e8527b5fb1775fc30bd17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1io_1_1_output_stream.html">decaf::io::OutputStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#adc961ba36ccd4f85c44985d3b3676e03">getOutputStream</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the OutputStream for this socket if it is connected.The pointer returned is the property of the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> instance and should not be deleted by the caller.Closing the returned <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> will also close the underlying <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>the OutputStream for this socket.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an error occurs during the creation of this OutputStream, or if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is closed or the output has been shutdown previously.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#adc961ba36ccd4f85c44985d3b3676e03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a7a8f072bdf94500dfc381c22a75c0f7d">shutdownInput</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the InputStream for this socket essentially marking it as EOF.The stream returns EOF for any calls to read after this method has been called.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a7a8f072bdf94500dfc381c22a75c0f7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a88fb7e78c66cdc463d7116917cf7a19a">shutdownOutput</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the OutputStream for this socket, any data already written to the socket will be sent, any further calls to OuputStream::write will throw an IOException.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a88fb7e78c66cdc463d7116917cf7a19a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a2396a0cd487555540f2b2cff86cf11d8">setOOBInline</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the OOBINLINE for this socket, by default this option is disabled.If enabled the urgent data is read inline on the Socket's InputStream, no notification is give.<dl class="return"><dt><b>Returns:</b></dt><dd>true if OOBINLINE is enabled, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_socket_exception.html" title="Exception for errors when manipulating sockets.">SocketException</a></td><td>if an error is encountered while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a2396a0cd487555540f2b2cff86cf11d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a613fc944a37386bb8edf1d28eb0b22bd">sendUrgentData</a> (int data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends on byte of urgent data to the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The value to write as urgent data, only the lower eight bits are sent.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a613fc944a37386bb8edf1d28eb0b22bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#ad0412a3832fecbbddd42fd84551dbf6f">getSupportedCipherSuites</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector containing the names of all the cipher suites that are supported by this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a>.Normally not all of these cipher suites will be enabled on the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>a vector containing the names of all the supported cipher suites.</dd></dl>
  <a href="#ad0412a3832fecbbddd42fd84551dbf6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a10023dbd1c514142f393dd02dfdd0b36">getSupportedProtocols</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector containing the names of all the protocols that could be enabled for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance.<dl class="return"><dt><b>Returns:</b></dt><dd>a vector containing the names of all the supported protocols.</dd></dl>
  <a href="#a10023dbd1c514142f393dd02dfdd0b36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a0d44a8b74d9906d6b9714aa4f9449194">getEnabledCipherSuites</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the names of all the currently enabled Cipher Suites for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>vector of the names of all enabled Cipher Suites.</dd></dl>
  <a href="#a0d44a8b74d9906d6b9714aa4f9449194"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a6a1607e558358c8816814b22f518e4bb">setEnabledCipherSuites</a> (const std::vector&lt; std::string &gt; &amp;suites)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Cipher Suites that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection.Each of the named Cipher Suites must appear in the list of supported cipher suites for this connection or an exception will be thrown.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">suites</td><td>An Vector of names for all the Cipher Suites that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the vector is empty or one of the names is invalid.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a6a1607e558358c8816814b22f518e4bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#aee7c07351c1eaf2c467a73c091a231b0">getEnabledProtocols</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the names of all the currently enabled Protocols for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>vector of the names of all enabled Protocols.</dd></dl>
  <a href="#aee7c07351c1eaf2c467a73c091a231b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a2835627682c02d1c108a814a4328b294">setEnabledProtocols</a> (const std::vector&lt; std::string &gt; &amp;protocols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Protocols that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection.Each of the named Protocols must appear in the list of supported protocols suites for this connection or an exception will be thrown.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">protocols</td><td>An Vector of names for all the Protocols that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the vector is empty or one of the names is invalid.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a2835627682c02d1c108a814a4328b294"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#ac56ebf60f6802a97a19c3b0682067bb6">startHandshake</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a handshake for this SSL Connection, this can be necessary for several reasons such as using new encryption keys, or starting a new session.When called for the first time after the socket connects this method blocks until the handshake is completed. The provider is not require to support multiple handshakes and can throw an IOException to indicate an error.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing the Handshake</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ac56ebf60f6802a97a19c3b0682067bb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a86902a685c339d45e5f53fd2fa9edbe6">setUseClientMode</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the mode that the socket uses when a handshake is initiated, client or server.This method must be called prior to any handshake attempts on this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>, once a handshake has be initiated this socket remains the the set mode; client or server, for the life of this object.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The mode setting, true for client or false for server.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if the handshake process has begun and mode is lcoked.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a86902a685c339d45e5f53fd2fa9edbe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#abcfa33b8361ee1770a8e3967466e7594">getUseClientMode</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client or Server mode, true indicates that the mode is set to Client.<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client mode, false otherwise.</dd></dl>
  <a href="#abcfa33b8361ee1770a8e3967466e7594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a6a24f429996ac595e86ced7ef48c0cf4">setNeedClientAuth</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to require that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket.This option only applies to sockets in the Server mode.If the option is enabled an the client does not provide a certificate then the handshake is considered failed and the connection is refused. Calling this method resets any previous value for this option as well as clears any value set in the setWantClientAuth method.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value indicating if a client is required to authenticate itself or not.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a6a24f429996ac595e86ced7ef48c0cf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a9a5b9f5ab301e0afecd88ca678b6842c">getNeedClientAuth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this socket is configured to require client authentication, true means that is has and that clients that failed to authenticate will be rejected.This option is only useful when the socket is operating in server mode.<dl class="return"><dt><b>Returns:</b></dt><dd>true if client authentication is required.</dd></dl>
  <a href="#a9a5b9f5ab301e0afecd88ca678b6842c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a30217f3e25ec76259b16ec86a76bffb2">setWantClientAuth</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to request that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket.This option only applies to sockets in the Server mode.If the option is enabled an the client does not provide a certificate then the handshake is considered to have succeeded, if it does send a certificate and that certificate is invalid the the handshake will fail. Calling this method resets any previous value for this option as well as clears any value set in the setNeedClientAuth method.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value indicating if a client is requested to authenticate itself or not.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a30217f3e25ec76259b16ec86a76bffb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a95db3ea93d26cfb17f9022a44b4e03c1">getWantClientAuth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this socket is configured to request client authentication, true means that is has and that clients that failed to authenticate will be rejected but that cleints that do not send a certificate are not considered to have failed authentication.This option is only useful when the socket is operating in server mode.<dl class="return"><dt><b>Returns:</b></dt><dd>true if client authentication is required.</dd></dl>
  <a href="#a95db3ea93d26cfb17f9022a44b4e03c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a639dba19df328182aca8ea5216cf3d9b">read</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the requested data from the Socket and write it into the passed in buffer.  <a href="#a639dba19df328182aca8ea5216cf3d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a295696b1a309d1c3cc400100d6d75d76">write</a> (const unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the specified data in the passed in buffer to the Socket.  <a href="#a295696b1a309d1c3cc400100d6d75d76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a43631ff59771ac17d9dcfe4c8813257f">available</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes in the Socket buffer that can be read without blocking.  <a href="#a43631ff59771ac17d9dcfe4c8813257f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Wraps a a Normal Socket object and extends or overrides functions in that class to make use of the OpenSSL Socket API. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a34750201d92b63947b20fb662c3065cd"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket" ref="a34750201d92b63947b20fb662c3065cd" args="(OpenSSLParameters *parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7176824faf99ae2f14a4585dbd8855a"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket" ref="ac7176824faf99ae2f14a4585dbd8855a" args="(OpenSSLParameters *parameters, const decaf::net::InetAddress *address, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afe109277f3766a8562c505352a2e6187"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket" ref="afe109277f3766a8562c505352a2e6187" args="(OpenSSLParameters *parameters, const decaf::net::InetAddress *address, int port, const decaf::net::InetAddress *localAddress, int localPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *&#160;</td>
          <td class="paramname"><em>localAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8895af7450b75e3f34b4193318f207d"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket" ref="ac8895af7450b75e3f34b4193318f207d" args="(OpenSSLParameters *parameters, const std::string &amp;host, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abecee7a3e252fc6740a7207bea0808b7"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket" ref="abecee7a3e252fc6740a7207bea0808b7" args="(OpenSSLParameters *parameters, const std::string &amp;host, int port, const decaf::net::InetAddress *localAddress, int localPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::net::ssl::openssl::OpenSSLSocket::OpenSSLSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_parameters.html">OpenSSLParameters</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">decaf::net::InetAddress</a> *&#160;</td>
          <td class="paramname"><em>localAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d28819988be4e7419bb0a6dd8b4c498"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::~OpenSSLSocket" ref="a0d28819988be4e7419bb0a6dd8b4c498" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::net::ssl::openssl::OpenSSLSocket::~OpenSSLSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a43631ff59771ac17d9dcfe4c8813257f"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::available" ref="a43631ff59771ac17d9dcfe4c8813257f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::internal::net::ssl::openssl::OpenSSLSocket::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of bytes in the Socket buffer that can be read without blocking. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes that can be read from the Socket without blocking.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d02b7d2155b48ea6d2838a3a62742e9"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::close" ref="a3d02b7d2155b48ea6d2838a3a62742e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.Once closed a <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> cannot be connected or otherwise operated upon, a new <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> instance must be created.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while closing the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#aa0fca683ef78b782e039d59a225ca95c">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="a270f74a706878f63a4e944e691f18e13"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::connect" ref="a270f74a706878f63a4e944e691f18e13" args="(const std::string &amp;host, int port, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to the specified destination, with a specified timeout value.If a connection to the remote host is not established within the specified timeout interval than an <a class="el" href="classdecaf_1_1net_1_1_socket_timeout_exception.html">SocketTimeoutException</a> is thrown. A timeout value of zero is treated as an inifinite timeout.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host name or IP address of the remote host to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port on the remote host to connect to. </td></tr>
    <tr><td class="paramname">timeout</td><td>The number of Milliseconds to wait before treating the connection as failed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>Thrown if a failure occurred in the connect. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_socket_timeout_exception.html">SocketTimeoutException</a></td><td>if the timeout for connection is exceeded. </td></tr>
    <tr><td class="paramname">IllegalArguementException</td><td>if the timeout value is negative or the endpoint is invalid.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#a4f215aa5c11dcee4a1e845142b102d21">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="a0d44a8b74d9906d6b9714aa4f9449194"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getEnabledCipherSuites" ref="a0d44a8b74d9906d6b9714aa4f9449194" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::internal::net::ssl::openssl::OpenSSLSocket::getEnabledCipherSuites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector containing the names of all the currently enabled Cipher Suites for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>vector of the names of all enabled Cipher Suites.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#af3ec5e4ef170d560793501d7ac3e716c">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="aee7c07351c1eaf2c467a73c091a231b0"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getEnabledProtocols" ref="aee7c07351c1eaf2c467a73c091a231b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::internal::net::ssl::openssl::OpenSSLSocket::getEnabledProtocols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector containing the names of all the currently enabled Protocols for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>vector of the names of all enabled Protocols.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a38dbc5a3b67f832ea59cbb9692458ef7">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a5911158d2c7e8527b5fb1775fc30bd17"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getInputStream" ref="a5911158d2c7e8527b5fb1775fc30bd17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a>* decaf::internal::net::ssl::openssl::OpenSSLSocket::getInputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the InputStream for this socket if its connected.The pointer returned is the property of the associated <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> and should not be deleted by the caller.When the returned InputStream is performing a blocking operation and the underlying connection is closed or otherwise broker the read calls will normally throw an exception to indicate the failure.Closing the InputStream will also close the underlying <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>The InputStream for this socket.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an error occurs during creation of the InputStream, also if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is not connected or the input has been shutdown previously.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#a8d8d8603788bd6a1c570781ce1234c5d">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="a9a5b9f5ab301e0afecd88ca678b6842c"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getNeedClientAuth" ref="a9a5b9f5ab301e0afecd88ca678b6842c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::net::ssl::openssl::OpenSSLSocket::getNeedClientAuth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this socket is configured to require client authentication, true means that is has and that clients that failed to authenticate will be rejected.This option is only useful when the socket is operating in server mode.<dl class="return"><dt><b>Returns:</b></dt><dd>true if client authentication is required.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a828defaef10ccd5f5b9bb4bb8512ff1f">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="adc961ba36ccd4f85c44985d3b3676e03"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getOutputStream" ref="adc961ba36ccd4f85c44985d3b3676e03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1io_1_1_output_stream.html">decaf::io::OutputStream</a>* decaf::internal::net::ssl::openssl::OpenSSLSocket::getOutputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the OutputStream for this socket if it is connected.The pointer returned is the property of the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> instance and should not be deleted by the caller.Closing the returned <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> will also close the underlying <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>the OutputStream for this socket.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an error occurs during the creation of this OutputStream, or if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is closed or the output has been shutdown previously.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#ae8cf82cc472a33d1d369f75734ba8094">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="ad0412a3832fecbbddd42fd84551dbf6f"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getSupportedCipherSuites" ref="ad0412a3832fecbbddd42fd84551dbf6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::internal::net::ssl::openssl::OpenSSLSocket::getSupportedCipherSuites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a vector containing the names of all the cipher suites that are supported by this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a>.Normally not all of these cipher suites will be enabled on the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl class="return"><dt><b>Returns:</b></dt><dd>a vector containing the names of all the supported cipher suites.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a248b57136c72db290800aa5efee2d0e2">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a10023dbd1c514142f393dd02dfdd0b36"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getSupportedProtocols" ref="a10023dbd1c514142f393dd02dfdd0b36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::internal::net::ssl::openssl::OpenSSLSocket::getSupportedProtocols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a vector containing the names of all the protocols that could be enabled for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance.<dl class="return"><dt><b>Returns:</b></dt><dd>a vector containing the names of all the supported protocols.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ad9865f96e3b0086ea37b64bed828d6e1">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="abcfa33b8361ee1770a8e3967466e7594"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getUseClientMode" ref="abcfa33b8361ee1770a8e3967466e7594" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::net::ssl::openssl::OpenSSLSocket::getUseClientMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client or Server mode, true indicates that the mode is set to Client.<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client mode, false otherwise.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ad193f3ac4f1e95a6dae8e138c29d62d2">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a95db3ea93d26cfb17f9022a44b4e03c1"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::getWantClientAuth" ref="a95db3ea93d26cfb17f9022a44b4e03c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::net::ssl::openssl::OpenSSLSocket::getWantClientAuth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this socket is configured to request client authentication, true means that is has and that clients that failed to authenticate will be rejected but that cleints that do not send a certificate are not considered to have failed authentication.This option is only useful when the socket is operating in server mode.<dl class="return"><dt><b>Returns:</b></dt><dd>true if client authentication is required.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a98078865be96ccdc3b24965a8224881d">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a639dba19df328182aca8ea5216cf3d9b"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::read" ref="a639dba19df328182aca8ea5216cf3d9b" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::internal::net::ssl::openssl::OpenSSLSocket::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the requested data from the Socket and write it into the passed in buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read into </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the buffer where reading should start filling. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes past offset to fill with data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the actual number of bytes read or -1 if at EOF.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs during the read. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer is Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset + length is greater than buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a613fc944a37386bb8edf1d28eb0b22bd"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::sendUrgentData" ref="a613fc944a37386bb8edf1d28eb0b22bd" args="(int data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::sendUrgentData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends on byte of urgent data to the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The value to write as urgent data, only the lower eight bits are sent.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#abe9ee374a1e07a7225af7c5c58b649a3">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="a6a1607e558358c8816814b22f518e4bb"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::setEnabledCipherSuites" ref="a6a1607e558358c8816814b22f518e4bb" args="(const std::vector&lt; std::string &gt; &amp;suites)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::setEnabledCipherSuites </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>suites</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Cipher Suites that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection.Each of the named Cipher Suites must appear in the list of supported cipher suites for this connection or an exception will be thrown.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">suites</td><td>An Vector of names for all the Cipher Suites that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the vector is empty or one of the names is invalid.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ad2948ae36921481849c9d17390baac80">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a2835627682c02d1c108a814a4328b294"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::setEnabledProtocols" ref="a2835627682c02d1c108a814a4328b294" args="(const std::vector&lt; std::string &gt; &amp;protocols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::setEnabledProtocols </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>protocols</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Protocols that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection.Each of the named Protocols must appear in the list of supported protocols suites for this connection or an exception will be thrown.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">protocols</td><td>An Vector of names for all the Protocols that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the vector is empty or one of the names is invalid.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ade5db0c2dd2b0ce3e055bc8b4e4aa356">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a6a24f429996ac595e86ced7ef48c0cf4"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::setNeedClientAuth" ref="a6a24f429996ac595e86ced7ef48c0cf4" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::setNeedClientAuth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to require that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket.This option only applies to sockets in the Server mode.If the option is enabled an the client does not provide a certificate then the handshake is considered failed and the connection is refused. Calling this method resets any previous value for this option as well as clears any value set in the setWantClientAuth method.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value indicating if a client is required to authenticate itself or not.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a650e1fc1f3f31fbae0a33d9f2a0ff746">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a2396a0cd487555540f2b2cff86cf11d8"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::setOOBInline" ref="a2396a0cd487555540f2b2cff86cf11d8" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::setOOBInline </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the value of the OOBINLINE for this socket, by default this option is disabled.If enabled the urgent data is read inline on the Socket's InputStream, no notification is give.<dl class="return"><dt><b>Returns:</b></dt><dd>true if OOBINLINE is enabled, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_socket_exception.html" title="Exception for errors when manipulating sockets.">SocketException</a></td><td>if an error is encountered while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#ac9626a100cca716039cda8d06eb11f7c">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="a86902a685c339d45e5f53fd2fa9edbe6"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::setUseClientMode" ref="a86902a685c339d45e5f53fd2fa9edbe6" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::setUseClientMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the mode that the socket uses when a handshake is initiated, client or server.This method must be called prior to any handshake attempts on this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>, once a handshake has be initiated this socket remains the the set mode; client or server, for the life of this object.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The mode setting, true for client or false for server.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if the handshake process has begun and mode is lcoked.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#aa887d76c42a4d22f8138ad286d131ac6">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a30217f3e25ec76259b16ec86a76bffb2"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::setWantClientAuth" ref="a30217f3e25ec76259b16ec86a76bffb2" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::setWantClientAuth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to request that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket.This option only applies to sockets in the Server mode.If the option is enabled an the client does not provide a certificate then the handshake is considered to have succeeded, if it does send a certificate and that certificate is invalid the the handshake will fail. Calling this method resets any previous value for this option as well as clears any value set in the setNeedClientAuth method.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value indicating if a client is requested to authenticate itself or not.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a3ccb2104f941f6caeacf1e88ca7b47b5">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a7a8f072bdf94500dfc381c22a75c0f7d"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::shutdownInput" ref="a7a8f072bdf94500dfc381c22a75c0f7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::shutdownInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuts down the InputStream for this socket essentially marking it as EOF.The stream returns EOF for any calls to read after this method has been called.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#aeda0ce287319a9cfedde52c875ace95d">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="a88fb7e78c66cdc463d7116917cf7a19a"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::shutdownOutput" ref="a88fb7e78c66cdc463d7116917cf7a19a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::shutdownOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuts down the OutputStream for this socket, any data already written to the socket will be sent, any further calls to OuputStream::write will throw an IOException.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing this operation.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1net_1_1_socket.html#aa62f731a6f3225bf7f077881066ddf7c">decaf::net::Socket</a>.</p>

</div>
</div>
<a class="anchor" id="ac56ebf60f6802a97a19c3b0682067bb6"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake" ref="ac56ebf60f6802a97a19c3b0682067bb6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::net::ssl::openssl::OpenSSLSocket::startHandshake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiates a handshake for this SSL Connection, this can be necessary for several reasons such as using new encryption keys, or starting a new session.When called for the first time after the socket connects this method blocks until the handshake is completed. The provider is not require to support multiple handshakes and can throw an IOException to indicate an error.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing the Handshake</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a17509ab175189abb81e5d32bd7e08b5f">decaf::net::ssl::SSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a295696b1a309d1c3cc400100d6d75d76"></a><!-- doxytag: member="decaf::internal::net::ssl::openssl::OpenSSLSocket::write" ref="a295696b1a309d1c3cc400100d6d75d76" args="(const unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::internal::net::ssl::openssl::OpenSSLSocket::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the specified data in the passed in buffer to the Socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to write to the socket. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the buffer where the data to write starts at. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes past offset to write.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs during the write. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer is Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset + length is greater than buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/net/ssl/openssl/<a class="el" href="_open_s_s_l_socket_8h_source.html">OpenSSLSocket.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1net.html">net</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1net_1_1ssl.html">ssl</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1net_1_1ssl_1_1openssl.html">openssl</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html">OpenSSLSocket</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
