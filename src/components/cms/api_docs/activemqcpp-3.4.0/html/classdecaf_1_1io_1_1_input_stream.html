<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::io::InputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1io_1_1_input_stream.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::io::InputStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::io::InputStream" --><!-- doxytag: inherits="decaf::io::Closeable,decaf::util::concurrent::Synchronizable" -->
<p>A base class that must be implemented by all classes wishing to provide a class that reads in a stream of bytes.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_input_stream_8h_source.html">src/main/decaf/io/InputStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::io::InputStream:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1io_1_1_input_stream__inherit__graph.png" border="0" usemap="#decaf_1_1io_1_1_input_stream_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1io_1_1_input_stream_inherit__map" id="decaf_1_1io_1_1_input_stream_inherit__map">
<area shape="rect" id="node7" href="classdecaf_1_1internal_1_1io_1_1_standard_input_stream.html" title="decaf::internal::io::StandardInputStream" alt="" coords="637,5,933,35"/><area shape="rect" id="node9" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_input_stream.html" title="An output stream for reading data from an OpenSSL Socket instance." alt="" coords="564,59,1007,88"/><area shape="rect" id="node11" href="classdecaf_1_1internal_1_1net_1_1tcp_1_1_tcp_socket_input_stream.html" title="Input stream for performing reads on a socket." alt="" coords="609,112,961,141"/><area shape="rect" id="node13" href="classdecaf_1_1io_1_1_blocking_byte_array_input_stream.html" title="This is a blocking version of a byte buffer stream." alt="" coords="636,165,935,195"/><area shape="rect" id="node15" href="classdecaf_1_1io_1_1_byte_array_input_stream.html" title="A ByteArrayInputStream contains an internal buffer that contains bytes that may be read from the stre..." alt="" coords="663,219,908,248"/><area shape="rect" id="node17" href="classdecaf_1_1io_1_1_filter_input_stream.html" title="A FilterInputStream contains some other input stream, which it uses as its basic source of data..." alt="" coords="680,272,891,301"/><area shape="rect" id="node2" href="classdecaf_1_1io_1_1_closeable.html" title="Interface for a class that implements the close method." alt="" coords="71,112,225,141"/><area shape="rect" id="node4" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="5,165,291,195"/><area shape="rect" id="node19" href="classactivemq_1_1io_1_1_logging_input_stream.html" title="activemq::io::LoggingInputStream" alt="" coords="1067,139,1320,168"/><area shape="rect" id="node21" href="classdecaf_1_1io_1_1_buffered_input_stream.html" title="A wrapper around another input stream that performs a buffered read, where it reads more data than it..." alt="" coords="1076,192,1311,221"/><area shape="rect" id="node23" href="classdecaf_1_1io_1_1_data_input_stream.html" title="A data input stream lets an application read primitive Java data types from an underlying input strea..." alt="" coords="1088,245,1299,275"/><area shape="rect" id="node25" href="classdecaf_1_1io_1_1_pushback_input_stream.html" title="A PushbackInputStream adds functionality to another input stream, namely the ability to &quot;push ba..." alt="" coords="1075,299,1312,328"/><area shape="rect" id="node27" href="classdecaf_1_1util_1_1zip_1_1_checked_input_stream.html" title="An implementation of a FilterInputStream that will maintain a Checksum of the bytes read..." alt="" coords="1056,352,1331,381"/><area shape="rect" id="node29" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance." alt="" coords="1061,405,1325,435"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#ac5f92ed522890848fc5d080c2584e740">InputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#aee74acb88e24c75b9b1ba1db27083562">~InputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a668416594975ab3b84e28450832fd1aa">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> freeing any resources that might have been acquired during the lifetime of this stream.  <a href="#a668416594975ab3b84e28450832fd1aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a4364fea883a343596df37e992e9f7977">mark</a> (int readLimit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the current position in the stream A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes.  <a href="#a4364fea883a343596df37e992e9f7977"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a9aac83307fee664c0faa397d2a9a835a">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Repositions this stream to the position at the time the mark method was last called on this input stream.  <a href="#a9aac83307fee664c0faa397d2a9a835a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a04e316403bac2ae826cb5d387bb4b6bf">markSupported</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this input stream supports the mark and reset methods.  <a href="#a04e316403bac2ae826cb5d387bb4b6bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#abd58067dcb828eae1b1c71550481011b">available</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the number of bytes available.  <a href="#abd58067dcb828eae1b1c71550481011b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#afb989ed43f6fa223d26886c37a27336a">read</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single byte from the buffer.  <a href="#afb989ed43f6fa223d26886c37a27336a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a33e2785f919cb99ac2919e303fcb8fc9">read</a> (unsigned char *buffer, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads up to size bytes of data from the input stream into an array of bytes.  <a href="#a33e2785f919cb99ac2919e303fcb8fc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#aa87ab8acf14308f9f2d71c136404ed5a">read</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads up to length bytes of data from the input stream into an array of bytes.  <a href="#aa87ab8acf14308f9f2d71c136404ed5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a4e9ec7e4e17195eb2f2d0326f07152bd">skip</a> (long long num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips over and discards n bytes of data from this input stream.  <a href="#a4e9ec7e4e17195eb2f2d0326f07152bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#aee3e6e61f4cc76a63f5661ff8df2ad98">toString</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a String representation of this object.  <a href="#aee3e6e61f4cc76a63f5661ff8df2ad98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a40e8181e868022abe611b9ae520a55b3">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the object.  <a href="#a40e8181e868022abe611b9ae520a55b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a2a30ce9b63fbac4b14b1363b66003fc0">tryLock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to Lock the object, if the lock is already held by another thread than this method returns false.  <a href="#a2a30ce9b63fbac4b14b1363b66003fc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#aa188a658fe93f718982f8d1d2d24c826">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the object.  <a href="#aa188a658fe93f718982f8d1d2d24c826"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a7e3ac5ea252dd5866306a07acfdb464e">wait</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a7e3ac5ea252dd5866306a07acfdb464e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a9051e49152c0473bb3fedcf643c6fd7c">wait</a> (long long millisecs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a9051e49152c0473bb3fedcf643c6fd7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a19c9a4c8db481bed73e7dc2708f39936">wait</a> (long long millisecs, int nanos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a19c9a4c8db481bed73e7dc2708f39936"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a6d728d0e9f83b2398ad585a5c097edba">notify</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals a waiter on this object that it can now wake up and continue.  <a href="#a6d728d0e9f83b2398ad585a5c097edba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#ab09a9b0db771414ba69922bf216edeb5">notifyAll</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the waiters on this object that it can now wake up and continue.  <a href="#ab09a9b0db771414ba69922bf216edeb5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a6ffe401a9e727d9b15fbefa543a02c06">doReadByte</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a3200d99c001f9f7116d94392deaed591">doReadArray</a> (unsigned char *buffer, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a2a7ec663798f4bf9f29b031a11ae7513">doReadArrayBounded</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A base class that must be implemented by all classes wishing to provide a class that reads in a stream of bytes. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac5f92ed522890848fc5d080c2584e740"></a><!-- doxytag: member="decaf::io::InputStream::InputStream" ref="ac5f92ed522890848fc5d080c2584e740" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::io::InputStream::InputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee74acb88e24c75b9b1ba1db27083562"></a><!-- doxytag: member="decaf::io::InputStream::~InputStream" ref="aee74acb88e24c75b9b1ba1db27083562" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::io::InputStream::~InputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abd58067dcb828eae1b1c71550481011b"></a><!-- doxytag: member="decaf::io::InputStream::available" ref="abd58067dcb828eae1b1c71550481011b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the number of bytes available. </p>
<p>The default implementation of this methods returns 0. Classes that override this method may return the total number of bytes that are currently available for reading and others may simply return a value of one indicating that there is some data avaiable. The caller should view the result of this method as an absolute.</p>
<p>The default implementation of this method returns zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes available on this input stream.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdecaf_1_1internal_1_1io_1_1_standard_input_stream.html#aa651c4b093523de81ddb01d777e6c936">decaf::internal::io::StandardInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_input_stream.html#ab18181c30dea368520180260a4b588ab">decaf::internal::net::ssl::openssl::OpenSSLSocketInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1tcp_1_1_tcp_socket_input_stream.html#a50d89e53cf789b5aa88095525b8425a2">decaf::internal::net::tcp::TcpSocketInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_blocking_byte_array_input_stream.html#a00da8d68545bb3502ad755461b91335c">decaf::io::BlockingByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#ad3d7ca8ea6a074a2cdf4e0d56b17bee6">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#aa8e319ea0ef7482b21a03bf6afcf2072">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a0f755e6f29a0bf09f6c36f9cbd901a05">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#a718a36cfaba533a0468eaa134187a6cc">decaf::io::PushbackInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a98ebc398888a57c05bd1c52f415d7a33">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a668416594975ab3b84e28450832fd1aa"></a><!-- doxytag: member="decaf::io::InputStream::close" ref="a668416594975ab3b84e28450832fd1aa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> freeing any resources that might have been acquired during the lifetime of this stream. </p>
<p>The default implementation of this method does nothing.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs while closing the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1io_1_1_closeable.html#a0eeba486c31a3a448b57beb810e4b5a2">decaf::io::Closeable</a>.</p>

<p>Reimplemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_input_stream.html#aeca8acb2d6b65eeb0118d4cdfa8e0a36">decaf::internal::net::ssl::openssl::OpenSSLSocketInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1tcp_1_1_tcp_socket_input_stream.html#a30156d772ed70287f8a5090761107be0">decaf::internal::net::tcp::TcpSocketInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_blocking_byte_array_input_stream.html#adb28ad3aa0bab82eb551597f3ada308e">decaf::io::BlockingByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#a4a9588a35d044983916fc4b8871dfed1">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a86fff21a2592c4b0e8654075b535a553">decaf::io::FilterInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a5ccc3334d7fec6890b2507f2783ca069">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a3200d99c001f9f7116d94392deaed591"></a><!-- doxytag: member="decaf::io::InputStream::doReadArray" ref="a3200d99c001f9f7116d94392deaed591" args="(unsigned char *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::doReadArray </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a17fd025ad90b2d4f729a605062493893">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a2a7ec663798f4bf9f29b031a11ae7513"></a><!-- doxytag: member="decaf::io::InputStream::doReadArrayBounded" ref="a2a7ec663798f4bf9f29b031a11ae7513" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::doReadArrayBounded </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classactivemq_1_1io_1_1_logging_input_stream.html#a6ee7383d3918d4a5cc42e930331f3dc6">activemq::io::LoggingInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_input_stream.html#a276651d7cd44cfe4487dec94b95b49e1">decaf::internal::net::ssl::openssl::OpenSSLSocketInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1tcp_1_1_tcp_socket_input_stream.html#a5f01efd33b5b686ff2c6f52e94ff457b">decaf::internal::net::tcp::TcpSocketInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_blocking_byte_array_input_stream.html#ad4d204b65e8a3e615d7e48d241ccd44b">decaf::io::BlockingByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#a37f483a36a400bc8394d44e425ccf6ef">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#a57599afe0f269076475a8fbad5618bc7">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a6d58708d0bd13acb46fa4884a0afabf3">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#ab447bd803236c45e3bd9ead8edc8baa7">decaf::io::PushbackInputStream</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_checked_input_stream.html#ac9f6b159d903ee9360fb7f435d667427">decaf::util::zip::CheckedInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a4527c3bb4d5532aa7c9b413131bb1cf9">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a6ffe401a9e727d9b15fbefa543a02c06"></a><!-- doxytag: member="decaf::io::InputStream::doReadByte" ref="a6ffe401a9e727d9b15fbefa543a02c06" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::doReadByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classactivemq_1_1io_1_1_logging_input_stream.html#a3e2bf01b49735c8e50daa7fa9904d80e">activemq::io::LoggingInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1io_1_1_standard_input_stream.html#af148402cabea22fbd5ccc6bf83bbe4c4">decaf::internal::io::StandardInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_input_stream.html#af1923dac4aeba51c15348b563d5072bd">decaf::internal::net::ssl::openssl::OpenSSLSocketInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1tcp_1_1_tcp_socket_input_stream.html#a3b38733932069744ad4ef8404cb957ee">decaf::internal::net::tcp::TcpSocketInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_blocking_byte_array_input_stream.html#ad42a48b60fd37d89c5af9dcc073dc302">decaf::io::BlockingByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#ae8190ca60e98e7ed848f682b472127f6">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#a6571d515b69238464fe423f7a86c8aa8">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#ab0514878c052c3b4b08954e6736a4173">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#a80e2754c1b93abb9395c44ea5f3f475e">decaf::io::PushbackInputStream</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_checked_input_stream.html#a1248acc86ebef61745f467469e440d8b">decaf::util::zip::CheckedInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a61fed11c09600bca777cecf51efafc2b">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a40e8181e868022abe611b9ae520a55b3"></a><!-- doxytag: member="decaf::io::InputStream::lock" ref="a40e8181e868022abe611b9ae520a55b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the object. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while locking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aeff8d806ec08a8ebef540fc059947c48">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a4364fea883a343596df37e992e9f7977"></a><!-- doxytag: member="decaf::io::InputStream::mark" ref="a4364fea883a343596df37e992e9f7977" args="(int readLimit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::mark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>readLimit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the current position in the stream A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes. </p>
<p>If a stream instance reports that marks are supported then the stream will ensure that the same bytes can be read again after the reset method is called so long the readLimit is not reached.</p>
<p>Calling mark on a closed stream instance should have no effect.</p>
<p>The default implementation of this method does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">readLimit</td><td>The max bytes read before marked position is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#aa31afad836438926a153590157696115">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#af1528c3e4ee710260e9e4d5ec633ebe4">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a669f86fa8c0da1f446b6f7ebb36110e0">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#ae27c520cef2e1e9c283172de24d73895">decaf::io::PushbackInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#aa3d00a554c5fff4805be07c8d50cf3d6">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a04e316403bac2ae826cb5d387bb4b6bf"></a><!-- doxytag: member="decaf::io::InputStream::markSupported" ref="a04e316403bac2ae826cb5d387bb4b6bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::io::InputStream::markSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if this input stream supports the mark and reset methods. </p>
<p>Whether or not mark and reset are supported is an invariant property of a particular input stream instance.</p>
<p>The default implementation of this method returns false.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this stream instance supports marks </dd></dl>

<p>Reimplemented in <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#a18cb7cb05e599f47a719e75d95a46f73">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#a1c90f1608ef28cce8fa2efbd8c528617">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a41d5a8addb10ec53949813e57d27fb1b">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#a32302aef0482f65559cbdc8f2e465e3d">decaf::io::PushbackInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a5eca95e1b22556ac68ed7fb2f7f3f811">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a6d728d0e9f83b2398ad585a5c097edba"></a><!-- doxytag: member="decaf::io::InputStream::notify" ref="a6d728d0e9f83b2398ad585a5c097edba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals a waiter on this object that it can now wake up and continue. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while notifying one of the waiting threads. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#ad62b154e5f2709b5471b00da52d0ad0b">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="ab09a9b0db771414ba69922bf216edeb5"></a><!-- doxytag: member="decaf::io::InputStream::notifyAll" ref="ab09a9b0db771414ba69922bf216edeb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::notifyAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals the waiters on this object that it can now wake up and continue. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while notifying the waiting threads. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aa3af140ed7eded4f7ff59833c0bc619a">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="aa87ab8acf14308f9f2d71c136404ed5a"></a><!-- doxytag: member="decaf::io::InputStream::read" ref="aa87ab8acf14308f9f2d71c136404ed5a" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads up to length bytes of data from the input stream into an array of bytes. </p>
<p>An attempt is made to read as many as length bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer.</p>
<p>This method blocks until input data is available, end of file is detected, or an exception is thrown.</p>
<p>If length is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value -1 is returned; otherwise, at least one byte is read and stored into b.</p>
<p>The first byte read is stored into element b[off], the next one into b[off+1], and so on. The number of bytes read is, at most, equal to length. Let k be the number of bytes actually read; these bytes will be stored in elements b[off] through b[off+k-1], leaving elements b[offset+k] through b[offset+length-1] unaffected.</p>
<p>In every case, elements b[0] through b[offset] and elements b[offset+length] through b[b.length-1] are unaffected.</p>
<p>This method called the protected virtual method doReadArrayBounded which simply calls the method <a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a6ffe401a9e727d9b15fbefa543a02c06">doReadByte()</a> repeatedly. If the first such call results in an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>, that exception is returned. If any subsequent call to <a class="el" href="classdecaf_1_1io_1_1_input_stream.html#a6ffe401a9e727d9b15fbefa543a02c06">doReadByte()</a> results in a <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>, the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into the buffer and the number of bytes read before the exception occurred is returned. The default implementation of this method blocks until the requested amount of input data has been read, end of file is detected, or an exception is thrown. Subclasses are encouraged to provide a more efficient implementation of this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The target buffer to write the read in data to. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the target buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the buffer to start inserting the read in data. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes that should be read into buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read or -1 if EOF is detected</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer passed is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if length &gt; size - offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb989ed43f6fa223d26886c37a27336a"></a><!-- doxytag: member="decaf::io::InputStream::read" ref="afb989ed43f6fa223d26886c37a27336a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a single byte from the buffer. </p>
<p>The value byte is returned as an int in the range 0 to 255. If no byte is available because the end of the stream has been reached, the value -1 is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.</p>
<p>The default implementation of this method calls the internal virtual method doReadByte which is a pure virtual method and must be overridden by all subclasses.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next byte or -1 if the end of stream is reached.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33e2785f919cb99ac2919e303fcb8fc9"></a><!-- doxytag: member="decaf::io::InputStream::read" ref="a33e2785f919cb99ac2919e303fcb8fc9" args="(unsigned char *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::io::InputStream::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads up to size bytes of data from the input stream into an array of bytes. </p>
<p>An attempt is made to read as many as size bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer.</p>
<p>This method blocks until input data is available, end of file is detected, or an exception is thrown.</p>
<p>If size is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value -1 is returned; otherwise, at least one byte is read and stored into b.</p>
<p>This method called the protected virtual method doReadArray which by default is the same as calling read( buffer, size, 0, size ). Subclasses can customize the behavior of this method by overriding the doReadArray method to provide a better performing read operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The target buffer to write the read in data to. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the target buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read or -1 if EOF is detected</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer passed is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aac83307fee664c0faa397d2a9a835a"></a><!-- doxytag: member="decaf::io::InputStream::reset" ref="a9aac83307fee664c0faa397d2a9a835a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repositions this stream to the position at the time the mark method was last called on this input stream. </p>
<p>If the method markSupported returns true, then: * If the method mark has not been called since the stream was created, or the number of bytes read from the stream since mark was last called is larger than the argument to mark at that last call, then an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> might be thrown. * If such an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to mark (or since the start of the file, if mark has not been called) will be resupplied to subsequent callers of the read method, followed by any bytes that otherwise would have been the next input data as of the time of the call to reset.</p>
<p>If the method markSupported returns false, then: * The call to reset may throw an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>. * If an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the read method depend on the particular type of the input stream.</p>
<p>The default implementation of this method throws an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#ac403e88b060a105acd8dd1c52473585b">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#a9fe2097ed89d7f233ec5d71a07e359a5">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a26b2960b011babbb14e532b580bc5bfb">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#a62f7b0c6d3b160b0f3eea24ba95a8126">decaf::io::PushbackInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a79c9bffe9dbf065e96d774820d1a348e">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a4e9ec7e4e17195eb2f2d0326f07152bd"></a><!-- doxytag: member="decaf::io::InputStream::skip" ref="a4e9ec7e4e17195eb2f2d0326f07152bd" args="(long long num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::io::InputStream::skip </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skips over and discards n bytes of data from this input stream. </p>
<p>The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. This may result from any of a number of conditions; reaching end of file before n bytes have been skipped is only one possibility. The actual number of bytes skipped is returned.</p>
<p>The skip method of <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> creates a byte array and then repeatedly reads into it until num bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The number of bytes to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>total bytes skipped</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the concrete stream class does not support skipping bytes. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket_input_stream.html#a7f8329a30fc45559b8c3dccf11398258">decaf::internal::net::ssl::openssl::OpenSSLSocketInputStream</a>, <a class="el" href="classdecaf_1_1internal_1_1net_1_1tcp_1_1_tcp_socket_input_stream.html#acbd0f3d818ad3a8b801fbb99124a16dc">decaf::internal::net::tcp::TcpSocketInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_blocking_byte_array_input_stream.html#aa1bbb0bcefa1f7875da6e849063aad7e">decaf::io::BlockingByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_buffered_input_stream.html#a7294c56d2164da76df46668bc74681d9">decaf::io::BufferedInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_byte_array_input_stream.html#a6e719a173d95d05354343c135fff0601">decaf::io::ByteArrayInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a19d847009df788eb53c1d9dea7cbe0df">decaf::io::FilterInputStream</a>, <a class="el" href="classdecaf_1_1io_1_1_pushback_input_stream.html#ad9ea3573fa4c51ce2bfa2f1e713afd91">decaf::io::PushbackInputStream</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_checked_input_stream.html#ac381cf3ce7737a9946c5efc4f3165bb3">decaf::util::zip::CheckedInputStream</a>, and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#add21d387d1b17bcfd9cbd642e2f56095">decaf::util::zip::InflaterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="aee3e6e61f4cc76a63f5661ff8df2ad98"></a><!-- doxytag: member="decaf::io::InputStream::toString" ref="aee3e6e61f4cc76a63f5661ff8df2ad98" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string decaf::io::InputStream::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output a String representation of this object. </p>
<p>The default version of this method just prints the Class Name.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string representation of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a30ce9b63fbac4b14b1363b66003fc0"></a><!-- doxytag: member="decaf::io::InputStream::tryLock" ref="a2a30ce9b63fbac4b14b1363b66003fc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::io::InputStream::tryLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to Lock the object, if the lock is already held by another thread than this method returns false. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the lock was acquired, false if it is already held by another thread.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while locking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a6aa79e4c2590ec4387d7bb2b7d265c47">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="aa188a658fe93f718982f8d1d2d24c826"></a><!-- doxytag: member="decaf::io::InputStream::unlock" ref="aa188a658fe93f718982f8d1d2d24c826" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the object. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while unlocking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aabb6c431936a7d4c9810a5f1a99bde21">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a9051e49152c0473bb3fedcf643c6fd7c"></a><!-- doxytag: member="decaf::io::InputStream::wait" ref="a9051e49152c0473bb3fedcf643c6fd7c" args="(long long millisecs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>millisecs</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling. This wait will timeout after the specified time interval.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>the time in milliseconds to wait, or WAIT_INIFINITE</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a84939d5f17b846ba0aeb5824ec6fff41">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3ac5ea252dd5866306a07acfdb464e"></a><!-- doxytag: member="decaf::io::InputStream::wait" ref="a7e3ac5ea252dd5866306a07acfdb464e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a2f7a5619b8800c295626983b9c7808a6">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a19c9a4c8db481bed73e7dc2708f39936"></a><!-- doxytag: member="decaf::io::InputStream::wait" ref="a19c9a4c8db481bed73e7dc2708f39936" args="(long long millisecs, int nanos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::io::InputStream::wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>millisecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling. This wait will timeout after the specified time interval. This method is similar to the one argument wait function except that it add a finer grained control over the amount of time that it waits by adding in the additional nanosecond argument.</p>
<p>NOTE: The ability to wait accurately at a nanosecond scale depends on the platform and OS that the Decaf API is running on, some systems do not provide an accurate enough clock to provide this level of granularity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>the time in milliseconds to wait, or WAIT_INIFINITE </td></tr>
    <tr><td class="paramname">nanos</td><td>additional time in nanoseconds with a range of 0-999999</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if an error occurs or the nanos argument is not in the range of [0-999999] </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a954b500f0e3cba3a366da91e210893ea">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/io/<a class="el" href="_input_stream_8h_source.html">InputStream.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1io.html">io</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html">InputStream</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
