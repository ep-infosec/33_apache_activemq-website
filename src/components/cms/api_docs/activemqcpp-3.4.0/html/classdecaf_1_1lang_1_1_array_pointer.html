<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::lang::ArrayPointer&lt; T, REFCOUNTER &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1lang_1_1_array_pointer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>decaf::lang::ArrayPointer&lt; T, REFCOUNTER &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::lang::ArrayPointer" -->
<p>Decaf's implementation of a Smart <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> that is a template on a Type and is <a class="el" href="classdecaf_1_1lang_1_1_thread.html" title="A Thread is a concurrent unit of execution.">Thread</a> Safe if the default Reference Counter is used.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_array_pointer_8h_source.html">src/main/decaf/lang/ArrayPointer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ArrayData</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6757d0fb15a239d53a19a6b162c2bad4">PointerType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#afe0a40bc8e5fd392fbcd315b35c65dcb">ReferenceType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a7a0cf85c453b3a7dbbe06a2edc142a18">ConstReferenceType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef REFCOUNTER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a5596608cab9c331e85706146faa24b69">CounterType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6011d5fa339856a420a61167823587d2">ArrayPointer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#a6011d5fa339856a420a61167823587d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#aa9ad91e87313eb655585dc0c78464bae">ArrayPointer</a> (int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance and allocates an internal array that is sized using the passed in size value.  <a href="#aa9ad91e87313eb655585dc0c78464bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#aeced701b2d05f41ab580d511a6077fa8">ArrayPointer</a> (int size, const T &amp;fillWith)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance and allocates an internal array that is sized using the passed in size value.  <a href="#aeced701b2d05f41ab580d511a6077fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#abbdde07c3ddb70accaeaa40faeb93382">ArrayPointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6757d0fb15a239d53a19a6b162c2bad4">PointerType</a> value, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Constructor, creates an <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> that contains value with a single reference.  <a href="#abbdde07c3ddb70accaeaa40faeb93382"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#ac07012b90c09336bfe59aab2ccf00fd2">ArrayPointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac07012b90c09336bfe59aab2ccf00fd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#ac4bd0fe2b5e0c5225487910b5ea16886">~ArrayPointer</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a21ee37584b3749f70e76bdbd70b2eba3">reset</a> (T *value, int size=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> to hold the new value.  <a href="#a21ee37584b3749f70e76bdbd70b2eba3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a8b8ea3b54df4136ca0df53eb8d876f49">release</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> held and resets the internal pointer value to Null.  <a href="#a8b8ea3b54df4136ca0df53eb8d876f49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6757d0fb15a239d53a19a6b162c2bad4">PointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a3b2ad146dcc86f913118eea052a83555">get</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the real array pointer that is contained within this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a>.  <a href="#a3b2ad146dcc86f913118eea052a83555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#aef250fd7bc5c384854a5229587b940b3">length</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of the contained array or zero if the array is NULL.  <a href="#aef250fd7bc5c384854a5229587b940b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a08a4cde6739e5586bc347a25e847bfde">swap</a> (<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdecaf_1_1lang_1_1_exception.html">Exception</a> Safe Swap Function.  <a href="#a08a4cde6739e5586bc347a25e847bfde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a883b994fce7d7161c77a0ee00c7e016e">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance that is a clone of the value contained in this <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a>.  <a href="#a883b994fce7d7161c77a0ee00c7e016e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a5a222a0c185f79f7200da4a5a53709f1">operator=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;right)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value of right to this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> and increments the reference Count.  <a href="#a5a222a0c185f79f7200da4a5a53709f1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a4eae9fb71fabe45cefb5210489df6953">operator=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T1, R1 &gt; &amp;right)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#afe0a40bc8e5fd392fbcd315b35c65dcb">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a484bcbf8ce80afa63cbc9a6c9dcedac9">operator[]</a> (int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference Operator, returns a reference to the Contained value.  <a href="#a484bcbf8ce80afa63cbc9a6c9dcedac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a7a0cf85c453b3a7dbbe06a2edc142a18">ConstReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a95ae65aa64239bdbc6892f38a05599fc">operator[]</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a964b9cbb994599ea731b5528cb8648ca">operator!</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a7d6314637c482dcc5347aa4c43e76988">operator==</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T1, R1 &gt; &amp;right) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a77c78a26f007dcdb8cc727758f4d6150">operator!=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T1, R1 &gt; &amp;right) const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a73e387fe0cf24728856029079d8f3243">operator==</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;left, const T *right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a793abe4e5a1f782c015e52a67dbe0885">operator==</a> (const T *left, const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a53dd17bdd0849a005b21cdeb7dcb89c1">operator!=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;left, const T *right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a48d41881242897b50cda9750f5750e52">operator!=</a> (const T *left, const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> &amp;right)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt;<br/>
 class decaf::lang::ArrayPointer&lt; T, REFCOUNTER &gt;</h3>

<p>Decaf's implementation of a Smart <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> that is a template on a Type and is <a class="el" href="classdecaf_1_1lang_1_1_thread.html" title="A Thread is a concurrent unit of execution.">Thread</a> Safe if the default Reference Counter is used. </p>
<p>This <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> type allows for the substitution of different Reference Counter implementations which provide a means of using invasive reference counting if desired using a custom implementation of <code>ReferenceCounter</code>. </p>
<p>The Decaf smart pointer provide comparison operators for comparing <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> instances in the same manner as normal pointer, except that it does not provide an overload of operators ( &lt;, &lt;=, &gt;, &gt;= ). To allow use of a <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> in a STL container that requires it, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> provides an implementation of std::less.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a7a0cf85c453b3a7dbbe06a2edc142a18"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ConstReferenceType" ref="a7a0cf85c453b3a7dbbe06a2edc142a18" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a7a0cf85c453b3a7dbbe06a2edc142a18">ConstReferenceType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5596608cab9c331e85706146faa24b69"></a><!-- doxytag: member="decaf::lang::ArrayPointer::CounterType" ref="a5596608cab9c331e85706146faa24b69" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef REFCOUNTER <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a5596608cab9c331e85706146faa24b69">CounterType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6757d0fb15a239d53a19a6b162c2bad4"></a><!-- doxytag: member="decaf::lang::ArrayPointer::PointerType" ref="a6757d0fb15a239d53a19a6b162c2bad4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6757d0fb15a239d53a19a6b162c2bad4">PointerType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afe0a40bc8e5fd392fbcd315b35c65dcb"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ReferenceType" ref="afe0a40bc8e5fd392fbcd315b35c65dcb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#afe0a40bc8e5fd392fbcd315b35c65dcb">ReferenceType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6011d5fa339856a420a61167823587d2"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ArrayPointer" ref="a6011d5fa339856a420a61167823587d2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Constructor. </p>
<p>Initialized the contained array pointer to NULL, using the subscript operator results in an exception unless reset to contain a real value. </p>

<p>Referenced by <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a883b994fce7d7161c77a0ee00c7e016e">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::clone()</a>, and <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a21ee37584b3749f70e76bdbd70b2eba3">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9ad91e87313eb655585dc0c78464bae"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ArrayPointer" ref="aa9ad91e87313eb655585dc0c78464bae" args="(int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance and allocates an internal array that is sized using the passed in size value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the array to allocate for this <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeced701b2d05f41ab580d511a6077fa8"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ArrayPointer" ref="aeced701b2d05f41ab580d511a6077fa8" args="(int size, const T &amp;fillWith)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillWith</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance and allocates an internal array that is sized using the passed in size value. </p>
<p>The array elements are initialized with the given value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the array to allocate for this <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance. </td></tr>
    <tr><td class="paramname">fillWith</td><td>The value to initialize each element of the newly allocated array with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbdde07c3ddb70accaeaa40faeb93382"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ArrayPointer" ref="abbdde07c3ddb70accaeaa40faeb93382" args="(const PointerType value, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6757d0fb15a239d53a19a6b162c2bad4">PointerType</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicit Constructor, creates an <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> that contains value with a single reference. </p>
<p>This object now has ownership until a call to release.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The pointer to the instance of the array we are taking ownership of. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array this object is taking ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac07012b90c09336bfe59aab2ccf00fd2"></a><!-- doxytag: member="decaf::lang::ArrayPointer::ArrayPointer" ref="ac07012b90c09336bfe59aab2ccf00fd2" args="(const ArrayPointer &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies the value contained in the <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> to the new instance and increments the reference counter. </p>

</div>
</div>
<a class="anchor" id="ac4bd0fe2b5e0c5225487910b5ea16886"></a><!-- doxytag: member="decaf::lang::ArrayPointer::~ArrayPointer" ref="ac4bd0fe2b5e0c5225487910b5ea16886" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::~<a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a883b994fce7d7161c77a0ee00c7e016e"></a><!-- doxytag: member="decaf::lang::ArrayPointer::clone" ref="a883b994fce7d7161c77a0ee00c7e016e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a> <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> instance that is a clone of the value contained in this <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> that contains a copy of the data in this <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b2ad146dcc86f913118eea052a83555"></a><!-- doxytag: member="decaf::lang::ArrayPointer::get" ref="a3b2ad146dcc86f913118eea052a83555" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a6757d0fb15a239d53a19a6b162c2bad4">PointerType</a> <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the real array pointer that is contained within this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a>. </p>
<p>This is not really safe since the caller could delete or alter the pointer but it mimics the STL auto_ptr and gives access in cases where the caller absolutely needs the real <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a>. Use at your own risk.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the contained pointer. </dd></dl>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1348b8a92975ef48222727245f6f4474">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#abb7d73a4cd2d1eb5736d1b263ce10a0f">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAllAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7ec6efcb0c6fcfa7f7ea144a3e928a97">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addIfAbsent()</a>, <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a883b994fce7d7161c77a0ee00c7e016e">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::clone()</a>, <a class="el" href="classdecaf_1_1lang_1_1_array_pointer_comparator.html#a4dc84a0f52e977092ec22ea8d5fba686">decaf::lang::ArrayPointerComparator&lt; T, R &gt;::compare()</a>, <a class="el" href="namespacedecaf_1_1lang.html#aed87f073c88933900a27cfdafe391fa8">decaf::lang::operator!=()</a>, <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a77c78a26f007dcdb8cc727758f4d6150">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::operator!=()</a>, <a class="el" href="structstd_1_1less_3_01decaf_1_1lang_1_1_array_pointer_3_01_t_01_4_01_4.html#aa6ecaf4cc192d7ee6a143d595c78d381">std::less&lt; decaf::lang::ArrayPointer&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="classdecaf_1_1lang_1_1_array_pointer_comparator.html#afa4fed35261293641fa045fb6b990b28">decaf::lang::ArrayPointerComparator&lt; T, R &gt;::operator()()</a>, <a class="el" href="namespacedecaf_1_1lang.html#aaeafb88074719fdfd5f6a73ca4dfcaeb">decaf::lang::operator==()</a>, <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a7d6314637c482dcc5347aa4c43e76988">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::operator==()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afaa8a997b2001dd3eac1393ab0ed24ca">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::removeAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a09dc6cc12d27c0099ba772cb1d805d62">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::removeAt()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9e7261248ccbbf2271773a027435037e">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::retainAll()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1155ffa7088e44b057e4525ecbc475ce">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="aef250fd7bc5c384854a5229587b940b3"></a><!-- doxytag: member="decaf::lang::ArrayPointer::length" ref="aef250fd7bc5c384854a5229587b940b3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current size of the contained array or zero if the array is NULL. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the array or zero if the array is NULL </dd></dl>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1348b8a92975ef48222727245f6f4474">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#abb7d73a4cd2d1eb5736d1b263ce10a0f">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAllAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7ec6efcb0c6fcfa7f7ea144a3e928a97">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addIfAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a8ab743968eaf8448ac03d85012198301">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator::ArrayListIterator()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9d1a9ed9c5c7ee9130d742c63f91c7bd">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::contains()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a335e703f5eaa0d9c5de377a0b275f9c2">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a8adaf616d9b83c3bc9f748c20fa2692a">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::indexOf()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ab1bc60cf328e1b5e12b1f5cacea02eee">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::lastIndexOf()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afaa8a997b2001dd3eac1393ab0ed24ca">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::removeAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a09dc6cc12d27c0099ba772cb1d805d62">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::removeAt()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9e7261248ccbbf2271773a027435037e">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::retainAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1155ffa7088e44b057e4525ecbc475ce">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::set()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a00ef7324a7dd2436bbcf2efca83db88d">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::toArray()</a>.</p>

</div>
</div>
<a class="anchor" id="a964b9cbb994599ea731b5528cb8648ca"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator!" ref="a964b9cbb994599ea731b5528cb8648ca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a77c78a26f007dcdb8cc727758f4d6150"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator!=" ref="a77c78a26f007dcdb8cc727758f4d6150" args="(const ArrayPointer&lt; T1, R1 &gt; &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4eae9fb71fabe45cefb5210489df6953"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator=" ref="a4eae9fb71fabe45cefb5210489df6953" args="(const ArrayPointer&lt; T1, R1 &gt; &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&amp; <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a222a0c185f79f7200da4a5a53709f1"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator=" ref="a5a222a0c185f79f7200da4a5a53709f1" args="(const ArrayPointer &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&amp; <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns the value of right to this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> and increments the reference Count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>- <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> on the right hand side of an operator= call to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d6314637c482dcc5347aa4c43e76988"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator==" ref="a7d6314637c482dcc5347aa4c43e76988" args="(const ArrayPointer&lt; T1, R1 &gt; &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a484bcbf8ce80afa63cbc9a6c9dcedac9"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator[]" ref="a484bcbf8ce80afa63cbc9a6c9dcedac9" args="(int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#afe0a40bc8e5fd392fbcd315b35c65dcb">ReferenceType</a> <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereference Operator, returns a reference to the Contained value. </p>
<p>This method throws an NullPointerException if the contained value is NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to the contained pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the contained value is Null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95ae65aa64239bdbc6892f38a05599fc"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator[]" ref="a95ae65aa64239bdbc6892f38a05599fc" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a7a0cf85c453b3a7dbbe06a2edc142a18">ConstReferenceType</a> <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b8ea3b54df4136ca0df53eb8d876f49"></a><!-- doxytag: member="decaf::lang::ArrayPointer::release" ref="a8b8ea3b54df4136ca0df53eb8d876f49" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> held and resets the internal pointer value to Null. </p>
<p>This method is not guaranteed to be safe if the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> is held by more than one object or this method is called from more than one thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The new value to contain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer instance that was held by this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> object, the pointer is no longer owned by this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> and won't be freed when this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> goes out of scope. </dd></dl>

<p>Referenced by <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#aa9ad91e87313eb655585dc0c78464bae">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::ArrayPointer()</a>.</p>

</div>
</div>
<a class="anchor" id="a21ee37584b3749f70e76bdbd70b2eba3"></a><!-- doxytag: member="decaf::lang::ArrayPointer::reset" ref="a21ee37584b3749f70e76bdbd70b2eba3" args="(T *value, int size=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">ArrayPointer</a> to hold the new value. </p>
<p>Before the new value is stored reset checks if the old value should be destroyed and if so calls delete. Call reset with a value of NULL is supported and acts to set this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> to a NULL pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new array pointer value to contain. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the new array value this object now contains. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08a4cde6739e5586bc347a25e847bfde"></a><!-- doxytag: member="decaf::lang::ArrayPointer::swap" ref="a08a4cde6739e5586bc347a25e847bfde" args="(ArrayPointer &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">decaf::lang::ArrayPointer</a>&lt; T, REFCOUNTER &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classdecaf_1_1lang_1_1_exception.html">Exception</a> Safe Swap Function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value to swap with this. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a5a222a0c185f79f7200da4a5a53709f1">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::operator=()</a>, and <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#a08a4cde6739e5586bc347a25e847bfde">decaf::lang::ArrayPointer&lt; decaf::util::LinkedList&lt; Pointer&lt; MessageDispatch &gt; &gt; &gt;::swap()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a53dd17bdd0849a005b21cdeb7dcb89c1"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator!=" ref="a53dd17bdd0849a005b21cdeb7dcb89c1" args="(const ArrayPointer &amp;left, const T *right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a48d41881242897b50cda9750f5750e52"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator!=" ref="a48d41881242897b50cda9750f5750e52" args="(const T *left, const ArrayPointer &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a73e387fe0cf24728856029079d8f3243"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator==" ref="a73e387fe0cf24728856029079d8f3243" args="(const ArrayPointer &amp;left, const T *right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a793abe4e5a1f782c015e52a67dbe0885"></a><!-- doxytag: member="decaf::lang::ArrayPointer::operator==" ref="a793abe4e5a1f782c015e52a67dbe0885" args="(const T *left, const ArrayPointer &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/lang/<a class="el" href="_array_pointer_8h_source.html">ArrayPointer.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1lang.html">lang</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
