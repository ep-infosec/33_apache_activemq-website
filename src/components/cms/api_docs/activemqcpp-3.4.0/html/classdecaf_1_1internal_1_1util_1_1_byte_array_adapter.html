<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::internal::util::ByteArrayAdapter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::internal::util::ByteArrayAdapter Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::internal::util::ByteArrayAdapter" -->
<p>This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on the same base byte array without copying data.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_array_adapter_8h_source.html">src/main/decaf/internal/util/ByteArrayAdapter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><b>Array</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a129fc709f9c0dd4107afc2b4ded1d69a">ByteArrayAdapter</a> (int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that is allocated internally and is then owned and deleted when this object is deleted.  <a href="#a129fc709f9c0dd4107afc2b4ded1d69a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a9f1ee6fbf6c07881a5a1eca7af9df6ff">ByteArrayAdapter</a> (unsigned char *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a9f1ee6fbf6c07881a5a1eca7af9df6ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8697a7ae20c23b149373a29c4a0da4bf">ByteArrayAdapter</a> (char *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a8697a7ae20c23b149373a29c4a0da4bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ac733ad44be96cc14a9d64c275f81fa43">ByteArrayAdapter</a> (double *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#ac733ad44be96cc14a9d64c275f81fa43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a9fc613305289bb100de9a5bce35e819f">ByteArrayAdapter</a> (float *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a9fc613305289bb100de9a5bce35e819f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a728d90f07cafdcbb940fd29e023b7807">ByteArrayAdapter</a> (long long *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a728d90f07cafdcbb940fd29e023b7807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a713178b4fa8a601d110f03c8729ad23b">ByteArrayAdapter</a> (int *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a713178b4fa8a601d110f03c8729ad23b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a09ca92ea3548903921e93dd804865a9f">ByteArrayAdapter</a> (short *array, int size, bool own=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a09ca92ea3548903921e93dd804865a9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#abf0b78333ebfb2f49f043fd6f3b18948">~ByteArrayAdapter</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a2f77697fb426146a7302f2ebee5e297c">getCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array.  <a href="#a2f77697fb426146a7302f2ebee5e297c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8ec6e02f6a12c189fb0308c9893d88ef">getCharCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains chars.  <a href="#a8ec6e02f6a12c189fb0308c9893d88ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a65a3d1a278ce5ef5846acb38e6607519">getDoubleCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains doubles.  <a href="#a65a3d1a278ce5ef5846acb38e6607519"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8d300e5b319be6b52553205aba23509e">getFloatCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains doubles.  <a href="#a8d300e5b319be6b52553205aba23509e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a99d163d012791c43d190baa0b1476791">getLongCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains doubles.  <a href="#a99d163d012791c43d190baa0b1476791"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae0cbdaf8811b42b67d27c979053687d0">getIntCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains ints.  <a href="#ae0cbdaf8811b42b67d27c979053687d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#acd2b054061171b2203eb6ae7f399d4f1">getShortCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains shorts.  <a href="#acd2b054061171b2203eb6ae7f399d4f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a3c624ccc9090ed86206f513646fed8bc">getByteArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a3c624ccc9090ed86206f513646fed8bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a78aa44ef21b2721025716d6977498d01">getCharArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a78aa44ef21b2721025716d6977498d01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a97b2e502b0ec09e58d9793852817fffa">getShortArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a97b2e502b0ec09e58d9793852817fffa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#afd942eeec67062fd63136ca2a1a9d5a8">getIntArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#afd942eeec67062fd63136ca2a1a9d5a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a7acd75e86a282814f79e3dc2d69e553d">getLongArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a7acd75e86a282814f79e3dc2d69e553d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a6ec9dfb41f81a6652aa6b5aab651e4f4">getDoubleArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a6ec9dfb41f81a6652aa6b5aab651e4f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#acb4c0a6c062feda0bef44dc035d9b91e">getFloatArray</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#acb4c0a6c062feda0bef44dc035d9b91e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a6dfd6373e8c2b327057998fa91ebf79d">read</a> (unsigned char *buffer, int size, int offset, int length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from the Byte array starting at the specified offset and reading the specified length.  <a href="#a6dfd6373e8c2b327057998fa91ebf79d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a0857e62a493c01a56e926e2cca7025ee">write</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes from the Byte array given, starting at the specified offset and writing the specified amount of data into this objects internal array.  <a href="#a0857e62a493c01a56e926e2cca7025ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8e4f9367846260c30f864e35336c7a23">resize</a> (int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the underlying array to the new given size, preserving all the Data that was previously in the array, unless the resize is smaller than the current size in which case only the data that will fit into the new array is preserved.  <a href="#a8e4f9367846260c30f864e35336c7a23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a15e748c8c2f300b5c6669c391de6dcd4">clear</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all data from that Array, setting the underlying bytes to zero.  <a href="#a15e748c8c2f300b5c6669c391de6dcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ab07fac85b8d56ac42158fe5f99e156d8">operator[]</a> (int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> to be indexed as a standard array.  <a href="#ab07fac85b8d56ac42158fe5f99e156d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a615c80f6585ed4ea2ca597be21860683">operator[]</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae8a1a7092425a5b51f2181b7289c531b">get</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.  <a href="#ae8a1a7092425a5b51f2181b7289c531b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#af999e971a4ea7f5bb1dc32cfc3b1f5d3">getChar</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte at the given index and returns it.  <a href="#af999e971a4ea7f5bb1dc32cfc3b1f5d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a592d4bb8b2d5c76bec3754b34bcdfca4">getDouble</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.  <a href="#a592d4bb8b2d5c76bec3754b34bcdfca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae4f899c3f36e51b69ebad06b206e7875">getDoubleAt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given byte index and returns it.  <a href="#ae4f899c3f36e51b69ebad06b206e7875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aa9f37f27dd2d7ee9574674fa7d72eeb7">getFloat</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.  <a href="#aa9f37f27dd2d7ee9574674fa7d72eeb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a40fefaa23edba36a625f1dc285529bfb">getFloatAt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given byte index and returns it.  <a href="#a40fefaa23edba36a625f1dc285529bfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aca8e87b3d2e0481ef7f87ce18ba7af0e">getLong</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.  <a href="#aca8e87b3d2e0481ef7f87ce18ba7af0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a2688a33d7df9c95c1ecfe35895db2a81">getLongAt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given byte index and returns it.  <a href="#a2688a33d7df9c95c1ecfe35895db2a81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a5a6112c2b9c8f9887b40822292d567cc">getInt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.  <a href="#a5a6112c2b9c8f9887b40822292d567cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a6d973809765ee8b5b33fd10a927c8b10">getIntAt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given byte index and returns it.  <a href="#a6d973809765ee8b5b33fd10a927c8b10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a50991610ce4f40ddbfdbc40b5701022c">getShort</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads two bytes at the given index and returns it.  <a href="#a50991610ce4f40ddbfdbc40b5701022c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#af7bde9ec83b4c69a6e164721dc665a65">getShortAt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads two bytes at the given byte index and returns it.  <a href="#af7bde9ec83b4c69a6e164721dc665a65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ac7bd95554124bb5a28f19f3c71c9155d">put</a> (int index, unsigned char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte into this buffer at the given index.  <a href="#ac7bd95554124bb5a28f19f3c71c9155d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aa5423888295ce5eb22309f0799878b0a">putChar</a> (int index, char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte containing the given value, into this buffer at the given index.  <a href="#aa5423888295ce5eb22309f0799878b0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a04781d674d2904e7486b500199fbc880">putDouble</a> (int index, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.  <a href="#a04781d674d2904e7486b500199fbc880"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a7e8dcc06095daacc4fcb354ea2a65aee">putDoubleAt</a> (int index, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given byte index.  <a href="#a7e8dcc06095daacc4fcb354ea2a65aee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8c97675a65adb7d964b2acd460f08747">putFloat</a> (int index, float value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.  <a href="#a8c97675a65adb7d964b2acd460f08747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae59dd74fb3affbc0e33351dc233b3710">putFloatAt</a> (int index, float value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given byte index.  <a href="#ae59dd74fb3affbc0e33351dc233b3710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#adcca10347197d3e391c94c632534d2c0">putLong</a> (int index, long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.  <a href="#adcca10347197d3e391c94c632534d2c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a2f3ac887d4e6c3fd1a7b60176cb95049">putLongAt</a> (int index, long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given byte index.  <a href="#a2f3ac887d4e6c3fd1a7b60176cb95049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aedb948bdbcd08fc5faa57eb4297b977b">putInt</a> (int index, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.  <a href="#aedb948bdbcd08fc5faa57eb4297b977b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a5bec39a3dbaf86c534eb77410e7ec45e">putIntAt</a> (int index, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given byte index.  <a href="#a5bec39a3dbaf86c534eb77410e7ec45e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a1ce00b38db02f687041d274a50b1d4f1">putShort</a> (int index, short value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the given index.  <a href="#a1ce00b38db02f687041d274a50b1d4f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ab705235270f67acf6dc2323821a21fd9">putShortAt</a> (int index, short value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the given byte index.  <a href="#ab705235270f67acf6dc2323821a21fd9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on the same base byte array without copying data. </p>
<p>All the array types are mapped down to a byte array and methods are supplied for accessing the data in any of the primitive type forms.</p>
<p>Methods in this class that do not return a specific value return a reference to this object so that calls can be chained.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a129fc709f9c0dd4107afc2b4ded1d69a"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a129fc709f9c0dd4107afc2b4ded1d69a" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that is allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f1ee6fbf6c07881a5a1eca7af9df6ff"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a9f1ee6fbf6c07881a5a1eca7af9df6ff" args="(unsigned char *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8697a7ae20c23b149373a29c4a0da4bf"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a8697a7ae20c23b149373a29c4a0da4bf" args="(char *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac733ad44be96cc14a9d64c275f81fa43"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="ac733ad44be96cc14a9d64c275f81fa43" args="(double *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fc613305289bb100de9a5bce35e819f"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a9fc613305289bb100de9a5bce35e819f" args="(float *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a728d90f07cafdcbb940fd29e023b7807"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a728d90f07cafdcbb940fd29e023b7807" args="(long long *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a713178b4fa8a601d110f03c8729ad23b"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a713178b4fa8a601d110f03c8729ad23b" args="(int *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09ca92ea3548903921e93dd804865a9f"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter" ref="a09ca92ea3548903921e93dd804865a9f" args="(short *array, int size, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf0b78333ebfb2f49f043fd6f3b18948"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::~ByteArrayAdapter" ref="abf0b78333ebfb2f49f043fd6f3b18948" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::util::ByteArrayAdapter::~ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a15e748c8c2f300b5c6669c391de6dcd4"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::clear" ref="a15e748c8c2f300b5c6669c391de6dcd4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear all data from that Array, setting the underlying bytes to zero. </p>

</div>
</div>
<a class="anchor" id="ae8a1a7092425a5b51f2181b7289c531b"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::get" ref="ae8a1a7092425a5b51f2181b7289c531b" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char decaf::internal::util::ByteArrayAdapter::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Absolute get method. </p>
<p>Reads the byte at the given index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>If index is not smaller than the buffer's limit or is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c624ccc9090ed86206f513646fed8bc"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getByteArray" ref="a3c624ccc9090ed86206f513646fed8bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char* decaf::internal::util::ByteArrayAdapter::getByteArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an unsigned char* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f77697fb426146a7302f2ebee5e297c"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getCapacity" ref="a2f77697fb426146a7302f2ebee5e297c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="af999e971a4ea7f5bb1dc32cfc3b1f5d3"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getChar" ref="af999e971a4ea7f5bb1dc32cfc3b1f5d3" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::util::ByteArrayAdapter::getChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads one byte at the given index and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>If index is not smaller than the buffer's limit or is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78aa44ef21b2721025716d6977498d01"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getCharArray" ref="a78aa44ef21b2721025716d6977498d01" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* decaf::internal::util::ByteArrayAdapter::getCharArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an char* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ec6e02f6a12c189fb0308c9893d88ef"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getCharCapacity" ref="a8ec6e02f6a12c189fb0308c9893d88ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getCharCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array as if it contains chars. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a592d4bb8b2d5c76bec3754b34bcdfca4"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getDouble" ref="a592d4bb8b2d5c76bec3754b34bcdfca4" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::internal::util::ByteArrayAdapter::getDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads eight bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ec9dfb41f81a6652aa6b5aab651e4f4"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getDoubleArray" ref="a6ec9dfb41f81a6652aa6b5aab651e4f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double* decaf::internal::util::ByteArrayAdapter::getDoubleArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an double* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4f899c3f36e51b69ebad06b206e7875"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getDoubleAt" ref="ae4f899c3f36e51b69ebad06b206e7875" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::internal::util::ByteArrayAdapter::getDoubleAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads eight bytes at the given byte index and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65a3d1a278ce5ef5846acb38e6607519"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getDoubleCapacity" ref="a65a3d1a278ce5ef5846acb38e6607519" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getDoubleCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array as if it contains doubles. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9f37f27dd2d7ee9574674fa7d72eeb7"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getFloat" ref="aa9f37f27dd2d7ee9574674fa7d72eeb7" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::internal::util::ByteArrayAdapter::getFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads four bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb4c0a6c062feda0bef44dc035d9b91e"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getFloatArray" ref="acb4c0a6c062feda0bef44dc035d9b91e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float* decaf::internal::util::ByteArrayAdapter::getFloatArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an float* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a40fefaa23edba36a625f1dc285529bfb"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getFloatAt" ref="a40fefaa23edba36a625f1dc285529bfb" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::internal::util::ByteArrayAdapter::getFloatAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads four bytes at the given byte index and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d300e5b319be6b52553205aba23509e"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getFloatCapacity" ref="a8d300e5b319be6b52553205aba23509e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getFloatCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array as if it contains doubles. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6112c2b9c8f9887b40822292d567cc"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getInt" ref="a5a6112c2b9c8f9887b40822292d567cc" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads four bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd942eeec67062fd63136ca2a1a9d5a8"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getIntArray" ref="afd942eeec67062fd63136ca2a1a9d5a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int* decaf::internal::util::ByteArrayAdapter::getIntArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an int* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d973809765ee8b5b33fd10a927c8b10"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getIntAt" ref="a6d973809765ee8b5b33fd10a927c8b10" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getIntAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads four bytes at the given byte index and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0cbdaf8811b42b67d27c979053687d0"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getIntCapacity" ref="ae0cbdaf8811b42b67d27c979053687d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getIntCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array as if it contains ints. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="aca8e87b3d2e0481ef7f87ce18ba7af0e"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getLong" ref="aca8e87b3d2e0481ef7f87ce18ba7af0e" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::internal::util::ByteArrayAdapter::getLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads eight bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7acd75e86a282814f79e3dc2d69e553d"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getLongArray" ref="a7acd75e86a282814f79e3dc2d69e553d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long* decaf::internal::util::ByteArrayAdapter::getLongArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an long long* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a2688a33d7df9c95c1ecfe35895db2a81"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getLongAt" ref="a2688a33d7df9c95c1ecfe35895db2a81" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::internal::util::ByteArrayAdapter::getLongAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads eight bytes at the given byte index and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99d163d012791c43d190baa0b1476791"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getLongCapacity" ref="a99d163d012791c43d190baa0b1476791" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getLongCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array as if it contains doubles. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a50991610ce4f40ddbfdbc40b5701022c"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getShort" ref="a50991610ce4f40ddbfdbc40b5701022c" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::internal::util::ByteArrayAdapter::getShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads two bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97b2e502b0ec09e58d9793852817fffa"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getShortArray" ref="a97b2e502b0ec09e58d9793852817fffa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual short* decaf::internal::util::ByteArrayAdapter::getShortArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an short* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="af7bde9ec83b4c69a6e164721dc665a65"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getShortAt" ref="af7bde9ec83b4c69a6e164721dc665a65" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::internal::util::ByteArrayAdapter::getShortAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads two bytes at the given byte index and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd2b054061171b2203eb6ae7f399d4f1"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::getShortCapacity" ref="acd2b054061171b2203eb6ae7f399d4f1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getShortCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the underlying array as if it contains shorts. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="ab07fac85b8d56ac42158fe5f99e156d8"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::operator[]" ref="ab07fac85b8d56ac42158fe5f99e156d8" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char&amp; decaf::internal::util::ByteArrayAdapter::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> to be indexed as a standard array. </p>
<p>calling the non constant version allows the user to change the value at index</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the array to access, if the value is negative or greater than the size of the underlying array an IndexOutOfBoundsException is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of index are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a615c80f6585ed4ea2ca597be21860683"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::operator[]" ref="a615c80f6585ed4ea2ca597be21860683" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char&amp; decaf::internal::util::ByteArrayAdapter::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7bd95554124bb5a28f19f3c71c9155d"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::put" ref="ac7bd95554124bb5a28f19f3c71c9155d" args="(int index, unsigned char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given byte into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5423888295ce5eb22309f0799878b0a"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putChar" ref="aa5423888295ce5eb22309f0799878b0a" args="(int index, char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes one byte containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04781d674d2904e7486b500199fbc880"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putDouble" ref="a04781d674d2904e7486b500199fbc880" args="(int index, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e8dcc06095daacc4fcb354ea2a65aee"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putDoubleAt" ref="a7e8dcc06095daacc4fcb354ea2a65aee" args="(int index, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putDoubleAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given byte index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c97675a65adb7d964b2acd460f08747"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putFloat" ref="a8c97675a65adb7d964b2acd460f08747" args="(int index, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae59dd74fb3affbc0e33351dc233b3710"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putFloatAt" ref="ae59dd74fb3affbc0e33351dc233b3710" args="(int index, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putFloatAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given byte index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedb948bdbcd08fc5faa57eb4297b977b"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putInt" ref="aedb948bdbcd08fc5faa57eb4297b977b" args="(int index, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bec39a3dbaf86c534eb77410e7ec45e"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putIntAt" ref="a5bec39a3dbaf86c534eb77410e7ec45e" args="(int index, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putIntAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given byte index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcca10347197d3e391c94c632534d2c0"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putLong" ref="adcca10347197d3e391c94c632534d2c0" args="(int index, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f3ac887d4e6c3fd1a7b60176cb95049"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putLongAt" ref="a2f3ac887d4e6c3fd1a7b60176cb95049" args="(int index, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putLongAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given byte index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ce00b38db02f687041d274a50b1d4f1"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putShort" ref="a1ce00b38db02f687041d274a50b1d4f1" args="(int index, short value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab705235270f67acf6dc2323821a21fd9"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::putShortAt" ref="ab705235270f67acf6dc2323821a21fd9" args="(int index, short value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putShortAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the given byte index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dfd6373e8c2b327057998fa91ebf79d"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::read" ref="a6dfd6373e8c2b327057998fa91ebf79d" args="(unsigned char *buffer, int size, int offset, int length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads from the Byte array starting at the specified offset and reading the specified length. </p>
<p>If the length is greater than the size of this underlying byte array then an BufferUnderflowException is thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read data from this array into. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in this array to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to read from this array.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length exceeds the size. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer is null </td></tr>
    <tr><td class="paramname">BufferUnderflowException</td><td>if there is not enough data to read because the offset or the length is greater than the size of this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e4f9367846260c30f864e35336c7a23"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::resize" ref="a8e4f9367846260c30f864e35336c7a23" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the underlying array to the new given size, preserving all the Data that was previously in the array, unless the resize is smaller than the current size in which case only the data that will fit into the new array is preserved. </p>
<p>A <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> can only be resized when it owns the underlying array, if it does not then it will throw an InvalidStateException.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the size parameter is negative. </td></tr>
    <tr><td class="paramname">InvalidStateException</td><td>if this object does not own the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0857e62a493c01a56e926e2cca7025ee"></a><!-- doxytag: member="decaf::internal::util::ByteArrayAdapter::write" ref="a0857e62a493c01a56e926e2cca7025ee" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::write </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes from the Byte array given, starting at the specified offset and writing the specified amount of data into this objects internal array. </p>
<p>. If the length is greater than the size of this underlying byte array then an BufferOverflowException is thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read data from this array into. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in this array to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to read from this array.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length exceeds the size. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer is null </td></tr>
    <tr><td class="paramname">BufferOverflowException</td><td>if the amount of data to be written to this array or the offset given are larger than this array's size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/util/<a class="el" href="_byte_array_adapter_8h_source.html">ByteArrayAdapter.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
