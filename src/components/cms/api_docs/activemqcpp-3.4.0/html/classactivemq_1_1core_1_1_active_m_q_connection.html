<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: activemq::core::ActiveMQConnection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classactivemq_1_1core_1_1_active_m_q_connection.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>activemq::core::ActiveMQConnection Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="activemq::core::ActiveMQConnection" --><!-- doxytag: inherits="cms::Connection,activemq::transport::TransportListener" -->
<p>Concrete connection used for all connectors to the ActiveMQ broker.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_active_m_q_connection_8h_source.html">src/main/activemq/core/ActiveMQConnection.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for activemq::core::ActiveMQConnection:</div>
<div class="dyncontent">
<div class="center"><img src="classactivemq_1_1core_1_1_active_m_q_connection__inherit__graph.png" border="0" usemap="#activemq_1_1core_1_1_active_m_q_connection_inherit__map" alt="Inheritance graph"/></div>
<map name="activemq_1_1core_1_1_active_m_q_connection_inherit__map" id="activemq_1_1core_1_1_active_m_q_connection_inherit__map">
<area shape="rect" id="node13" href="classactivemq_1_1core_1_1_active_m_q_x_a_connection.html" title="activemq::core::ActiveMQXAConnection" alt="" coords="183,237,481,267"/><area shape="rect" id="node2" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider." alt="" coords="147,83,283,112"/><area shape="rect" id="node4" href="classcms_1_1_startable.html" title="Interface for a class that implements the start method." alt="" coords="5,5,128,35"/><area shape="rect" id="node6" href="classcms_1_1_stoppable.html" title="Interface for a class that implements the stop method." alt="" coords="152,5,277,35"/><area shape="rect" id="node8" href="classcms_1_1_closeable.html" title="Interface for a class that implements the close method." alt="" coords="301,5,427,35"/><area shape="rect" id="node10" href="classactivemq_1_1transport_1_1_transport_listener.html" title="A listener of asynchronous exceptions from a command transport object." alt="" coords="307,83,592,112"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ae811d576a9ae80839401a1b393cfcda3">ActiveMQConnection</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1transport_1_1_transport.html">transport::Transport</a> &gt; &amp;transport, const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classdecaf_1_1util_1_1_properties.html">decaf::util::Properties</a> &gt; &amp;properties)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae811d576a9ae80839401a1b393cfcda3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a2605378ccc4227c872a4cffbbf1d73c0">~ActiveMQConnection</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a63eb43e62d438e9a54d2f37a8bee30e2">addSession</a> (<a class="el" href="classactivemq_1_1core_1_1_active_m_q_session.html">ActiveMQSession</a> *session)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the session resources for the given session instance.  <a href="#a63eb43e62d438e9a54d2f37a8bee30e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a88739f3f4baeee371f3f72e9ea9fbdce">removeSession</a> (<a class="el" href="classactivemq_1_1core_1_1_active_m_q_session.html">ActiveMQSession</a> *session)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the session resources for the given session instance.  <a href="#a88739f3f4baeee371f3f72e9ea9fbdce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a0dff5e84fa141fa2c959ebd323ddfc0a">addProducer</a> (<a class="el" href="classactivemq_1_1core_1_1_active_m_q_producer.html">ActiveMQProducer</a> *producer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an active Producer to the Set of known producers.  <a href="#a0dff5e84fa141fa2c959ebd323ddfc0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ad6a9aa008b4833eb02c23f0395384036">removeProducer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_producer_id.html">commands::ProducerId</a> &gt; &amp;producerId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an active Producer to the Set of known producers.  <a href="#ad6a9aa008b4833eb02c23f0395384036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a384472a28a506ff43ab20de7ac592444">addDispatcher</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_consumer_id.html">commands::ConsumerId</a> &gt; &amp;consumer, <a class="el" href="classactivemq_1_1core_1_1_dispatcher.html">Dispatcher</a> *dispatcher)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dispatcher for a consumer.  <a href="#a384472a28a506ff43ab20de7ac592444"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a9fd8c4947c364e7f25d98437004f4a85">removeDispatcher</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_consumer_id.html">commands::ConsumerId</a> &gt; &amp;consumer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the dispatcher for a consumer.  <a href="#a9fd8c4947c364e7f25d98437004f4a85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a39f71b51d402502bf11f0198b12d1c5b">sendPullRequest</a> (const <a class="el" href="classactivemq_1_1commands_1_1_consumer_info.html">commands::ConsumerInfo</a> *consumer, long long timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If supported sends a message pull request to the service provider asking for the delivery of a new message.  <a href="#a39f71b51d402502bf11f0198b12d1c5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ac7b2b3c0602cd0436e3f588771374424">isClosed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this connection has been closed.  <a href="#ac7b2b3c0602cd0436e3f588771374424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a07dd334e846f4f0e3b80be1bc4dbb237">isStarted</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this connection has been started.  <a href="#a07dd334e846f4f0e3b80be1bc4dbb237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#af41a6aee9a3564909152fb4d9e8d1ce6">isTransportFailed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the Connection's Transport has failed.  <a href="#af41a6aee9a3564909152fb4d9e8d1ce6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ae3e2c2e6b9e37b8686179450c2eea48e">destroyDestination</a> (const <a class="el" href="classactivemq_1_1commands_1_1_active_m_q_destination.html">commands::ActiveMQDestination</a> *destination)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the Broker removes the given Destination.  <a href="#ae3e2c2e6b9e37b8686179450c2eea48e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aa93af25b6aaec97404e443933663d685">destroyDestination</a> (const <a class="el" href="classcms_1_1_destination.html">cms::Destination</a> *destination)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the Broker removes the given Destination.  <a href="#aa93af25b6aaec97404e443933663d685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <br class="typebreak"/>
<a class="el" href="classcms_1_1_connection_meta_data.html">cms::ConnectionMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a6b8fdf65b791675091dd9b607e8d8328">getMetaData</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the metadata for this connection.<dl class="return"><dt><b>Returns:</b></dt><dd>the connection MetaData pointer ( caller does not own it ).</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if the provider fails to get the connection metadata for this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcms_1_1_connection_meta_data.html" title="A ConnectionMetaData object provides information describing the Connection object.">ConnectionMetaData</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>2.0</dd></dl>
  <a href="#a6b8fdf65b791675091dd9b607e8d8328"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcms_1_1_session.html">cms::Session</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a372408d458debb1026c258829c55f5e8">createSession</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AUTO_ACKNOWLEDGE <a class="el" href="classcms_1_1_session.html" title="A Session object is a single-threaded context for producing and consuming messages.">Session</a>.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
  <a href="#a372408d458debb1026c258829c55f5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aa9b6ebc7c064c358e755e3f4b04615d9">getClientID</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Client Id for this session, the client Id is provider specific and is either assigned by the connection factory or set using the setClientID method.<dl class="return"><dt><b>Returns:</b></dt><dd>Client Id String for this <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if the provider fails to return the client id or an internal error occurs.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aa9b6ebc7c064c358e755e3f4b04615d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aeb87c79f66e3c709856e0949ca99e2ee">setClientID</a> (const std::string &amp;clientID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the client identifier for this connection.The preferred way to assign a CMS client's client identifier is for it to be configured in a client-specific <a class="el" href="classcms_1_1_connection_factory.html" title="Defines the interface for a factory that creates connection objects, the Connection objects returned ...">ConnectionFactory</a> object and transparently assigned to the <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a> object it creates.If a client sets the client identifier explicitly, it must do so immediately after it creates the connection and before any other action on the connection is taken. After this point, setting the client identifier is a programming error that should throw an <a class="el" href="classcms_1_1_illegal_state_exception.html" title="This exception is thrown when a method is invoked at an illegal or inappropriate time or if the provi...">IllegalStateException</a>.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">clientID</td><td>The unique client identifier to assign to the <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if the provider fails to set the client id due to some internal error. </td></tr>
    <tr><td class="paramname">InvalidClientIDException</td><td>if the id given is somehow invalid or is a duplicate. </td></tr>
    <tr><td class="paramname"><a class="el" href="classcms_1_1_illegal_state_exception.html" title="This exception is thrown when a method is invoked at an illegal or inappropriate time or if the provi...">IllegalStateException</a></td><td>if the client tries to set the id after a <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a> method has been called.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aeb87c79f66e3c709856e0949ca99e2ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcms_1_1_session.html">cms::Session</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a651ab05d224c046d80ed64dba3b69380">createSession</a> (<a class="el" href="classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185">cms::Session::AcknowledgeMode</a> ackMode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classcms_1_1_session.html" title="A Session object is a single-threaded context for producing and consuming messages.">Session</a> to work for this <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a> using the specified acknowledgment mode.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ackMode</td><td>the Acknowledgment Mode to use.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
  <a href="#a651ab05d224c046d80ed64dba3b69380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aec65c16bc9f574e4d20bb52b42cf9a5f">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes this connection as well as any Sessions created from it (and those Sessions' consumers and producers).<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
  <a href="#aec65c16bc9f574e4d20bb52b42cf9a5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a733bc028094a89400e752d64d9a9d445">start</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the service.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if an internal error occurs while starting.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a733bc028094a89400e752d64d9a9d445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a511a7a1ade9c08a24c2bd8f554cce149">stop</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops this service.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>- if an internal error occurs while stopping the Service.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a511a7a1ade9c08a24c2bd8f554cce149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcms_1_1_exception_listener.html">cms::ExceptionListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a4dcc4261b8561fe2e3181a144ee7d044">getExceptionListener</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the registered Exception Listener for this connection.<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to an exception listener or NULL</dd></dl>
  <a href="#a4dcc4261b8561fe2e3181a144ee7d044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a6876e71ba256f2ffa041c2b5ec1ee315">setExceptionListener</a> (<a class="el" href="classcms_1_1_exception_listener.html">cms::ExceptionListener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the registered Exception Listener for this connection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>pointer to and <code><a class="el" href="classcms_1_1_exception_listener.html" title="If a CMS provider detects a serious problem, it notifies the client application through an ExceptionL...">ExceptionListener</a></code></td></tr>
  </table>
  </dd>
</dl>
  <a href="#a6876e71ba256f2ffa041c2b5ec1ee315"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ac7857b65abcc62a80cab0a2139aa366b">setUsername</a> (const std::string &amp;username)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the username that should be used when creating a new connection.  <a href="#ac7857b65abcc62a80cab0a2139aa366b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a0b0ab63284f9b4b71090711c93f19341">getUsername</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the username that this factory will use when creating a new connection instance.  <a href="#a0b0ab63284f9b4b71090711c93f19341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a5934fc866d3e926604e021935f5c3ffa">setPassword</a> (const std::string &amp;password)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the password that should be used when creating a new connection.  <a href="#a5934fc866d3e926604e021935f5c3ffa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a4cb31fe2b92591990819f0521b3daac6">getPassword</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the password that this factory will use when creating a new connection instance.  <a href="#a4cb31fe2b92591990819f0521b3daac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a80d66d374532befbdc399e3b1c5abf50">setDefaultClientId</a> (const std::string &amp;clientId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Client Id.  <a href="#a80d66d374532befbdc399e3b1c5abf50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aa271b56a14f05624a37f225b790e99d0">setBrokerURL</a> (const std::string &amp;brokerURL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Broker URL that should be used when creating a new connection instance.  <a href="#aa271b56a14f05624a37f225b790e99d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a0321f89fe63659f6ab696207b398aae8">getBrokerURL</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Broker URL that this factory will use when creating a new connection instance.  <a href="#a0321f89fe63659f6ab696207b398aae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a799579dd9cb741424a946bd6afe59ff6">setPrefetchPolicy</a> (<a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html">PrefetchPolicy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a> instance that this factory should use when it creates new Connection instances.  <a href="#a799579dd9cb741424a946bd6afe59ff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html">PrefetchPolicy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a42d9ad051b922aec57a72b14f08d86b7">getPrefetchPolicy</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the current <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a> that is in use by this ConnectionFactory.  <a href="#a42d9ad051b922aec57a72b14f08d86b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a28a0a8871c13e1ba0b8fc8e0a8185ab1">setRedeliveryPolicy</a> (<a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html">RedeliveryPolicy</a> *policy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a> instance that this factory should use when it creates new Connection instances.  <a href="#a28a0a8871c13e1ba0b8fc8e0a8185ab1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html">RedeliveryPolicy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a8fda960c4f13377f502ee6af2b8a5025">getRedeliveryPolicy</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the current <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a> that is in use by this ConnectionFactory.  <a href="#a8fda960c4f13377f502ee6af2b8a5025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a7ef836f227018ca3716f6e94eff4991e">isDispatchAsync</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a3032cf87402acab6398ace176b9547ba">setDispatchAsync</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Should messages be dispatched synchronously or asynchronously from the producer thread for non-durable topics in the broker? For fast consumers set this to false.  <a href="#a3032cf87402acab6398ace176b9547ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#abf02657763df7ec4307cfad6d6724afc">isAlwaysSyncSend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if the Connection should always send things Synchronously.  <a href="#abf02657763df7ec4307cfad6d6724afc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a97ad78a25690963ac1f7d0fbadb13b6e">setAlwaysSyncSend</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if the Connection should always send things Synchronously.  <a href="#a97ad78a25690963ac1f7d0fbadb13b6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aad22c4ade4f6cd1643a0ab8301e3be0f">isUseAsyncSend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if the useAsyncSend option is set.  <a href="#aad22c4ade4f6cd1643a0ab8301e3be0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aff58f2f016ad18def0703fc3410ab828">setUseAsyncSend</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the useAsyncSend option.  <a href="#aff58f2f016ad18def0703fc3410ab828"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#acfbbd286a43b1bf61dffc35db38bae1c">isUseCompression</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if the Connection is configured for Message body compression.  <a href="#acfbbd286a43b1bf61dffc35db38bae1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a4dd0a165b61e424112410624fbe54815">setUseCompression</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether Message body compression is enabled.  <a href="#a4dd0a165b61e424112410624fbe54815"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a7c36c14e473509c71742980f6b054590">setCompressionLevel</a> (int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Compression level used when Message body compression is enabled, a value of -1 causes the Compression Library to use the default setting which is a balance of speed and compression.  <a href="#a7c36c14e473509c71742980f6b054590"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a235a0f620026593ec13eaea57aeb8abd">getCompressionLevel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently configured Compression level for Message bodies.  <a href="#a235a0f620026593ec13eaea57aeb8abd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a4e1e510007a6987b3dfc4098ee4964da">getSendTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the assigned send timeout for this Connector.  <a href="#a4e1e510007a6987b3dfc4098ee4964da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a24d6a2869214a73b26b31ce8a4704196">setSendTimeout</a> (unsigned int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the send timeout to use when sending Message objects, this will cause all messages to be sent using a Synchronous request is non-zero.  <a href="#a24d6a2869214a73b26b31ce8a4704196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a8bc163b9904c6dda7ad1a2912145efe1">getCloseTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the assigned close timeout for this Connector.  <a href="#a8bc163b9904c6dda7ad1a2912145efe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a4eabda8fca616e215a9d4bf08f2165f5">setCloseTimeout</a> (unsigned int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the close timeout to use when sending the disconnect request.  <a href="#a4eabda8fca616e215a9d4bf08f2165f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a2af3b9597190bf427e30107a8d74b321">getProducerWindowSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the configured producer window size for Producers that are created from this connector.  <a href="#a2af3b9597190bf427e30107a8d74b321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a80eb98a5fa3e91b752fe109ac729ef8d">setProducerWindowSize</a> (unsigned int windowSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size in Bytes of messages that a producer can send before it is blocked to await a ProducerAck from the broker that frees enough memory to allow another message to be sent.  <a href="#a80eb98a5fa3e91b752fe109ac729ef8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a482b7f488bc34fc4ffbc4505ac936ddc">isMessagePrioritySupported</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a35a7ab22126bd9a597e754a1cfbf4126">setMessagePrioritySupported</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not this factory should create Connection objects with the Message priority support function enabled.  <a href="#a35a7ab22126bd9a597e754a1cfbf4126"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ad1936a542663315fd5bf38d08fdf4df6">getNextTempDestinationId</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Next Temporary Destination Id.  <a href="#ad1936a542663315fd5bf38d08fdf4df6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#af135ce31bad5bf06f9bf246b1944858a">getNextLocalTransactionId</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Next Temporary Destination Id.  <a href="#af135ce31bad5bf06f9bf246b1944858a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a6619876b9179370ad777c30013824b4b">addTransportListener</a> (<a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html">transport::TransportListener</a> *transportListener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a transport listener so that a client can be notified of events in the underlying transport, client's are always notified after the event has been processed by the Connection class.  <a href="#a6619876b9179370ad777c30013824b4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a9a300adb00f9becfb9903d8e73b34db4">removeTransportListener</a> (<a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html">transport::TransportListener</a> *transportListener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a registered TransportListener from the Connection's set of Transport listeners, this listener will no longer receive any Transport related events.  <a href="#a9a300adb00f9becfb9903d8e73b34db4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a76ec2ef05dd27d8627618524b241f47a">onCommand</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_command.html">commands::Command</a> &gt; &amp;command)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for the receipt of a non-response command from the transport.  <a href="#a76ec2ef05dd27d8627618524b241f47a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#afabbe8f3df2c08e854a0be53860542b6">onException</a> (const <a class="el" href="classdecaf_1_1lang_1_1_exception.html">decaf::lang::Exception</a> &amp;ex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for an exception from a command transport.  <a href="#afabbe8f3df2c08e854a0be53860542b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#af766d1b740b80bb2eb120595abff912e">transportInterrupted</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The transport has suffered an interruption from which it hopes to recover.  <a href="#af766d1b740b80bb2eb120595abff912e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aaa792d2a29b1d5dc3605ca33db8b7c0e">transportResumed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The transport has resumed after an interruption.  <a href="#aaa792d2a29b1d5dc3605ca33db8b7c0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classactivemq_1_1commands_1_1_connection_info.html">commands::ConnectionInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ab3fa370df488b85616b12f01b6b20b9b">getConnectionInfo</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ConnectionInfo for this Object, if the Connection is not open than this method throws an exception.  <a href="#ab3fa370df488b85616b12f01b6b20b9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classactivemq_1_1commands_1_1_connection_id.html">commands::ConnectionId</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a6606b263418a80bcd5daa7c278693c91">getConnectionId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ConnectionId for this Object, if the Connection is not open than this method throws an exception.  <a href="#a6606b263418a80bcd5daa7c278693c91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classactivemq_1_1transport_1_1_transport.html">transport::Transport</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a92e339cc0663ec2340fbc08e6d075269">getTransport</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to this object's Transport instance.  <a href="#a92e339cc0663ec2340fbc08e6d075269"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1threads_1_1_scheduler.html">threads::Scheduler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a5f059cddff70b2f7745ed9221242c4cc">getScheduler</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the Connection objects built in Scheduler instance.  <a href="#a5f059cddff70b2f7745ed9221242c4cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#acddb432014a6e9307165ad5c29dd77a3">getResourceManagerId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Id of the Resource Manager that this client will use should it be entered into an XA Transaction.  <a href="#acddb432014a6e9307165ad5c29dd77a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a453c636b9150bd6485d2b19c3a72bf59">cleanup</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up this connection object, reseting it back to a state that mirrors what a newly created <a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html" title="Concrete connection used for all connectors to the ActiveMQ broker.">ActiveMQConnection</a> object has.  <a href="#a453c636b9150bd6485d2b19c3a72bf59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a4054cd4165ce83d4084778a4bcf158f8">oneway</a> (<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_command.html">commands::Command</a> &gt; command)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message without request that the broker send a response to indicate that it was received.  <a href="#a4054cd4165ce83d4084778a4bcf158f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_response.html">commands::Response</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a2eb599535fa68e911a2c2ee9ab66f139">syncRequest</a> (<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_command.html">commands::Command</a> &gt; command, unsigned int timeout=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a synchronous request and returns the response from the broker.  <a href="#a2eb599535fa68e911a2c2ee9ab66f139"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a385d89dae5a3407cf8ac84a628b1c210">fire</a> (const <a class="el" href="classactivemq_1_1exceptions_1_1_active_m_q_exception.html">exceptions::ActiveMQException</a> &amp;ex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the exception listener.  <a href="#a385d89dae5a3407cf8ac84a628b1c210"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a0ebd3eadd9f8a10da73e7a9a5b74a54b">setTransportInterruptionProcessingComplete</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a Connection resource that is processing the transportInterrupted event has completed.  <a href="#a0ebd3eadd9f8a10da73e7a9a5b74a54b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_exception.html">decaf::lang::Exception</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a8c08143975bd797cf550445af197ca03">getFirstFailureError</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the first exception that caused the Connection to become failed.  <a href="#a8c08143975bd797cf550445af197ca03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aebc1d128137a6df8463feb173b27bde2">onAsyncException</a> (const <a class="el" href="classdecaf_1_1lang_1_1_exception.html">decaf::lang::Exception</a> &amp;ex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for dealing with async exceptions.  <a href="#aebc1d128137a6df8463feb173b27bde2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aeb7d6b74a5c1abf7c4768d6a7588dd9e">checkClosed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for Closed State and Throw an exception if true.  <a href="#aeb7d6b74a5c1abf7c4768d6a7588dd9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#aadc7f387936eaa757b7a5daf11fbf836">checkClosedOrFailed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for Closed State and Failed State and Throw an exception if either is true.  <a href="#aadc7f387936eaa757b7a5daf11fbf836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a35c810dee4cea7bbc9bfcb166e9f9506">ensureConnectionInfoSent</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If its not been sent, then send the ConnectionInfo to the Broker.  <a href="#a35c810dee4cea7bbc9bfcb166e9f9506"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a><br class="typebreak"/>
&lt; <a class="el" href="classactivemq_1_1commands_1_1_session_id.html">commands::SessionId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ae0c9c401fca486ed9238cbf46a287621">getNextSessionId</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#afb93a147d4cc16d61bf0cad2d1a795ad">disconnect</a> (long long lastDeliveredSequenceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#ac523dd59c3e069da5f23a3e935a848d1">waitForTransportInterruptionProcessingToComplete</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a5dab945fb27fb3177e266c4559576d9c">signalInterruptionProcessingComplete</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdecaf_1_1util_1_1_properties.html">decaf::util::Properties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html#a5917f66fa0732e913465f59c73a2a66b">getProperties</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Concrete connection used for all connectors to the ActiveMQ broker. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>2.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae811d576a9ae80839401a1b393cfcda3"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::ActiveMQConnection" ref="ae811d576a9ae80839401a1b393cfcda3" args="(const Pointer&lt; transport::Transport &gt; &amp;transport, const Pointer&lt; decaf::util::Properties &gt; &amp;properties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">activemq::core::ActiveMQConnection::ActiveMQConnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1transport_1_1_transport.html">transport::Transport</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classdecaf_1_1util_1_1_properties.html">decaf::util::Properties</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The Transport requested for this connection to the Broker. </td></tr>
    <tr><td class="paramname">properties</td><td>The Properties that were defined for this connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2605378ccc4227c872a4cffbbf1d73c0"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::~ActiveMQConnection" ref="a2605378ccc4227c872a4cffbbf1d73c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual activemq::core::ActiveMQConnection::~ActiveMQConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a384472a28a506ff43ab20de7ac592444"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::addDispatcher" ref="a384472a28a506ff43ab20de7ac592444" args="(const Pointer&lt; commands::ConsumerId &gt; &amp;consumer, Dispatcher *dispatcher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::addDispatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_consumer_id.html">commands::ConsumerId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1core_1_1_dispatcher.html">Dispatcher</a> *&#160;</td>
          <td class="paramname"><em>dispatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a dispatcher for a consumer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>- The consumer for which to register a dispatcher. </td></tr>
    <tr><td class="paramname">dispatcher</td><td>- The dispatcher to handle incoming messages for the consumer. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dff5e84fa141fa2c959ebd323ddfc0a"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::addProducer" ref="a0dff5e84fa141fa2c959ebd323ddfc0a" args="(ActiveMQProducer *producer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::addProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_producer.html">ActiveMQProducer</a> *&#160;</td>
          <td class="paramname"><em>producer</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an active Producer to the Set of known producers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The Producer to add from the the known set.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63eb43e62d438e9a54d2f37a8bee30e2"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::addSession" ref="a63eb43e62d438e9a54d2f37a8bee30e2" args="(ActiveMQSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::addSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_session.html">ActiveMQSession</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the session resources for the given session instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>The session to be added to this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6619876b9179370ad777c30013824b4b"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::addTransportListener" ref="a6619876b9179370ad777c30013824b4b" args="(transport::TransportListener *transportListener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::addTransportListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html">transport::TransportListener</a> *&#160;</td>
          <td class="paramname"><em>transportListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a transport listener so that a client can be notified of events in the underlying transport, client's are always notified after the event has been processed by the Connection class. </p>
<p>Client's should ensure that the registered listener does not block or take a long amount of time to execute in order to not degrade performance of this Connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transportListener</td><td>The TransportListener instance to add to this Connection's set of listeners to notify of Transport events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb7d6b74a5c1abf7c4768d6a7588dd9e"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::checkClosed" ref="aeb7d6b74a5c1abf7c4768d6a7588dd9e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::checkClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for Closed State and Throw an exception if true. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if the Connection is closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc7f387936eaa757b7a5daf11fbf836"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::checkClosedOrFailed" ref="aadc7f387936eaa757b7a5daf11fbf836" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::checkClosedOrFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for Closed State and Failed State and Throw an exception if either is true. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if the Connection is closed or failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a453c636b9150bd6485d2b19c3a72bf59"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::cleanup" ref="a453c636b9150bd6485d2b19c3a72bf59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up this connection object, reseting it back to a state that mirrors what a newly created <a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html" title="Concrete connection used for all connectors to the ActiveMQ broker.">ActiveMQConnection</a> object has. </p>

</div>
</div>
<a class="anchor" id="aec65c16bc9f574e4d20bb52b42cf9a5f"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::close" ref="aec65c16bc9f574e4d20bb52b42cf9a5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes this connection as well as any Sessions created from it (and those Sessions' consumers and producers).<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#a0350ba08f42f9f90f7662b47a90d753c">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="a651ab05d224c046d80ed64dba3b69380"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::createSession" ref="a651ab05d224c046d80ed64dba3b69380" args="(cms::Session::AcknowledgeMode ackMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcms_1_1_session.html">cms::Session</a>* activemq::core::ActiveMQConnection::createSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcms_1_1_session.html#ae2fd7b8b76928b465727760c78522185">cms::Session::AcknowledgeMode</a>&#160;</td>
          <td class="paramname"><em>ackMode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classcms_1_1_session.html" title="A Session object is a single-threaded context for producing and consuming messages.">Session</a> to work for this <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a> using the specified acknowledgment mode.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ackMode</td><td>the Acknowledgment Mode to use.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#a34e4ee09142e4f79ddd365a345e56661">cms::Connection</a>.</p>

<p>Reimplemented in <a class="el" href="classactivemq_1_1core_1_1_active_m_q_x_a_connection.html#a87185649eb64981892829a0fbe6fa1cd">activemq::core::ActiveMQXAConnection</a>.</p>

</div>
</div>
<a class="anchor" id="a372408d458debb1026c258829c55f5e8"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::createSession" ref="a372408d458debb1026c258829c55f5e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcms_1_1_session.html">cms::Session</a>* activemq::core::ActiveMQConnection::createSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an AUTO_ACKNOWLEDGE <a class="el" href="classcms_1_1_session.html" title="A Session object is a single-threaded context for producing and consuming messages.">Session</a>.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#aacd3bff8cfc7aaa6a117afac8d225209">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="ae3e2c2e6b9e37b8686179450c2eea48e"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::destroyDestination" ref="ae3e2c2e6b9e37b8686179450c2eea48e" args="(const commands::ActiveMQDestination *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::destroyDestination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classactivemq_1_1commands_1_1_active_m_q_destination.html">commands::ActiveMQDestination</a> *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests that the Broker removes the given Destination. </p>
<p>Calling this method implies that the client is finished with the Destination and that no other messages will be sent or received for the given Destination. The Broker frees all resources it has associated with this Destination.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The Destination the Broker will be requested to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>If the passed Destination is Null </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If the connection is closed. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the wire format in use does not support this operation. </td></tr>
    <tr><td class="paramname">ActiveMQException</td><td>If any other error occurs during the attempt to destroy the destination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa93af25b6aaec97404e443933663d685"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::destroyDestination" ref="aa93af25b6aaec97404e443933663d685" args="(const cms::Destination *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::destroyDestination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcms_1_1_destination.html">cms::Destination</a> *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests that the Broker removes the given Destination. </p>
<p>Calling this method implies that the client is finished with the Destination and that no other messages will be sent or received for the given Destination. The Broker frees all resources it has associated with this Destination.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The CMS Destination the Broker will be requested to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>If the passed Destination is Null </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If the connection is closed. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the wire format in use does not support this operation. </td></tr>
    <tr><td class="paramname">ActiveMQException</td><td>If any other error occurs during the attempt to destroy the destination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb93a147d4cc16d61bf0cad2d1a795ad"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::disconnect" ref="afb93a147d4cc16d61bf0cad2d1a795ad" args="(long long lastDeliveredSequenceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::disconnect </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>lastDeliveredSequenceId</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a35c810dee4cea7bbc9bfcb166e9f9506"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::ensureConnectionInfoSent" ref="a35c810dee4cea7bbc9bfcb166e9f9506" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::ensureConnectionInfoSent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If its not been sent, then send the ConnectionInfo to the Broker. </p>

</div>
</div>
<a class="anchor" id="a385d89dae5a3407cf8ac84a628b1c210"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::fire" ref="a385d89dae5a3407cf8ac84a628b1c210" args="(const exceptions::ActiveMQException &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::fire </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classactivemq_1_1exceptions_1_1_active_m_q_exception.html">exceptions::ActiveMQException</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify the exception listener. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>the exception to fire </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0321f89fe63659f6ab696207b398aae8"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getBrokerURL" ref="a0321f89fe63659f6ab696207b398aae8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; activemq::core::ActiveMQConnection::getBrokerURL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Broker URL that this factory will use when creating a new connection instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>brokerURL string </dd></dl>

</div>
</div>
<a class="anchor" id="aa9b6ebc7c064c358e755e3f4b04615d9"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getClientID" ref="aa9b6ebc7c064c358e755e3f4b04615d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string activemq::core::ActiveMQConnection::getClientID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Client Id for this session, the client Id is provider specific and is either assigned by the connection factory or set using the setClientID method.<dl class="return"><dt><b>Returns:</b></dt><dd>Client Id String for this <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if the provider fails to return the client id or an internal error occurs.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#a52378ac4fbe35df331a3bcf5071146ce">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="a8bc163b9904c6dda7ad1a2912145efe1"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getCloseTimeout" ref="a8bc163b9904c6dda7ad1a2912145efe1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int activemq::core::ActiveMQConnection::getCloseTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the assigned close timeout for this Connector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the close timeout configured in the connection uri </dd></dl>

</div>
</div>
<a class="anchor" id="a235a0f620026593ec13eaea57aeb8abd"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getCompressionLevel" ref="a235a0f620026593ec13eaea57aeb8abd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int activemq::core::ActiveMQConnection::getCompressionLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the currently configured Compression level for Message bodies. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the int value of the current compression level. </dd></dl>

</div>
</div>
<a class="anchor" id="a6606b263418a80bcd5daa7c278693c91"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getConnectionId" ref="a6606b263418a80bcd5daa7c278693c91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classactivemq_1_1commands_1_1_connection_id.html">commands::ConnectionId</a>&amp; activemq::core::ActiveMQConnection::getConnectionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the ConnectionId for this Object, if the Connection is not open than this method throws an exception. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ActiveMQException</td><td>if an error occurs while performing this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3fa370df488b85616b12f01b6b20b9b"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getConnectionInfo" ref="ab3fa370df488b85616b12f01b6b20b9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classactivemq_1_1commands_1_1_connection_info.html">commands::ConnectionInfo</a>&amp; activemq::core::ActiveMQConnection::getConnectionInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the ConnectionInfo for this Object, if the Connection is not open than this method throws an exception. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ActiveMQException</td><td>if an error occurs while performing this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dcc4261b8561fe2e3181a144ee7d044"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getExceptionListener" ref="a4dcc4261b8561fe2e3181a144ee7d044" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcms_1_1_exception_listener.html">cms::ExceptionListener</a>* activemq::core::ActiveMQConnection::getExceptionListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the registered Exception Listener for this connection.<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to an exception listener or NULL</dd></dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#a004a7dc66f114ec7fdda8dadcb206deb">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="a8c08143975bd797cf550445af197ca03"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getFirstFailureError" ref="a8c08143975bd797cf550445af197ca03" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_exception.html">decaf::lang::Exception</a>* activemq::core::ActiveMQConnection::getFirstFailureError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the first exception that caused the Connection to become failed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to and Exception instance or NULL if none is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b8fdf65b791675091dd9b607e8d8328"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getMetaData" ref="a6b8fdf65b791675091dd9b607e8d8328" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classcms_1_1_connection_meta_data.html">cms::ConnectionMetaData</a>* activemq::core::ActiveMQConnection::getMetaData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the metadata for this connection.<dl class="return"><dt><b>Returns:</b></dt><dd>the connection MetaData pointer ( caller does not own it ).</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if the provider fails to get the connection metadata for this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcms_1_1_connection_meta_data.html" title="A ConnectionMetaData object provides information describing the Connection object.">ConnectionMetaData</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>2.0</dd></dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#aa3c7abb2b37ae5f2c5339c2ad8103b80">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="af135ce31bad5bf06f9bf246b1944858a"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getNextLocalTransactionId" ref="af135ce31bad5bf06f9bf246b1944858a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long activemq::core::ActiveMQConnection::getNextLocalTransactionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Next Temporary Destination Id. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next id in the sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0c9c401fca486ed9238cbf46a287621"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getNextSessionId" ref="ae0c9c401fca486ed9238cbf46a287621" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt;<a class="el" href="classactivemq_1_1commands_1_1_session_id.html">commands::SessionId</a>&gt; activemq::core::ActiveMQConnection::getNextSessionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the next available Session Id. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1936a542663315fd5bf38d08fdf4df6"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getNextTempDestinationId" ref="ad1936a542663315fd5bf38d08fdf4df6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long activemq::core::ActiveMQConnection::getNextTempDestinationId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Next Temporary Destination Id. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next id in the sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cb31fe2b92591990819f0521b3daac6"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getPassword" ref="a4cb31fe2b92591990819f0521b3daac6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; activemq::core::ActiveMQConnection::getPassword </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the password that this factory will use when creating a new connection instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>password string, "" for default credentials </dd></dl>

</div>
</div>
<a class="anchor" id="a42d9ad051b922aec57a72b14f08d86b7"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getPrefetchPolicy" ref="a42d9ad051b922aec57a72b14f08d86b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html">PrefetchPolicy</a>* activemq::core::ActiveMQConnection::getPrefetchPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the current <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a> that is in use by this ConnectionFactory. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to this objects <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2af3b9597190bf427e30107a8d74b321"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getProducerWindowSize" ref="a2af3b9597190bf427e30107a8d74b321" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int activemq::core::ActiveMQConnection::getProducerWindowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the configured producer window size for Producers that are created from this connector. </p>
<p>This only applies if there is no send timeout and the producer is able to send asynchronously. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size in bytes of messages that this producer can produce before it must block and wait for ProducerAck messages to free resources. </dd></dl>

</div>
</div>
<a class="anchor" id="a5917f66fa0732e913465f59c73a2a66b"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getProperties" ref="a5917f66fa0732e913465f59c73a2a66b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdecaf_1_1util_1_1_properties.html">decaf::util::Properties</a>&amp; activemq::core::ActiveMQConnection::getProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fda960c4f13377f502ee6af2b8a5025"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getRedeliveryPolicy" ref="a8fda960c4f13377f502ee6af2b8a5025" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html">RedeliveryPolicy</a>* activemq::core::ActiveMQConnection::getRedeliveryPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the pointer to the current <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a> that is in use by this ConnectionFactory. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to this objects <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acddb432014a6e9307165ad5c29dd77a3"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getResourceManagerId" ref="acddb432014a6e9307165ad5c29dd77a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string activemq::core::ActiveMQConnection::getResourceManagerId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Id of the Resource Manager that this client will use should it be entered into an XA Transaction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the resource manager Id for XA Transactions. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f059cddff70b2f7745ed9221242c4cc"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getScheduler" ref="a5f059cddff70b2f7745ed9221242c4cc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt;<a class="el" href="classactivemq_1_1threads_1_1_scheduler.html">threads::Scheduler</a>&gt; activemq::core::ActiveMQConnection::getScheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a reference to the Connection objects built in Scheduler instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a Scheduler instance owned by this Connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1e510007a6987b3dfc4098ee4964da"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getSendTimeout" ref="a4e1e510007a6987b3dfc4098ee4964da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int activemq::core::ActiveMQConnection::getSendTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the assigned send timeout for this Connector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the send timeout configured in the connection uri </dd></dl>

</div>
</div>
<a class="anchor" id="a92e339cc0663ec2340fbc08e6d075269"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getTransport" ref="a92e339cc0663ec2340fbc08e6d075269" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classactivemq_1_1transport_1_1_transport.html">transport::Transport</a>&amp; activemq::core::ActiveMQConnection::getTransport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a reference to this object's Transport instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the Transport that is in use by this Connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b0ab63284f9b4b71090711c93f19341"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::getUsername" ref="a0b0ab63284f9b4b71090711c93f19341" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; activemq::core::ActiveMQConnection::getUsername </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the username that this factory will use when creating a new connection instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>username string, "" for default credentials </dd></dl>

</div>
</div>
<a class="anchor" id="abf02657763df7ec4307cfad6d6724afc"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isAlwaysSyncSend" ref="abf02657763df7ec4307cfad6d6724afc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isAlwaysSyncSend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets if the Connection should always send things Synchronously. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if sends should always be Synchronous. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7b2b3c0602cd0436e3f588771374424"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isClosed" ref="ac7b2b3c0602cd0436e3f588771374424" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if this connection has been closed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the connection is closed </dd></dl>

</div>
</div>
<a class="anchor" id="a7ef836f227018ca3716f6e94eff4991e"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isDispatchAsync" ref="a7ef836f227018ca3716f6e94eff4991e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isDispatchAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the dispatch asynchronously option sent to the broker. </dd></dl>

</div>
</div>
<a class="anchor" id="a482b7f488bc34fc4ffbc4505ac936ddc"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isMessagePrioritySupported" ref="a482b7f488bc34fc4ffbc4505ac936ddc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isMessagePrioritySupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the Connections that this factory creates should support the message based priority settings. </dd></dl>

</div>
</div>
<a class="anchor" id="a07dd334e846f4f0e3b80be1bc4dbb237"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isStarted" ref="a07dd334e846f4f0e3b80be1bc4dbb237" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this connection has been started. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the start method has been called. </dd></dl>

</div>
</div>
<a class="anchor" id="af41a6aee9a3564909152fb4d9e8d1ce6"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isTransportFailed" ref="af41a6aee9a3564909152fb4d9e8d1ce6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isTransportFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the Connection's Transport has failed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the Connection's Transport has failed. </dd></dl>

</div>
</div>
<a class="anchor" id="aad22c4ade4f6cd1643a0ab8301e3be0f"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isUseAsyncSend" ref="aad22c4ade4f6cd1643a0ab8301e3be0f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isUseAsyncSend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets if the useAsyncSend option is set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if on false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="acfbbd286a43b1bf61dffc35db38bae1c"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::isUseCompression" ref="acfbbd286a43b1bf61dffc35db38bae1c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activemq::core::ActiveMQConnection::isUseCompression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets if the Connection is configured for Message body compression. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if the Message body will be Compressed or not. </dd></dl>

</div>
</div>
<a class="anchor" id="aebc1d128137a6df8463feb173b27bde2"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::onAsyncException" ref="aebc1d128137a6df8463feb173b27bde2" args="(const decaf::lang::Exception &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::onAsyncException </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_exception.html">decaf::lang::Exception</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event handler for dealing with async exceptions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The exception that caused the error condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76ec2ef05dd27d8627618524b241f47a"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::onCommand" ref="a76ec2ef05dd27d8627618524b241f47a" args="(const Pointer&lt; commands::Command &gt; &amp;command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::onCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_command.html">commands::Command</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event handler for the receipt of a non-response command from the transport. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>the received command object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html#a6fe6bb9c9e981af541f9d62c74c09c71">activemq::transport::TransportListener</a>.</p>

</div>
</div>
<a class="anchor" id="a4054cd4165ce83d4084778a4bcf158f8"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::oneway" ref="a4054cd4165ce83d4084778a4bcf158f8" args="(Pointer&lt; commands::Command &gt; command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::oneway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_command.html">commands::Command</a> &gt;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a message without request that the broker send a response to indicate that it was received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The Command object to send to the Broker.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ActiveMQException</td><td>if not currently connected, or if the operation fails for any reason. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afabbe8f3df2c08e854a0be53860542b6"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::onException" ref="afabbe8f3df2c08e854a0be53860542b6" args="(const decaf::lang::Exception &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::onException </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_exception.html">decaf::lang::Exception</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event handler for an exception from a command transport. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The exception. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html#a75805597dcfe32d2ea0894f263ddea82">activemq::transport::TransportListener</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd8c4947c364e7f25d98437004f4a85"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::removeDispatcher" ref="a9fd8c4947c364e7f25d98437004f4a85" args="(const Pointer&lt; commands::ConsumerId &gt; &amp;consumer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::removeDispatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_consumer_id.html">commands::ConsumerId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>consumer</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the dispatcher for a consumer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>- The consumer for which to remove the dispatcher. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6a9aa008b4833eb02c23f0395384036"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::removeProducer" ref="ad6a9aa008b4833eb02c23f0395384036" args="(const Pointer&lt; commands::ProducerId &gt; &amp;producerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::removeProducer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_producer_id.html">commands::ProducerId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>producerId</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an active Producer to the Set of known producers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">producerId</td><td>- The ProducerId to remove from the the known set. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88739f3f4baeee371f3f72e9ea9fbdce"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::removeSession" ref="a88739f3f4baeee371f3f72e9ea9fbdce" args="(ActiveMQSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::removeSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_session.html">ActiveMQSession</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the session resources for the given session instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>The session to be unregistered from this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">CMSException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a300adb00f9becfb9903d8e73b34db4"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::removeTransportListener" ref="a9a300adb00f9becfb9903d8e73b34db4" args="(transport::TransportListener *transportListener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::removeTransportListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html">transport::TransportListener</a> *&#160;</td>
          <td class="paramname"><em>transportListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a registered TransportListener from the Connection's set of Transport listeners, this listener will no longer receive any Transport related events. </p>
<p>The caller is responsible for freeing the listener in all cases.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transportListener</td><td>The pointer to the TransportListener to remove from the set of listeners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39f71b51d402502bf11f0198b12d1c5b"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::sendPullRequest" ref="a39f71b51d402502bf11f0198b12d1c5b" args="(const commands::ConsumerInfo *consumer, long long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::sendPullRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classactivemq_1_1commands_1_1_consumer_info.html">commands::ConsumerInfo</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If supported sends a message pull request to the service provider asking for the delivery of a new message. </p>
<p>This is used in the case where the service provider has been configured with a zero prefetch or is only capable of delivering messages on a pull basis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>- the ConsumerInfo for the requesting Consumer. </td></tr>
    <tr><td class="paramname">timeout</td><td>- the time that the client is willing to wait.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ActiveMQException</td><td>if an error occurs while removing performing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97ad78a25690963ac1f7d0fbadb13b6e"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setAlwaysSyncSend" ref="a97ad78a25690963ac1f7d0fbadb13b6e" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setAlwaysSyncSend </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets if the Connection should always send things Synchronously. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>true if sends should always be Synchronous. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa271b56a14f05624a37f225b790e99d0"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setBrokerURL" ref="aa271b56a14f05624a37f225b790e99d0" args="(const std::string &amp;brokerURL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setBrokerURL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>brokerURL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Broker URL that should be used when creating a new connection instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">brokerURL</td><td>string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb87c79f66e3c709856e0949ca99e2ee"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setClientID" ref="aeb87c79f66e3c709856e0949ca99e2ee" args="(const std::string &amp;clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::setClientID </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clientID</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the client identifier for this connection.The preferred way to assign a CMS client's client identifier is for it to be configured in a client-specific <a class="el" href="classcms_1_1_connection_factory.html" title="Defines the interface for a factory that creates connection objects, the Connection objects returned ...">ConnectionFactory</a> object and transparently assigned to the <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a> object it creates.If a client sets the client identifier explicitly, it must do so immediately after it creates the connection and before any other action on the connection is taken. After this point, setting the client identifier is a programming error that should throw an <a class="el" href="classcms_1_1_illegal_state_exception.html" title="This exception is thrown when a method is invoked at an illegal or inappropriate time or if the provi...">IllegalStateException</a>.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">clientID</td><td>The unique client identifier to assign to the <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if the provider fails to set the client id due to some internal error. </td></tr>
    <tr><td class="paramname">InvalidClientIDException</td><td>if the id given is somehow invalid or is a duplicate. </td></tr>
    <tr><td class="paramname"><a class="el" href="classcms_1_1_illegal_state_exception.html" title="This exception is thrown when a method is invoked at an illegal or inappropriate time or if the provi...">IllegalStateException</a></td><td>if the client tries to set the id after a <a class="el" href="classcms_1_1_connection.html" title="The client&#39;s connection to its provider.">Connection</a> method has been called.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#a1b5d17ce18474353314d70921689b718">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="a4eabda8fca616e215a9d4bf08f2165f5"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setCloseTimeout" ref="a4eabda8fca616e215a9d4bf08f2165f5" args="(unsigned int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setCloseTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the close timeout to use when sending the disconnect request. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>- The time to wait for a close message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c36c14e473509c71742980f6b054590"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setCompressionLevel" ref="a7c36c14e473509c71742980f6b054590" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setCompressionLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Compression level used when Message body compression is enabled, a value of -1 causes the Compression Library to use the default setting which is a balance of speed and compression. </p>
<p>The range of compression levels is [0..9] where 0 indicates best speed and 9 indicates best compression.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A signed int value that controls the compression level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80d66d374532befbdc399e3b1c5abf50"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setDefaultClientId" ref="a80d66d374532befbdc399e3b1c5abf50" args="(const std::string &amp;clientId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setDefaultClientId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clientId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Client Id. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">clientId</td><td>- The new clientId value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3032cf87402acab6398ace176b9547ba"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setDispatchAsync" ref="a3032cf87402acab6398ace176b9547ba" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setDispatchAsync </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Should messages be dispatched synchronously or asynchronously from the producer thread for non-durable topics in the broker? For fast consumers set this to false. </p>
<p>For slow consumers set it to true so that dispatching will not block fast consumers. .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the dispatch asynchronously option sent to the broker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6876e71ba256f2ffa041c2b5ec1ee315"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setExceptionListener" ref="a6876e71ba256f2ffa041c2b5ec1ee315" args="(cms::ExceptionListener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::setExceptionListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcms_1_1_exception_listener.html">cms::ExceptionListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the registered Exception Listener for this connection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>pointer to and <code><a class="el" href="classcms_1_1_exception_listener.html" title="If a CMS provider detects a serious problem, it notifies the client application through an ExceptionL...">ExceptionListener</a></code></td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_connection.html#adfe5ecc913687ce0fa1453730b3fc5bb">cms::Connection</a>.</p>

</div>
</div>
<a class="anchor" id="a35a7ab22126bd9a597e754a1cfbf4126"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setMessagePrioritySupported" ref="a35a7ab22126bd9a597e754a1cfbf4126" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setMessagePrioritySupported </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether or not this factory should create Connection objects with the Message priority support function enabled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Boolean indicating if Message priority should be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5934fc866d3e926604e021935f5c3ffa"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setPassword" ref="a5934fc866d3e926604e021935f5c3ffa" args="(const std::string &amp;password)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setPassword </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the password that should be used when creating a new connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a799579dd9cb741424a946bd6afe59ff6"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setPrefetchPolicy" ref="a799579dd9cb741424a946bd6afe59ff6" args="(PrefetchPolicy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setPrefetchPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html">PrefetchPolicy</a> *&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a> instance that this factory should use when it creates new Connection instances. </p>
<p>The <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a> passed becomes the property of the factory and will be deleted when the factory is destroyed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The new <a class="el" href="classactivemq_1_1core_1_1_prefetch_policy.html" title="Interface for a Policy object that controls message Prefetching on various destination types in Activ...">PrefetchPolicy</a> that the ConnectionFactory should clone for Connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80eb98a5fa3e91b752fe109ac729ef8d"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setProducerWindowSize" ref="a80eb98a5fa3e91b752fe109ac729ef8d" args="(unsigned int windowSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setProducerWindowSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>windowSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the size in Bytes of messages that a producer can send before it is blocked to await a ProducerAck from the broker that frees enough memory to allow another message to be sent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">windowSize</td><td>- The size in bytes of the Producers memory window. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28a0a8871c13e1ba0b8fc8e0a8185ab1"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setRedeliveryPolicy" ref="a28a0a8871c13e1ba0b8fc8e0a8185ab1" args="(RedeliveryPolicy *policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setRedeliveryPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html">RedeliveryPolicy</a> *&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a> instance that this factory should use when it creates new Connection instances. </p>
<p>The <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a> passed becomes the property of the factory and will be deleted when the factory is destroyed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The new <a class="el" href="classactivemq_1_1core_1_1_redelivery_policy.html" title="Interface for a RedeliveryPolicy object that controls how message Redelivery is handled in ActiveMQ-C...">RedeliveryPolicy</a> that the ConnectionFactory should clone for Connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24d6a2869214a73b26b31ce8a4704196"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setSendTimeout" ref="a24d6a2869214a73b26b31ce8a4704196" args="(unsigned int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setSendTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the send timeout to use when sending Message objects, this will cause all messages to be sent using a Synchronous request is non-zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>- The time to wait for a response. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ebd3eadd9f8a10da73e7a9a5b74a54b"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setTransportInterruptionProcessingComplete" ref="a0ebd3eadd9f8a10da73e7a9a5b74a54b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setTransportInterruptionProcessingComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that a Connection resource that is processing the transportInterrupted event has completed. </p>

</div>
</div>
<a class="anchor" id="aff58f2f016ad18def0703fc3410ab828"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setUseAsyncSend" ref="aff58f2f016ad18def0703fc3410ab828" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setUseAsyncSend </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the useAsyncSend option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- true to activate, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dd0a165b61e424112410624fbe54815"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setUseCompression" ref="a4dd0a165b61e424112410624fbe54815" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setUseCompression </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether Message body compression is enabled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Boolean indicating if Message body compression is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7857b65abcc62a80cab0a2139aa366b"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::setUsername" ref="ac7857b65abcc62a80cab0a2139aa366b" args="(const std::string &amp;username)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::setUsername </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>username</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the username that should be used when creating a new connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">username</td><td>string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dab945fb27fb3177e266c4559576d9c"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::signalInterruptionProcessingComplete" ref="a5dab945fb27fb3177e266c4559576d9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::signalInterruptionProcessingComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a733bc028094a89400e752d64d9a9d445"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::start" ref="a733bc028094a89400e752d64d9a9d445" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the service.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>if an internal error occurs while starting.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_startable.html#ad40903c18cca87ceee9aa5ae176ac811">cms::Startable</a>.</p>

</div>
</div>
<a class="anchor" id="a511a7a1ade9c08a24c2bd8f554cce149"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::stop" ref="a511a7a1ade9c08a24c2bd8f554cce149" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops this service.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcms_1_1_c_m_s_exception.html" title="CMS API Exception that is the base for all exceptions thrown from CMS classes.">CMSException</a></td><td>- if an internal error occurs while stopping the Service.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classcms_1_1_stoppable.html#a3ac01c725ee82734189e9f82d5b076d3">cms::Stoppable</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb599535fa68e911a2c2ee9ab66f139"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::syncRequest" ref="a2eb599535fa68e911a2c2ee9ab66f139" args="(Pointer&lt; commands::Command &gt; command, unsigned int timeout=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt;<a class="el" href="classactivemq_1_1commands_1_1_response.html">commands::Response</a>&gt; activemq::core::ActiveMQConnection::syncRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; <a class="el" href="classactivemq_1_1commands_1_1_command.html">commands::Command</a> &gt;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a synchronous request and returns the response from the broker. </p>
<p>This method converts any error responses it receives into an exception.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The Command object that is to be sent to the broker. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time in milliseconds to wait for a response, default is zero or infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a Pointer instance to the Response object sent from the Broker.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">BrokerException</td><td>if the response from the broker is of type ExceptionResponse. </td></tr>
    <tr><td class="paramname">ActiveMQException</td><td>if any other error occurs while sending the Command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af766d1b740b80bb2eb120595abff912e"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::transportInterrupted" ref="af766d1b740b80bb2eb120595abff912e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::transportInterrupted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The transport has suffered an interruption from which it hopes to recover. </p>

<p>Implements <a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html#adfe926d1a33816fd73c58103b22ff17c">activemq::transport::TransportListener</a>.</p>

</div>
</div>
<a class="anchor" id="aaa792d2a29b1d5dc3605ca33db8b7c0e"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::transportResumed" ref="aaa792d2a29b1d5dc3605ca33db8b7c0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void activemq::core::ActiveMQConnection::transportResumed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The transport has resumed after an interruption. </p>

<p>Implements <a class="el" href="classactivemq_1_1transport_1_1_transport_listener.html#ae4779a98227ea3d61696b630c06f4865">activemq::transport::TransportListener</a>.</p>

</div>
</div>
<a class="anchor" id="ac523dd59c3e069da5f23a3e935a848d1"></a><!-- doxytag: member="activemq::core::ActiveMQConnection::waitForTransportInterruptionProcessingToComplete" ref="ac523dd59c3e069da5f23a3e935a848d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activemq::core::ActiveMQConnection::waitForTransportInterruptionProcessingToComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/activemq/core/<a class="el" href="_active_m_q_connection_8h_source.html">ActiveMQConnection.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceactivemq.html">activemq</a>      </li>
      <li class="navelem"><a class="el" href="namespaceactivemq_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="classactivemq_1_1core_1_1_active_m_q_connection.html">ActiveMQConnection</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
