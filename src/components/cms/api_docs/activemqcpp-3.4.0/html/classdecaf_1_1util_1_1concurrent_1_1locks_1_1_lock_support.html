<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::util::concurrent::locks::LockSupport Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::concurrent::locks::LockSupport Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::concurrent::locks::LockSupport" -->
<p>Basic thread blocking primitives for creating locks and other synchronization classes.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_lock_support_8h_source.html">src/main/decaf/util/concurrent/locks/LockSupport.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html#a66916690b3d78f535e3df37de7bdf170">~LockSupport</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html#a07ed4625328e89c93e5461c73c679421">unpark</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *thread)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes available the permit for the given thread, if it was not already available.  <a href="#a07ed4625328e89c93e5461c73c679421"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html#a3127e78e7c6737d7354f55dbf25615a5">park</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the current thread for thread scheduling purposes unless the permit is available.  <a href="#a3127e78e7c6737d7354f55dbf25615a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html#a210d6a1b14fbb1e7b24e1e5bf1075b97">parkNanos</a> (long long nanos)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available.  <a href="#a210d6a1b14fbb1e7b24e1e5bf1075b97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html#af7601c16027d78038969eeac84598bf8">parkUntil</a> (long long deadline)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available.  <a href="#af7601c16027d78038969eeac84598bf8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Basic thread blocking primitives for creating locks and other synchronization classes. </p>
<p>This class associates, with each thread that uses it, a permit (in the sense of the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_semaphore.html" title="A counting semaphore.">Semaphore</a> class). A call to park will return immediately if the permit is available, consuming it in the process; otherwise it may block. A call to unpark makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.)</p>
<p>Methods park and unpark provide efficient means of blocking and unblocking threads Races between one thread invoking park and another thread trying to unpark it will preserve liveness, due to the permit. Additionally, park will return if the caller's thread was interrupted, and timeout versions are supported. The park method may also return at any other time, for "no reason", so in general must be invoked within a loop that rechecks conditions upon return. In this sense park serves as an optimization of a "busy wait" that does not waste as much time spinning, but must be paired with an unpark to be effective.</p>
<p>These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications. The park method is designed for use only in constructions of the form:</p>
<p>while (!canProceed()) { ... LockSupport.park(this); }</p>
<p>where neither canProceed nor any other actions prior to the call to park entail locking or blocking. Because only one permit is associated with each thread, any intermediary uses of park could interfere with its intended effects.</p>
<p>Sample Usage. Here is a sketch of a first-in-first-out non-reentrant lock class:</p>
<p>class FIFOMutex { private:</p>
<p>AtomicBoolean locked; ConcurrentLinkedQueue&lt;Thread*&gt; waiters;</p>
<p>public:</p>
<p>void lock() {</p>
<p>bool wasInterrupted = false; Thread* current = Thread::currentThread(); waiters.add( current );</p>
<p>// Block while not first in queue or cannot acquire lock while( waiters.peek() != current || !locked.compareAndSet( false, true ) ) {</p>
<p>LockSupport.park(this); if( Thread::interrupted() ) // ignore interrupts while waiting wasInterrupted = true; }</p>
<p>waiters.remove(); if( wasInterrupted ) // reassert interrupt status on exit current.interrupt(); }</p>
<p>void unlock() { locked.set( false ); <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html#a07ed4625328e89c93e5461c73c679421" title="Makes available the permit for the given thread, if it was not already available.">LockSupport.unpark</a>( waiters.peek() ); } };</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a66916690b3d78f535e3df37de7bdf170"></a><!-- doxytag: member="decaf::util::concurrent::locks::LockSupport::~LockSupport" ref="a66916690b3d78f535e3df37de7bdf170" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::concurrent::locks::LockSupport::~LockSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3127e78e7c6737d7354f55dbf25615a5"></a><!-- doxytag: member="decaf::util::concurrent::locks::LockSupport::park" ref="a3127e78e7c6737d7354f55dbf25615a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::util::concurrent::locks::LockSupport::park </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the current thread for thread scheduling purposes unless the permit is available. </p>
<p>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</p>
<p>* Some other thread invokes unpark with the current thread as the target; or * Some other thread interrupts the current thread; or * The call spuriously (that is, for no reason) returns.</p>
<p>This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread upon return. </p>

</div>
</div>
<a class="anchor" id="a210d6a1b14fbb1e7b24e1e5bf1075b97"></a><!-- doxytag: member="decaf::util::concurrent::locks::LockSupport::parkNanos" ref="a210d6a1b14fbb1e7b24e1e5bf1075b97" args="(long long nanos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::util::concurrent::locks::LockSupport::parkNanos </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>nanos</em></td><td>)</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available. </p>
<p>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</p>
<p>* Some other thread invokes unpark with the current thread as the target; or * Some other thread interrupts the current thread; or * The specified waiting time elapses; or * The call spuriously (that is, for no reason) returns.</p>
<p>This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the elapsed time upon return.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nanos</td><td>the maximum number of nanoseconds to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7601c16027d78038969eeac84598bf8"></a><!-- doxytag: member="decaf::util::concurrent::locks::LockSupport::parkUntil" ref="af7601c16027d78038969eeac84598bf8" args="(long long deadline)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::util::concurrent::locks::LockSupport::parkUntil </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>deadline</em></td><td>)</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available. </p>
<p>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</p>
<p>* Some other thread invokes unpark with the current thread as the target; or * Some other thread interrupts the current thread; or * The specified deadline passes; or * The call spuriously (that is, for no reason) returns.</p>
<p>This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the current time upon return.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">deadline</td><td>the absolute time, in milliseconds from the Epoch, to wait until </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07ed4625328e89c93e5461c73c679421"></a><!-- doxytag: member="decaf::util::concurrent::locks::LockSupport::unpark" ref="a07ed4625328e89c93e5461c73c679421" args="(decaf::lang::Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::util::concurrent::locks::LockSupport::unpark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes available the permit for the given thread, if it was not already available. </p>
<p>If the thread was blocked on park then it will unblock. Otherwise, its next call to park is guaranteed not to block. This operation is not guaranteed to have any effect at all if the given thread has not been started.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to unport, or NULL in which case the method has no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/locks/<a class="el" href="_lock_support_8h_source.html">LockSupport.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent_1_1locks.html">locks</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock_support.html">LockSupport</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
