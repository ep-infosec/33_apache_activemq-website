<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::util::ListIterator&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1_list_iterator.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::ListIterator&lt; E &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::ListIterator" --><!-- doxytag: inherits="decaf::util::Iterator" -->
<p>An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_list_iterator_8h_source.html">src/main/decaf/util/ListIterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::ListIterator&lt; E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1_list_iterator__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1_list_iterator_3_01_e_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1_list_iterator_3_01_e_01_4_inherit__map" id="decaf_1_1util_1_1_list_iterator_3_01_e_01_4_inherit__map">
<area shape="rect" id="node9" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html" title="decaf::util::concurrent::CopyOnWriteArrayList\&lt; E \&gt;::ArrayListIterator" alt="" coords="515,112,1011,141"/><area shape="rect" id="node2" href="classdecaf_1_1util_1_1_iterator.html" title="Defines an object that can be used to iterate over the elements of a collection." alt="" coords="7,165,199,195"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a2c9b28ab86af4607b39167bafe472e32">~ListIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a66c1af7bee313514cf8297316ba1bef0">add</a> (const E &amp;e)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element into the list (optional operation).  <a href="#a66c1af7bee313514cf8297316ba1bef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a20d93e035e0c952f71c0e2a7a5cdf67a">set</a> (const E &amp;e)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the last element returned by next or previous with the specified element (optional operation).  <a href="#a20d93e035e0c952f71c0e2a7a5cdf67a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a49da594069834d22fede126acc999ecb">hasPrevious</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this list iterator has more elements when traversing the list in the reverse direction.  <a href="#a49da594069834d22fede126acc999ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a66abb34917e79060ec9a203a6e210bcb">previous</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous element in the list.  <a href="#a66abb34917e79060ec9a203a6e210bcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a3c14adb19b578476df0b950f1bcdb12c">nextIndex</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element that would be returned by a subsequent call to next.  <a href="#a3c14adb19b578476df0b950f1bcdb12c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#af9f13e48289325042a3d3d64830dd17d">previousIndex</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element that would be returned by a subsequent call to previous.  <a href="#af9f13e48289325042a3d3d64830dd17d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename E&gt;<br/>
 class decaf::util::ListIterator&lt; E &gt;</h3>

<p>An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list. </p>
<p>Note that the <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">remove()</a> and set(Object) methods are not defined in terms of the cursor position; they are defined to operate on the last element returned by a call to <a class="el" href="classdecaf_1_1util_1_1_iterator.html#ae03ba0935e64dbdfd3b384ef89f9fd83" title="Returns the next element in the iteration.">next()</a> or <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a66abb34917e79060ec9a203a6e210bcb" title="Returns the previous element in the list.">previous()</a>. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2c9b28ab86af4607b39167bafe472e32"></a><!-- doxytag: member="decaf::util::ListIterator::~ListIterator" ref="a2c9b28ab86af4607b39167bafe472e32" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::~<a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a66c1af7bee313514cf8297316ba1bef0"></a><!-- doxytag: member="decaf::util::ListIterator::add" ref="a66c1af7bee313514cf8297316ba1bef0" args="(const E &amp;e)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element into the list (optional operation). </p>
<p>The element is inserted immediately before the next element that would be returned by next, if any, and after the next element that would be returned by previous, if any. (If the list contains no elements, the new element becomes the sole element on the list.) The new element is inserted before the implicit cursor: a subsequent call to next would be unaffected, and a subsequent call to previous would return the new element. (This call increases by one the value that would be returned by a call to nextIndex or previousIndex.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The element to insert into the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the add method is not supported by this list iterator. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some aspect of this element prevents it from being added to this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49da594069834d22fede126acc999ecb"></a><!-- doxytag: member="decaf::util::ListIterator::hasPrevious" ref="a49da594069834d22fede126acc999ecb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::hasPrevious </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this list iterator has more elements when traversing the list in the reverse direction. </p>
<p>(In other words, returns true if previous would return an element rather than throwing an exception.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the list iterator has more elements when traversing the list in the reverse direction. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a8a29a0d9e77aedd88de05a13a4097a34">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a3c14adb19b578476df0b950f1bcdb12c"></a><!-- doxytag: member="decaf::util::ListIterator::nextIndex" ref="a3c14adb19b578476df0b950f1bcdb12c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::nextIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the element that would be returned by a subsequent call to next. </p>
<p>(Returns list size if the list iterator is at the end of the list.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the element that would be returned by a subsequent call to next, or list size if list iterator is at end of list. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a2d3515de3c7571a2518979255795141c">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a66abb34917e79060ec9a203a6e210bcb"></a><!-- doxytag: member="decaf::util::ListIterator::previous" ref="a66abb34917e79060ec9a203a6e210bcb" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::previous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the previous element in the list. </p>
<p>This method may be called repeatedly to iterate through the list backwards, or intermixed with calls to next to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the previous element in the list.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1util_1_1_no_such_element_exception.html">NoSuchElementException</a></td><td>if the iteration has no previous element. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a5730cc4ad66aa30b8b6a4e8926ed66c0">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator</a>.</p>

</div>
</div>
<a class="anchor" id="af9f13e48289325042a3d3d64830dd17d"></a><!-- doxytag: member="decaf::util::ListIterator::previousIndex" ref="af9f13e48289325042a3d3d64830dd17d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::previousIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the element that would be returned by a subsequent call to previous. </p>
<p>(Returns -1 if the list iterator is at the beginning of the list.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the element that would be returned by a subsequent call to previous, or -1 if list iterator is at beginning of list. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a3005821734feaf26c68d7295fb1f466b">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator</a>.</p>

</div>
</div>
<a class="anchor" id="a20d93e035e0c952f71c0e2a7a5cdf67a"></a><!-- doxytag: member="decaf::util::ListIterator::set" ref="a20d93e035e0c952f71c0e2a7a5cdf67a" args="(const E &amp;e)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">decaf::util::ListIterator</a>&lt; E &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the last element returned by next or previous with the specified element (optional operation). </p>
<p>This call can be made only if neither <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">ListIterator.remove</a> nor <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a66c1af7bee313514cf8297316ba1bef0" title="Inserts the specified element into the list (optional operation).">ListIterator.add</a> have been called after the last call to next or previous.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The element with which to replace the last element returned by next or previous.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the add method is not supported by this list iterator. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some aspect of this element prevents it from being added to this list. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if neither next nor previous have been called, or remove or add have been called after the last call to next or previous. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/<a class="el" href="_list_iterator_8h_source.html">ListIterator.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
