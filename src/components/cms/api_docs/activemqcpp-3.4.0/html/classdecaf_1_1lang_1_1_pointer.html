<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::lang::Pointer&lt; T, REFCOUNTER &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1lang_1_1_pointer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>decaf::lang::Pointer&lt; T, REFCOUNTER &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::lang::Pointer" -->
<p>Decaf's implementation of a Smart <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> that is a template on a Type and is <a class="el" href="classdecaf_1_1lang_1_1_thread.html" title="A Thread is a concurrent unit of execution.">Thread</a> Safe if the default Reference Counter is used.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pointer_8h_source.html">src/main/decaf/lang/Pointer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a44a453bd81e34929c9c4483a4ed70217">ReferenceType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef REFCOUNTER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a79580eea56341724f31432f23069b85e">CounterType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#abf587c9007f830eab3c3184c7306606e">Pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#abf587c9007f830eab3c3184c7306606e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a7ccf0c3f6e2e947e83dcb4db19bf9881">Pointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit Constructor, creates a <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> that contains value with a single reference.  <a href="#a7ccf0c3f6e2e947e83dcb4db19bf9881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a1809c2372ded54f9ad7d55a222ee2bf6">Pointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a1809c2372ded54f9ad7d55a222ee2bf6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#aede651faba07f2261619053e220f73be">Pointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aede651faba07f2261619053e220f73be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a983aaa0aaf4d3a44b7d1b1a7995d26fa">Pointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;value, const <a class="el" href="structdecaf_1_1lang_1_1_s_t_a_t_i_c___c_a_s_t___t_o_k_e_n.html">STATIC_CAST_TOKEN</a> &amp;)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Static Cast constructor.  <a href="#a983aaa0aaf4d3a44b7d1b1a7995d26fa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a7dabd2d98d47a42ede4d8330ab4719a8">Pointer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;value, const <a class="el" href="structdecaf_1_1lang_1_1_d_y_n_a_m_i_c___c_a_s_t___t_o_k_e_n.html">DYNAMIC_CAST_TOKEN</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Cast constructor.  <a href="#a7dabd2d98d47a42ede4d8330ab4719a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#af707b604ed15d7a4275f89ebdc35d298">~Pointer</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#aabc0584f50459bc766f653d6ec74cc7d">reset</a> (T *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> to hold the new value.  <a href="#aabc0584f50459bc766f653d6ec74cc7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ac74131d93efc562477403ff32e389471">release</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> held and resets the internal pointer value to Null.  <a href="#ac74131d93efc562477403ff32e389471"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a5833de119c2b224563e2730cfb9c06e7">get</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the real pointer that is contained within this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a>.  <a href="#a5833de119c2b224563e2730cfb9c06e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#afe3de97779cb9eaf827c01ab6ce7dc31">swap</a> (<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdecaf_1_1lang_1_1_exception.html">Exception</a> Safe Swap Function.  <a href="#afe3de97779cb9eaf827c01ab6ce7dc31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ad30b08a18ad149cef92c13fa5c088fc4">operator=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;right)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value of right to this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> and increments the reference Count.  <a href="#ad30b08a18ad149cef92c13fa5c088fc4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#afdf613612a71761df42fb61804e52fa8">operator=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;right)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a44a453bd81e34929c9c4483a4ed70217">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a787436fd4a49284377f92251b89b7e54">operator*</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference Operator, returns a reference to the Contained value.  <a href="#a787436fd4a49284377f92251b89b7e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a44a453bd81e34929c9c4483a4ed70217">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a7f20e4228568c02e272b11ad83a0e225">operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a41be756e3ba5a99e5b43e009bfeb8dc8">operator-&gt;</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirection Operator, returns a pointer to the Contained value.  <a href="#a41be756e3ba5a99e5b43e009bfeb8dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a93d03389ad1ae5707682fe1d65beae24">operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a7e5a333c89d83cf4d738c6782ab2bb83">operator!</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#acb5ccb60107af9cdd7e1005f64c59db3">operator==</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;right) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename R1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ac535feb087990026a3764441479e2e7d">operator!=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;right) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a79580eea56341724f31432f23069b85e">CounterType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ae45023d6743a39817a793df54d0cc5df">dynamicCast</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a79580eea56341724f31432f23069b85e">CounterType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a1ba067f97204913aa7d0a8bd835f6235">staticCast</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ab5d93efe286f72639230b6ab42831543">operator==</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;left, const T *right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#aa9551b5acb538c51422310948760829d">operator==</a> (const T *left, const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ac7d02f188b1a69b539edfc0e1b3b4040">operator!=</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;left, const T *right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a2f18794d7f05fde07b908973c8c29247">operator!=</a> (const T *left, const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> &amp;right)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt;<br/>
 class decaf::lang::Pointer&lt; T, REFCOUNTER &gt;</h3>

<p>Decaf's implementation of a Smart <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> that is a template on a Type and is <a class="el" href="classdecaf_1_1lang_1_1_thread.html" title="A Thread is a concurrent unit of execution.">Thread</a> Safe if the default Reference Counter is used. </p>
<p>This <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> type allows for the substitution of different Reference Counter implementations which provide a means of using invasive reference counting if desired using a custom implementation of <code>ReferenceCounter</code>. </p>
<p>The Decaf smart pointer provide comparison operators for comparing <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> instances in the same manner as normal pointer, except that it does not provide an overload of operators ( &lt;, &lt;=, &gt;, &gt;= ). To allow use of a <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> in a STL container that requires it, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> provides an implementation of std::less.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a79580eea56341724f31432f23069b85e"></a><!-- doxytag: member="decaf::lang::Pointer::CounterType" ref="a79580eea56341724f31432f23069b85e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef REFCOUNTER <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a79580eea56341724f31432f23069b85e">CounterType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22b5d52b7c8b9b31921a3e48c8196bfb"></a><!-- doxytag: member="decaf::lang::Pointer::PointerType" ref="a22b5d52b7c8b9b31921a3e48c8196bfb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a44a453bd81e34929c9c4483a4ed70217"></a><!-- doxytag: member="decaf::lang::Pointer::ReferenceType" ref="a44a453bd81e34929c9c4483a4ed70217" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a44a453bd81e34929c9c4483a4ed70217">ReferenceType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abf587c9007f830eab3c3184c7306606e"></a><!-- doxytag: member="decaf::lang::Pointer::Pointer" ref="abf587c9007f830eab3c3184c7306606e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Constructor. </p>
<p>Initialized the contained pointer to NULL, using the -&gt; operator results in an exception unless reset to contain a real value. </p>

<p>Referenced by <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#aabc0584f50459bc766f653d6ec74cc7d">decaf::lang::Pointer&lt; TransactionId &gt;::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ccf0c3f6e2e947e83dcb4db19bf9881"></a><!-- doxytag: member="decaf::lang::Pointer::Pointer" ref="a7ccf0c3f6e2e947e83dcb4db19bf9881" args="(const PointerType value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicit Constructor, creates a <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> that contains value with a single reference. </p>
<p>This object now has ownership until a call to release.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- instance of the type we are containing here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1809c2372ded54f9ad7d55a222ee2bf6"></a><!-- doxytag: member="decaf::lang::Pointer::Pointer" ref="a1809c2372ded54f9ad7d55a222ee2bf6" args="(const Pointer &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies the value contained in the pointer to the new instance and increments the reference counter. </p>

</div>
</div>
<a class="anchor" id="aede651faba07f2261619053e220f73be"></a><!-- doxytag: member="decaf::lang::Pointer::Pointer" ref="aede651faba07f2261619053e220f73be" args="(const Pointer&lt; T1, R1 &gt; &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies the value contained in the pointer to the new instance and increments the reference counter. </p>

</div>
</div>
<a class="anchor" id="a983aaa0aaf4d3a44b7d1b1a7995d26fa"></a><!-- doxytag: member="decaf::lang::Pointer::Pointer" ref="a983aaa0aaf4d3a44b7d1b1a7995d26fa" args="(const Pointer&lt; T1, R1 &gt; &amp;value, const STATIC_CAST_TOKEN &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdecaf_1_1lang_1_1_s_t_a_t_i_c___c_a_s_t___t_o_k_e_n.html">STATIC_CAST_TOKEN</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static Cast constructor. </p>
<p>Copies the value contained in the pointer to the new instance and increments the reference counter performing a static cast on the value contained in the source <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> instance to cast to this type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dabd2d98d47a42ede4d8330ab4719a8"></a><!-- doxytag: member="decaf::lang::Pointer::Pointer" ref="a7dabd2d98d47a42ede4d8330ab4719a8" args="(const Pointer&lt; T1, R1 &gt; &amp;value, const DYNAMIC_CAST_TOKEN &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdecaf_1_1lang_1_1_d_y_n_a_m_i_c___c_a_s_t___t_o_k_e_n.html">DYNAMIC_CAST_TOKEN</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dynamic Cast constructor. </p>
<p>Copies the value contained in the pointer to the new instance and increments the reference counter performing a dynamic cast on the value contained in the source <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> object. If the cast fails and return NULL then this method throws a ClassCastException.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> instance to cast to this type.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ClassCastException</td><td>if the dynamic cast returns NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af707b604ed15d7a4275f89ebdc35d298"></a><!-- doxytag: member="decaf::lang::Pointer::~Pointer" ref="af707b604ed15d7a4275f89ebdc35d298" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::~<a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae45023d6743a39817a793df54d0cc5df"></a><!-- doxytag: member="decaf::lang::Pointer::dynamicCast" ref="ae45023d6743a39817a793df54d0cc5df" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt;T1, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a79580eea56341724f31432f23069b85e">CounterType</a>&gt; <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::dynamicCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5833de119c2b224563e2730cfb9c06e7"></a><!-- doxytag: member="decaf::lang::Pointer::get" ref="a5833de119c2b224563e2730cfb9c06e7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the real pointer that is contained within this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a>. </p>
<p>This is not really safe since the caller could delete or alter the pointer but it mimics the STL auto_ptr and gives access in cases where the caller absolutely needs the real <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a>. Use at your own risk.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the contained pointer. </dd></dl>

<p>Referenced by <a class="el" href="classactivemq_1_1commands_1_1_active_m_q_message_template.html#a9af95f8fe95b78e713fe3fe9417e16f6">activemq::commands::ActiveMQMessageTemplate&lt; cms::ObjectMessage &gt;::equals()</a>, <a class="el" href="classactivemq_1_1state_1_1_connection_state.html#a1fc9a9ad2fa0521afaa8078891b5443c">activemq::state::ConnectionState::getTransactionState()</a>, <a class="el" href="namespacedecaf_1_1lang.html#a06a44db2c048f0eaca700e5a41073e89">decaf::lang::operator!=()</a>, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ac535feb087990026a3764441479e2e7d">decaf::lang::Pointer&lt; TransactionId &gt;::operator!=()</a>, <a class="el" href="structstd_1_1less_3_01decaf_1_1lang_1_1_pointer_3_01_t_01_4_01_4.html#a36138b8ea9a05bdf0610d4f4eca397fd">std::less&lt; decaf::lang::Pointer&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="namespacedecaf_1_1lang.html#ad566cbbfbf88ab97528128f2290b8c6e">decaf::lang::operator==()</a>, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#acb5ccb60107af9cdd7e1005f64c59db3">decaf::lang::Pointer&lt; TransactionId &gt;::operator==()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a6553c7d97144fb9f5205e5c666aa05e1">decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;::peek()</a>, <a class="el" href="classactivemq_1_1state_1_1_command_visitor_adapter.html#a9d12b8df7f39882fe27e3c8eed331a6d">activemq::state::CommandVisitorAdapter::processRemoveInfo()</a>, and <a class="el" href="classactivemq_1_1state_1_1_connection_state.html#a26134cb900847339f0e306c5c0d302d7">activemq::state::ConnectionState::removeTempDestination()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e5a333c89d83cf4d738c6782ab2bb83"></a><!-- doxytag: member="decaf::lang::Pointer::operator!" ref="a7e5a333c89d83cf4d738c6782ab2bb83" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac535feb087990026a3764441479e2e7d"></a><!-- doxytag: member="decaf::lang::Pointer::operator!=" ref="ac535feb087990026a3764441479e2e7d" args="(const Pointer&lt; T1, R1 &gt; &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f20e4228568c02e272b11ad83a0e225"></a><!-- doxytag: member="decaf::lang::Pointer::operator*" ref="a7f20e4228568c02e272b11ad83a0e225" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a44a453bd81e34929c9c4483a4ed70217">ReferenceType</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a787436fd4a49284377f92251b89b7e54"></a><!-- doxytag: member="decaf::lang::Pointer::operator*" ref="a787436fd4a49284377f92251b89b7e54" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a44a453bd81e34929c9c4483a4ed70217">ReferenceType</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereference Operator, returns a reference to the Contained value. </p>
<p>This method throws an NullPointerException if the contained value is NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to the contained pointer. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the contained value is Null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41be756e3ba5a99e5b43e009bfeb8dc8"></a><!-- doxytag: member="decaf::lang::Pointer::operator&#45;&gt;" ref="a41be756e3ba5a99e5b43e009bfeb8dc8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indirection Operator, returns a pointer to the Contained value. </p>
<p>This method throws an NullPointerException if the contained value is NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to the contained pointer. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the contained value is Null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93d03389ad1ae5707682fe1d65beae24"></a><!-- doxytag: member="decaf::lang::Pointer::operator&#45;&gt;" ref="a93d03389ad1ae5707682fe1d65beae24" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a22b5d52b7c8b9b31921a3e48c8196bfb">PointerType</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad30b08a18ad149cef92c13fa5c088fc4"></a><!-- doxytag: member="decaf::lang::Pointer::operator=" ref="ad30b08a18ad149cef92c13fa5c088fc4" args="(const Pointer &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&amp; <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns the value of right to this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> and increments the reference Count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>- <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> on the right hand side of an operator= call to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdf613612a71761df42fb61804e52fa8"></a><!-- doxytag: member="decaf::lang::Pointer::operator=" ref="afdf613612a71761df42fb61804e52fa8" args="(const Pointer&lt; T1, R1 &gt; &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&amp; <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb5ccb60107af9cdd7e1005f64c59db3"></a><!-- doxytag: member="decaf::lang::Pointer::operator==" ref="acb5ccb60107af9cdd7e1005f64c59db3" args="(const Pointer&lt; T1, R1 &gt; &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T1, R1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac74131d93efc562477403ff32e389471"></a><!-- doxytag: member="decaf::lang::Pointer::release" ref="ac74131d93efc562477403ff32e389471" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> held and resets the internal pointer value to Null. </p>
<p>This method is not guaranteed to be safe if the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> is held by more than one object or this method is called from more than one thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The new value to contain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer instance that was held by this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> object, the pointer is no longer owned by this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> and won't be freed when this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> goes out of scope. </dd></dl>

<p>Referenced by <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a7dabd2d98d47a42ede4d8330ab4719a8">decaf::lang::Pointer&lt; TransactionId &gt;::Pointer()</a>.</p>

</div>
</div>
<a class="anchor" id="aabc0584f50459bc766f653d6ec74cc7d"></a><!-- doxytag: member="decaf::lang::Pointer::reset" ref="aabc0584f50459bc766f653d6ec74cc7d" args="(T *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> to hold the new value. </p>
<p>Before the new value is stored reset checks if the old value should be destroyed and if so calls delete. Call reset with a value of NULL is supported and acts to set this <a class="el" href="classdecaf_1_1lang_1_1_pointer.html" title="Decaf&#39;s implementation of a Smart Pointer that is a template on a Type and is Thread Safe if the ...">Pointer</a> to a NULL pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- The new value to contain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ba067f97204913aa7d0a8bd835f6235"></a><!-- doxytag: member="decaf::lang::Pointer::staticCast" ref="a1ba067f97204913aa7d0a8bd835f6235" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt;T1, <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a79580eea56341724f31432f23069b85e">CounterType</a>&gt; <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::staticCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afe3de97779cb9eaf827c01ab6ce7dc31"></a><!-- doxytag: member="decaf::lang::Pointer::swap" ref="afe3de97779cb9eaf827c01ab6ce7dc31" args="(Pointer &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; T, REFCOUNTER &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classdecaf_1_1lang_1_1_exception.html">Exception</a> Safe Swap Function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value to swap with this. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#ad30b08a18ad149cef92c13fa5c088fc4">decaf::lang::Pointer&lt; TransactionId &gt;::operator=()</a>, and <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#afe3de97779cb9eaf827c01ab6ce7dc31">decaf::lang::Pointer&lt; TransactionId &gt;::swap()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac7d02f188b1a69b539edfc0e1b3b4040"></a><!-- doxytag: member="decaf::lang::Pointer::operator!=" ref="ac7d02f188b1a69b539edfc0e1b3b4040" args="(const Pointer &amp;left, const T *right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f18794d7f05fde07b908973c8c29247"></a><!-- doxytag: member="decaf::lang::Pointer::operator!=" ref="a2f18794d7f05fde07b908973c8c29247" args="(const T *left, const Pointer &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5d93efe286f72639230b6ab42831543"></a><!-- doxytag: member="decaf::lang::Pointer::operator==" ref="ab5d93efe286f72639230b6ab42831543" args="(const Pointer &amp;left, const T *right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9551b5acb538c51422310948760829d"></a><!-- doxytag: member="decaf::lang::Pointer::operator==" ref="aa9551b5acb538c51422310948760829d" args="(const T *left, const Pointer &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename REFCOUNTER = decaf::util::concurrent::atomic::AtomicRefCounter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>&lt; T, REFCOUNTER &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/lang/<a class="el" href="_pointer_8h_source.html">Pointer.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1lang.html">lang</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">Pointer</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
