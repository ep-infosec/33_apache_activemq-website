<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.4.0: decaf::util::zip::Deflater Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.4.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1zip_1_1_deflater.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>decaf::util::zip::Deflater Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::zip::Deflater" -->
<p>This class compresses data using the <em>DEFLATE</em> algorithm (see <a href="http://www.gzip.org/algorithm.txt">specification</a>).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_deflater_8h_source.html">src/main/decaf/util/zip/Deflater.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a81ff05087ec55eb42a64a9c02c71d037">Deflater</a> (int level, bool nowrap=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new compressor using the specified compression level.  <a href="#a81ff05087ec55eb42a64a9c02c71d037"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#ac0e27070bf6329b37ba310601cd2f189">Deflater</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new compressor with the default compression level.  <a href="#ac0e27070bf6329b37ba310601cd2f189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a3ded69e78ea481686493f8a932b0cea9">~Deflater</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#afc382ac1b2ec971e125b271db6c96bff">setInput</a> (const unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets input data for compression.  <a href="#afc382ac1b2ec971e125b271db6c96bff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a01bd17b4976d3b3819019b7fea2cb88f">setInput</a> (const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets input data for compression.  <a href="#a01bd17b4976d3b3819019b7fea2cb88f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#ab28f5e182a1637924bbc5eabb418bca8">setInput</a> (const std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets input data for compression.  <a href="#ab28f5e182a1637924bbc5eabb418bca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a1d1a7e81f34a78410ec1eb7b9a319837">setDictionary</a> (const unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preset dictionary for compression.  <a href="#a1d1a7e81f34a78410ec1eb7b9a319837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a5d7d0fe55a02d912c9befb3c5a39b0db">setDictionary</a> (const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preset dictionary for compression.  <a href="#a5d7d0fe55a02d912c9befb3c5a39b0db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#afb26686d04250c4d113f4821457e451d">setDictionary</a> (const std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preset dictionary for compression.  <a href="#afb26686d04250c4d113f4821457e451d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a46f9a31a2ddebbefe0a36192b24ed17a">setStrategy</a> (int strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression strategy to the specified value.  <a href="#a46f9a31a2ddebbefe0a36192b24ed17a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#ab2b5640523b46d5de9142a131f6ea453">setLevel</a> (int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression level to the specified value.  <a href="#ab2b5640523b46d5de9142a131f6ea453"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#ad67b4f7b5ed509a85d38acc23343d90e">finish</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, indicates that compression should end with the current contents of the input buffer.  <a href="#ad67b4f7b5ed509a85d38acc23343d90e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#afd438a0cc30cc35523e70d261543a90e">finished</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#aac3aef8a4a6e2f58c2059390c6f16e66">deflate</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills specified buffer with compressed data.  <a href="#aac3aef8a4a6e2f58c2059390c6f16e66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0fab01069290b8c2963a460aa4c58f88">deflate</a> (std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills specified buffer with compressed data.  <a href="#a0fab01069290b8c2963a460aa4c58f88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a235cdd1804bf3370b358bcf13346298b">deflate</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills specified buffer with compressed data.  <a href="#a235cdd1804bf3370b358bcf13346298b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a103f65a8309670e47c8d41f592596b57">getAdler</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a3e4be46511cbbac84cbcd68a3501fbe5">getBytesRead</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a2fdfc79cae593565a72e48533dce65a9">getBytesWritten</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a2f317bfd5b42d889a9686deedf6068c0">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets deflater so that a new set of input data can be processed.  <a href="#a2f317bfd5b42d889a9686deedf6068c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a5d96274dca408b654ecde0b8f2ff7ded">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the compressor and discards any unprocessed input.  <a href="#a5d96274dca408b654ecde0b8f2ff7ded"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a45bca712d5679aa7961ee9aa7a494d2c">BEST_SPEED</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression level for fastest compression.  <a href="#a45bca712d5679aa7961ee9aa7a494d2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a4818cb2b076de7a7694006841a38f9fb">BEST_COMPRESSION</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression level for best compression.  <a href="#a4818cb2b076de7a7694006841a38f9fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#aebe7736ca9bf73c63185eb362855c13e">DEFAULT_COMPRESSION</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default compression level.  <a href="#aebe7736ca9bf73c63185eb362855c13e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#affd4e2a6a7f7fbc70a3be05ef5cea9fe">DEFLATED</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression method for the deflate algorithm (the only one currently supported).  <a href="#affd4e2a6a7f7fbc70a3be05ef5cea9fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a080f6222cf01ccd1dc4c8f9955a1bcf5">NO_COMPRESSION</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression level for no compression.  <a href="#a080f6222cf01ccd1dc4c8f9955a1bcf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#aa5445980e72f3b60a8b1f123b8f7ec0e">FILTERED</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression strategy best used for data consisting mostly of small values with a somewhat random distribution.  <a href="#aa5445980e72f3b60a8b1f123b8f7ec0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a03eec580775f8cc61b78b326ba95794f">HUFFMAN_ONLY</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression strategy for Huffman coding only.  <a href="#a03eec580775f8cc61b78b326ba95794f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a23c009eab2f3f47decb334b7f43e6a7a">DEFAULT_STRATEGY</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default compression strategy.  <a href="#a23c009eab2f3f47decb334b7f43e6a7a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class compresses data using the <em>DEFLATE</em> algorithm (see <a href="http://www.gzip.org/algorithm.txt">specification</a>). </p>
<p>Basically this class is part of the API to the stream based ZLIB compression library and is used as such by <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater_output_stream.html" title="Provides a FilterOutputStream instance that compresses the data before writing it to the wrapped Outp...">DeflaterOutputStream</a> and its descendants.</p>
<p>The typical usage of a <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html" title="This class compresses data using the DEFLATE algorithm (see specification).">Deflater</a> instance outside this package consists of a specific call to one of its constructors before being passed to an instance of <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater_output_stream.html" title="Provides a FilterOutputStream instance that compresses the data before writing it to the wrapped Outp...">DeflaterOutputStream</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater_output_stream.html" title="Provides a FilterOutputStream instance that compresses the data before writing it to the wrapped Outp...">DeflaterOutputStream</a> </dd>
<dd>
<a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a81ff05087ec55eb42a64a9c02c71d037"></a><!-- doxytag: member="decaf::util::zip::Deflater::Deflater" ref="a81ff05087ec55eb42a64a9c02c71d037" args="(int level, bool nowrap=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::Deflater::Deflater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nowrap</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new compressor using the specified compression level. </p>
<p>If 'nowrap' is true then the ZLIB header and checksum fields will not be used in order to support the compression format used in both GZIP and PKZIP.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The compression level to use (0-9). </td></tr>
    <tr><td class="paramname">nowrap</td><td>If true uses GZip compatible compression (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0e27070bf6329b37ba310601cd2f189"></a><!-- doxytag: member="decaf::util::zip::Deflater::Deflater" ref="ac0e27070bf6329b37ba310601cd2f189" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::Deflater::Deflater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new compressor with the default compression level. </p>
<p>Compressed data will be generated in ZLIB format. </p>

</div>
</div>
<a class="anchor" id="a3ded69e78ea481686493f8a932b0cea9"></a><!-- doxytag: member="decaf::util::zip::Deflater::~Deflater" ref="a3ded69e78ea481686493f8a932b0cea9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::util::zip::Deflater::~Deflater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aac3aef8a4a6e2f58c2059390c6f16e66"></a><!-- doxytag: member="decaf::util::zip::Deflater::deflate" ref="aac3aef8a4a6e2f58c2059390c6f16e66" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Deflater::deflate </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills specified buffer with compressed data. </p>
<p>Returns actual number of bytes of compressed data. A return value of 0 indicates that <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput()</a> should be called in order to determine if more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to write the compressed data to. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the passed buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start writing at. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of byte of data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the actual number of bytes of compressed data.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fab01069290b8c2963a460aa4c58f88"></a><!-- doxytag: member="decaf::util::zip::Deflater::deflate" ref="a0fab01069290b8c2963a460aa4c58f88" args="(std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Deflater::deflate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills specified buffer with compressed data. </p>
<p>Returns actual number of bytes of compressed data. A return value of 0 indicates that <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput()</a> should be called in order to determine if more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to write the compressed data to. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start writing at. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of byte of data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the actual number of bytes of compressed data.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a235cdd1804bf3370b358bcf13346298b"></a><!-- doxytag: member="decaf::util::zip::Deflater::deflate" ref="a235cdd1804bf3370b358bcf13346298b" args="(std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Deflater::deflate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills specified buffer with compressed data. </p>
<p>Returns actual number of bytes of compressed data. A return value of 0 indicates that <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput()</a> should be called in order to determine if more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to write the compressed data to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the actual number of bytes of compressed data.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d96274dca408b654ecde0b8f2ff7ded"></a><!-- doxytag: member="decaf::util::zip::Deflater::end" ref="a5d96274dca408b654ecde0b8f2ff7ded" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the compressor and discards any unprocessed input. </p>
<p>This method should be called when the compressor is no longer being used, but will also be called automatically by the destructor. Once this method is called, the behavior of the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html" title="This class compresses data using the DEFLATE algorithm (see specification).">Deflater</a> object is undefined. </p>

</div>
</div>
<a class="anchor" id="ad67b4f7b5ed509a85d38acc23343d90e"></a><!-- doxytag: member="decaf::util::zip::Deflater::finish" ref="ad67b4f7b5ed509a85d38acc23343d90e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When called, indicates that compression should end with the current contents of the input buffer. </p>

</div>
</div>
<a class="anchor" id="afd438a0cc30cc35523e70d261543a90e"></a><!-- doxytag: member="decaf::util::zip::Deflater::finished" ref="afd438a0cc30cc35523e70d261543a90e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::zip::Deflater::finished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the end of the compressed data output stream has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="a103f65a8309670e47c8d41f592596b57"></a><!-- doxytag: member="decaf::util::zip::Deflater::getAdler" ref="a103f65a8309670e47c8d41f592596b57" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long decaf::util::zip::Deflater::getAdler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the ADLER-32 value of the uncompressed data.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e4be46511cbbac84cbcd68a3501fbe5"></a><!-- doxytag: member="decaf::util::zip::Deflater::getBytesRead" ref="a3e4be46511cbbac84cbcd68a3501fbe5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long decaf::util::zip::Deflater::getBytesRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of uncompressed bytes input so far.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fdfc79cae593565a72e48533dce65a9"></a><!-- doxytag: member="decaf::util::zip::Deflater::getBytesWritten" ref="a2fdfc79cae593565a72e48533dce65a9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long decaf::util::zip::Deflater::getBytesWritten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of compressed bytes output so far.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dc342e9ade44810bd6d932cb55dfb90"></a><!-- doxytag: member="decaf::util::zip::Deflater::needsInput" ref="a0dc342e9ade44810bd6d932cb55dfb90" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::zip::Deflater::needsInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the input data buffer is empty and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#afc382ac1b2ec971e125b271db6c96bff" title="Sets input data for compression.">setInput()</a> should be called in order to provide more input </dd></dl>

</div>
</div>
<a class="anchor" id="a2f317bfd5b42d889a9686deedf6068c0"></a><!-- doxytag: member="decaf::util::zip::Deflater::reset" ref="a2f317bfd5b42d889a9686deedf6068c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets deflater so that a new set of input data can be processed. </p>
<p>Keeps current compression level and strategy settings.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d7d0fe55a02d912c9befb3c5a39b0db"></a><!-- doxytag: member="decaf::util::zip::Deflater::setDictionary" ref="a5d7d0fe55a02d912c9befb3c5a39b0db" args="(const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setDictionary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets preset dictionary for compression. </p>
<p>A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832" title="Uncompresses bytes into specified buffer.">Inflater.inflate()</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">Inflater.getAdler()</a> can be called in order to get the Adler-32 value of the dictionary required for decompression.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the preset dictionary. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d1a7e81f34a78410ec1eb7b9a319837"></a><!-- doxytag: member="decaf::util::zip::Deflater::setDictionary" ref="a1d1a7e81f34a78410ec1eb7b9a319837" args="(const unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setDictionary </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets preset dictionary for compression. </p>
<p>A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832" title="Uncompresses bytes into specified buffer.">Inflater.inflate()</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">Inflater.getAdler()</a> can be called in order to get the Adler-32 value of the dictionary required for decompression.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the preset dictionary. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the passed dictionary buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb26686d04250c4d113f4821457e451d"></a><!-- doxytag: member="decaf::util::zip::Deflater::setDictionary" ref="afb26686d04250c4d113f4821457e451d" args="(const std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setDictionary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets preset dictionary for compression. </p>
<p>A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832" title="Uncompresses bytes into specified buffer.">Inflater.inflate()</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">Inflater.getAdler()</a> can be called in order to get the Adler-32 value of the dictionary required for decompression.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the preset dictionary.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab28f5e182a1637924bbc5eabb418bca8"></a><!-- doxytag: member="decaf::util::zip::Deflater::setInput" ref="ab28f5e182a1637924bbc5eabb418bca8" args="(const std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setInput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets input data for compression. </p>
<p>This should be called whenever <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput()</a> returns true indicating that more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for compression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01bd17b4976d3b3819019b7fea2cb88f"></a><!-- doxytag: member="decaf::util::zip::Deflater::setInput" ref="a01bd17b4976d3b3819019b7fea2cb88f" args="(const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setInput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets input data for compression. </p>
<p>This should be called whenever <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput()</a> returns true indicating that more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for compression. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc382ac1b2ec971e125b271db6c96bff"></a><!-- doxytag: member="decaf::util::zip::Deflater::setInput" ref="afc382ac1b2ec971e125b271db6c96bff" args="(const unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setInput </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets input data for compression. </p>
<p>This should be called whenever <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a0dc342e9ade44810bd6d932cb55dfb90">needsInput()</a> returns true indicating that more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for compression. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2b5640523b46d5de9142a131f6ea453"></a><!-- doxytag: member="decaf::util::zip::Deflater::setLevel" ref="ab2b5640523b46d5de9142a131f6ea453" args="(int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the compression level to the specified value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The new Compression level to use.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the level value is invalid. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46f9a31a2ddebbefe0a36192b24ed17a"></a><!-- doxytag: member="decaf::util::zip::Deflater::setStrategy" ref="a46f9a31a2ddebbefe0a36192b24ed17a" args="(int strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Deflater::setStrategy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the compression strategy to the specified value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The new Compression strategy to use.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the strategy value is invalid. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a4818cb2b076de7a7694006841a38f9fb"></a><!-- doxytag: member="decaf::util::zip::Deflater::BEST_COMPRESSION" ref="a4818cb2b076de7a7694006841a38f9fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a4818cb2b076de7a7694006841a38f9fb">decaf::util::zip::Deflater::BEST_COMPRESSION</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compression level for best compression. </p>

</div>
</div>
<a class="anchor" id="a45bca712d5679aa7961ee9aa7a494d2c"></a><!-- doxytag: member="decaf::util::zip::Deflater::BEST_SPEED" ref="a45bca712d5679aa7961ee9aa7a494d2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a45bca712d5679aa7961ee9aa7a494d2c">decaf::util::zip::Deflater::BEST_SPEED</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compression level for fastest compression. </p>

</div>
</div>
<a class="anchor" id="aebe7736ca9bf73c63185eb362855c13e"></a><!-- doxytag: member="decaf::util::zip::Deflater::DEFAULT_COMPRESSION" ref="aebe7736ca9bf73c63185eb362855c13e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#aebe7736ca9bf73c63185eb362855c13e">decaf::util::zip::Deflater::DEFAULT_COMPRESSION</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default compression level. </p>

</div>
</div>
<a class="anchor" id="a23c009eab2f3f47decb334b7f43e6a7a"></a><!-- doxytag: member="decaf::util::zip::Deflater::DEFAULT_STRATEGY" ref="a23c009eab2f3f47decb334b7f43e6a7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a23c009eab2f3f47decb334b7f43e6a7a">decaf::util::zip::Deflater::DEFAULT_STRATEGY</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default compression strategy. </p>

</div>
</div>
<a class="anchor" id="affd4e2a6a7f7fbc70a3be05ef5cea9fe"></a><!-- doxytag: member="decaf::util::zip::Deflater::DEFLATED" ref="affd4e2a6a7f7fbc70a3be05ef5cea9fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#affd4e2a6a7f7fbc70a3be05ef5cea9fe">decaf::util::zip::Deflater::DEFLATED</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compression method for the deflate algorithm (the only one currently supported). </p>

</div>
</div>
<a class="anchor" id="aa5445980e72f3b60a8b1f123b8f7ec0e"></a><!-- doxytag: member="decaf::util::zip::Deflater::FILTERED" ref="aa5445980e72f3b60a8b1f123b8f7ec0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#aa5445980e72f3b60a8b1f123b8f7ec0e">decaf::util::zip::Deflater::FILTERED</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compression strategy best used for data consisting mostly of small values with a somewhat random distribution. </p>
<p>Forces more Huffman coding and less string matching. </p>

</div>
</div>
<a class="anchor" id="a03eec580775f8cc61b78b326ba95794f"></a><!-- doxytag: member="decaf::util::zip::Deflater::HUFFMAN_ONLY" ref="a03eec580775f8cc61b78b326ba95794f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a03eec580775f8cc61b78b326ba95794f">decaf::util::zip::Deflater::HUFFMAN_ONLY</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compression strategy for Huffman coding only. </p>

</div>
</div>
<a class="anchor" id="a080f6222cf01ccd1dc4c8f9955a1bcf5"></a><!-- doxytag: member="decaf::util::zip::Deflater::NO_COMPRESSION" ref="a080f6222cf01ccd1dc4c8f9955a1bcf5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html#a080f6222cf01ccd1dc4c8f9955a1bcf5">decaf::util::zip::Deflater::NO_COMPRESSION</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compression level for no compression. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/zip/<a class="el" href="_deflater_8h_source.html">Deflater.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1zip.html">zip</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html">Deflater</a>      </li>
      <li class="footer">Generated on Mon Apr 25 2011 for activemq-cpp-3.4.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
