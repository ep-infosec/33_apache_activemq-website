<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>activemq-cpp-3.6.0: decaf::internal::util::ByteArrayAdapter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.6.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">decaf::internal::util::ByteArrayAdapter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on the same base byte array without copying data.  
 <a href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_array_adapter_8h_source.html">src/main/decaf/internal/util/ByteArrayAdapter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><b>Array</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a129fc709f9c0dd4107afc2b4ded1d69a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a129fc709f9c0dd4107afc2b4ded1d69a">ByteArrayAdapter</a> (int size)</td></tr>
<tr class="memdesc:a129fc709f9c0dd4107afc2b4ded1d69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that is allocated internally and is then owned and deleted when this object is deleted.  <a href="#a129fc709f9c0dd4107afc2b4ded1d69a"></a><br/></td></tr>
<tr class="memitem:a9f1ee6fbf6c07881a5a1eca7af9df6ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a9f1ee6fbf6c07881a5a1eca7af9df6ff">ByteArrayAdapter</a> (unsigned char *array, int size, bool own=false)</td></tr>
<tr class="memdesc:a9f1ee6fbf6c07881a5a1eca7af9df6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a9f1ee6fbf6c07881a5a1eca7af9df6ff"></a><br/></td></tr>
<tr class="memitem:a8697a7ae20c23b149373a29c4a0da4bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8697a7ae20c23b149373a29c4a0da4bf">ByteArrayAdapter</a> (char *array, int size, bool own=false)</td></tr>
<tr class="memdesc:a8697a7ae20c23b149373a29c4a0da4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a8697a7ae20c23b149373a29c4a0da4bf"></a><br/></td></tr>
<tr class="memitem:ac733ad44be96cc14a9d64c275f81fa43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ac733ad44be96cc14a9d64c275f81fa43">ByteArrayAdapter</a> (double *array, int size, bool own=false)</td></tr>
<tr class="memdesc:ac733ad44be96cc14a9d64c275f81fa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#ac733ad44be96cc14a9d64c275f81fa43"></a><br/></td></tr>
<tr class="memitem:a9fc613305289bb100de9a5bce35e819f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a9fc613305289bb100de9a5bce35e819f">ByteArrayAdapter</a> (float *array, int size, bool own=false)</td></tr>
<tr class="memdesc:a9fc613305289bb100de9a5bce35e819f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a9fc613305289bb100de9a5bce35e819f"></a><br/></td></tr>
<tr class="memitem:a728d90f07cafdcbb940fd29e023b7807"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a728d90f07cafdcbb940fd29e023b7807">ByteArrayAdapter</a> (long long *array, int size, bool own=false)</td></tr>
<tr class="memdesc:a728d90f07cafdcbb940fd29e023b7807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a728d90f07cafdcbb940fd29e023b7807"></a><br/></td></tr>
<tr class="memitem:a713178b4fa8a601d110f03c8729ad23b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a713178b4fa8a601d110f03c8729ad23b">ByteArrayAdapter</a> (int *array, int size, bool own=false)</td></tr>
<tr class="memdesc:a713178b4fa8a601d110f03c8729ad23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a713178b4fa8a601d110f03c8729ad23b"></a><br/></td></tr>
<tr class="memitem:a09ca92ea3548903921e93dd804865a9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a09ca92ea3548903921e93dd804865a9f">ByteArrayAdapter</a> (short *array, int size, bool own=false)</td></tr>
<tr class="memdesc:a09ca92ea3548903921e93dd804865a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte array object that wraps the given array.  <a href="#a09ca92ea3548903921e93dd804865a9f"></a><br/></td></tr>
<tr class="memitem:abf0b78333ebfb2f49f043fd6f3b18948"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#abf0b78333ebfb2f49f043fd6f3b18948">~ByteArrayAdapter</a> ()</td></tr>
<tr class="memitem:a2f77697fb426146a7302f2ebee5e297c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a2f77697fb426146a7302f2ebee5e297c">getCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2f77697fb426146a7302f2ebee5e297c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array.  <a href="#a2f77697fb426146a7302f2ebee5e297c"></a><br/></td></tr>
<tr class="memitem:a8ec6e02f6a12c189fb0308c9893d88ef"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8ec6e02f6a12c189fb0308c9893d88ef">getCharCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a8ec6e02f6a12c189fb0308c9893d88ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains chars.  <a href="#a8ec6e02f6a12c189fb0308c9893d88ef"></a><br/></td></tr>
<tr class="memitem:a65a3d1a278ce5ef5846acb38e6607519"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a65a3d1a278ce5ef5846acb38e6607519">getDoubleCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a65a3d1a278ce5ef5846acb38e6607519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains doubles.  <a href="#a65a3d1a278ce5ef5846acb38e6607519"></a><br/></td></tr>
<tr class="memitem:a8d300e5b319be6b52553205aba23509e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8d300e5b319be6b52553205aba23509e">getFloatCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a8d300e5b319be6b52553205aba23509e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains doubles.  <a href="#a8d300e5b319be6b52553205aba23509e"></a><br/></td></tr>
<tr class="memitem:a99d163d012791c43d190baa0b1476791"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a99d163d012791c43d190baa0b1476791">getLongCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a99d163d012791c43d190baa0b1476791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains doubles.  <a href="#a99d163d012791c43d190baa0b1476791"></a><br/></td></tr>
<tr class="memitem:ae0cbdaf8811b42b67d27c979053687d0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae0cbdaf8811b42b67d27c979053687d0">getIntCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae0cbdaf8811b42b67d27c979053687d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains ints.  <a href="#ae0cbdaf8811b42b67d27c979053687d0"></a><br/></td></tr>
<tr class="memitem:acd2b054061171b2203eb6ae7f399d4f1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#acd2b054061171b2203eb6ae7f399d4f1">getShortCapacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:acd2b054061171b2203eb6ae7f399d4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the underlying array as if it contains shorts.  <a href="#acd2b054061171b2203eb6ae7f399d4f1"></a><br/></td></tr>
<tr class="memitem:a3c624ccc9090ed86206f513646fed8bc"><td class="memItemLeft" align="right" valign="top">virtual unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a3c624ccc9090ed86206f513646fed8bc">getByteArray</a> ()</td></tr>
<tr class="memdesc:a3c624ccc9090ed86206f513646fed8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a3c624ccc9090ed86206f513646fed8bc"></a><br/></td></tr>
<tr class="memitem:a78aa44ef21b2721025716d6977498d01"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a78aa44ef21b2721025716d6977498d01">getCharArray</a> ()</td></tr>
<tr class="memdesc:a78aa44ef21b2721025716d6977498d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a78aa44ef21b2721025716d6977498d01"></a><br/></td></tr>
<tr class="memitem:a97b2e502b0ec09e58d9793852817fffa"><td class="memItemLeft" align="right" valign="top">virtual short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a97b2e502b0ec09e58d9793852817fffa">getShortArray</a> ()</td></tr>
<tr class="memdesc:a97b2e502b0ec09e58d9793852817fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a97b2e502b0ec09e58d9793852817fffa"></a><br/></td></tr>
<tr class="memitem:afd942eeec67062fd63136ca2a1a9d5a8"><td class="memItemLeft" align="right" valign="top">virtual int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#afd942eeec67062fd63136ca2a1a9d5a8">getIntArray</a> ()</td></tr>
<tr class="memdesc:afd942eeec67062fd63136ca2a1a9d5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#afd942eeec67062fd63136ca2a1a9d5a8"></a><br/></td></tr>
<tr class="memitem:a7acd75e86a282814f79e3dc2d69e553d"><td class="memItemLeft" align="right" valign="top">virtual long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a7acd75e86a282814f79e3dc2d69e553d">getLongArray</a> ()</td></tr>
<tr class="memdesc:a7acd75e86a282814f79e3dc2d69e553d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a7acd75e86a282814f79e3dc2d69e553d"></a><br/></td></tr>
<tr class="memitem:a6ec9dfb41f81a6652aa6b5aab651e4f4"><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a6ec9dfb41f81a6652aa6b5aab651e4f4">getDoubleArray</a> ()</td></tr>
<tr class="memdesc:a6ec9dfb41f81a6652aa6b5aab651e4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#a6ec9dfb41f81a6652aa6b5aab651e4f4"></a><br/></td></tr>
<tr class="memitem:acb4c0a6c062feda0bef44dc035d9b91e"><td class="memItemLeft" align="right" valign="top">virtual float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#acb4c0a6c062feda0bef44dc035d9b91e">getFloatArray</a> ()</td></tr>
<tr class="memdesc:acb4c0a6c062feda0bef44dc035d9b91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer to the array we are wrapping.  <a href="#acb4c0a6c062feda0bef44dc035d9b91e"></a><br/></td></tr>
<tr class="memitem:a6dfd6373e8c2b327057998fa91ebf79d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a6dfd6373e8c2b327057998fa91ebf79d">read</a> (unsigned char *buffer, int size, int offset, int length) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a6dfd6373e8c2b327057998fa91ebf79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from the Byte array starting at the specified offset and reading the specified length.  <a href="#a6dfd6373e8c2b327057998fa91ebf79d"></a><br/></td></tr>
<tr class="memitem:a0857e62a493c01a56e926e2cca7025ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a0857e62a493c01a56e926e2cca7025ee">write</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a0857e62a493c01a56e926e2cca7025ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes from the Byte array given, starting at the specified offset and writing the specified amount of data into this objects internal array.  <a href="#a0857e62a493c01a56e926e2cca7025ee"></a><br/></td></tr>
<tr class="memitem:a8e4f9367846260c30f864e35336c7a23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8e4f9367846260c30f864e35336c7a23">resize</a> (int size)</td></tr>
<tr class="memdesc:a8e4f9367846260c30f864e35336c7a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the underlying array to the new given size, preserving all the Data that was previously in the array, unless the resize is smaller than the current size in which case only the data that will fit into the new array is preserved.  <a href="#a8e4f9367846260c30f864e35336c7a23"></a><br/></td></tr>
<tr class="memitem:a15e748c8c2f300b5c6669c391de6dcd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a15e748c8c2f300b5c6669c391de6dcd4">clear</a> ()</td></tr>
<tr class="memdesc:a15e748c8c2f300b5c6669c391de6dcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all data from that Array, setting the underlying bytes to zero.  <a href="#a15e748c8c2f300b5c6669c391de6dcd4"></a><br/></td></tr>
<tr class="memitem:ab07fac85b8d56ac42158fe5f99e156d8"><td class="memItemLeft" align="right" valign="top">unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ab07fac85b8d56ac42158fe5f99e156d8">operator[]</a> (int index)</td></tr>
<tr class="memdesc:ab07fac85b8d56ac42158fe5f99e156d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> to be indexed as a standard array.  <a href="#ab07fac85b8d56ac42158fe5f99e156d8"></a><br/></td></tr>
<tr class="memitem:a615c80f6585ed4ea2ca597be21860683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a615c80f6585ed4ea2ca597be21860683">operator[]</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:ae8a1a7092425a5b51f2181b7289c531b"><td class="memItemLeft" align="right" valign="top">virtual unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae8a1a7092425a5b51f2181b7289c531b">get</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae8a1a7092425a5b51f2181b7289c531b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.  <a href="#ae8a1a7092425a5b51f2181b7289c531b"></a><br/></td></tr>
<tr class="memitem:af999e971a4ea7f5bb1dc32cfc3b1f5d3"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#af999e971a4ea7f5bb1dc32cfc3b1f5d3">getChar</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:af999e971a4ea7f5bb1dc32cfc3b1f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte at the given index and returns it.  <a href="#af999e971a4ea7f5bb1dc32cfc3b1f5d3"></a><br/></td></tr>
<tr class="memitem:a592d4bb8b2d5c76bec3754b34bcdfca4"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a592d4bb8b2d5c76bec3754b34bcdfca4">getDouble</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a592d4bb8b2d5c76bec3754b34bcdfca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.  <a href="#a592d4bb8b2d5c76bec3754b34bcdfca4"></a><br/></td></tr>
<tr class="memitem:ae4f899c3f36e51b69ebad06b206e7875"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae4f899c3f36e51b69ebad06b206e7875">getDoubleAt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae4f899c3f36e51b69ebad06b206e7875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given byte index and returns it.  <a href="#ae4f899c3f36e51b69ebad06b206e7875"></a><br/></td></tr>
<tr class="memitem:aa9f37f27dd2d7ee9574674fa7d72eeb7"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aa9f37f27dd2d7ee9574674fa7d72eeb7">getFloat</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:aa9f37f27dd2d7ee9574674fa7d72eeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.  <a href="#aa9f37f27dd2d7ee9574674fa7d72eeb7"></a><br/></td></tr>
<tr class="memitem:a40fefaa23edba36a625f1dc285529bfb"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a40fefaa23edba36a625f1dc285529bfb">getFloatAt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a40fefaa23edba36a625f1dc285529bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given byte index and returns it.  <a href="#a40fefaa23edba36a625f1dc285529bfb"></a><br/></td></tr>
<tr class="memitem:aca8e87b3d2e0481ef7f87ce18ba7af0e"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aca8e87b3d2e0481ef7f87ce18ba7af0e">getLong</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:aca8e87b3d2e0481ef7f87ce18ba7af0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.  <a href="#aca8e87b3d2e0481ef7f87ce18ba7af0e"></a><br/></td></tr>
<tr class="memitem:a2688a33d7df9c95c1ecfe35895db2a81"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a2688a33d7df9c95c1ecfe35895db2a81">getLongAt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2688a33d7df9c95c1ecfe35895db2a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given byte index and returns it.  <a href="#a2688a33d7df9c95c1ecfe35895db2a81"></a><br/></td></tr>
<tr class="memitem:a5a6112c2b9c8f9887b40822292d567cc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a5a6112c2b9c8f9887b40822292d567cc">getInt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a5a6112c2b9c8f9887b40822292d567cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.  <a href="#a5a6112c2b9c8f9887b40822292d567cc"></a><br/></td></tr>
<tr class="memitem:a6d973809765ee8b5b33fd10a927c8b10"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a6d973809765ee8b5b33fd10a927c8b10">getIntAt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a6d973809765ee8b5b33fd10a927c8b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given byte index and returns it.  <a href="#a6d973809765ee8b5b33fd10a927c8b10"></a><br/></td></tr>
<tr class="memitem:a50991610ce4f40ddbfdbc40b5701022c"><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a50991610ce4f40ddbfdbc40b5701022c">getShort</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a50991610ce4f40ddbfdbc40b5701022c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads two bytes at the given index and returns it.  <a href="#a50991610ce4f40ddbfdbc40b5701022c"></a><br/></td></tr>
<tr class="memitem:af7bde9ec83b4c69a6e164721dc665a65"><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#af7bde9ec83b4c69a6e164721dc665a65">getShortAt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:af7bde9ec83b4c69a6e164721dc665a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads two bytes at the given byte index and returns it.  <a href="#af7bde9ec83b4c69a6e164721dc665a65"></a><br/></td></tr>
<tr class="memitem:ac7bd95554124bb5a28f19f3c71c9155d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ac7bd95554124bb5a28f19f3c71c9155d">put</a> (int index, unsigned char value)</td></tr>
<tr class="memdesc:ac7bd95554124bb5a28f19f3c71c9155d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte into this buffer at the given index.  <a href="#ac7bd95554124bb5a28f19f3c71c9155d"></a><br/></td></tr>
<tr class="memitem:aa5423888295ce5eb22309f0799878b0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aa5423888295ce5eb22309f0799878b0a">putChar</a> (int index, char value)</td></tr>
<tr class="memdesc:aa5423888295ce5eb22309f0799878b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte containing the given value, into this buffer at the given index.  <a href="#aa5423888295ce5eb22309f0799878b0a"></a><br/></td></tr>
<tr class="memitem:a04781d674d2904e7486b500199fbc880"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a04781d674d2904e7486b500199fbc880">putDouble</a> (int index, double value)</td></tr>
<tr class="memdesc:a04781d674d2904e7486b500199fbc880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.  <a href="#a04781d674d2904e7486b500199fbc880"></a><br/></td></tr>
<tr class="memitem:a7e8dcc06095daacc4fcb354ea2a65aee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a7e8dcc06095daacc4fcb354ea2a65aee">putDoubleAt</a> (int index, double value)</td></tr>
<tr class="memdesc:a7e8dcc06095daacc4fcb354ea2a65aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given byte index.  <a href="#a7e8dcc06095daacc4fcb354ea2a65aee"></a><br/></td></tr>
<tr class="memitem:a8c97675a65adb7d964b2acd460f08747"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a8c97675a65adb7d964b2acd460f08747">putFloat</a> (int index, float value)</td></tr>
<tr class="memdesc:a8c97675a65adb7d964b2acd460f08747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.  <a href="#a8c97675a65adb7d964b2acd460f08747"></a><br/></td></tr>
<tr class="memitem:ae59dd74fb3affbc0e33351dc233b3710"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ae59dd74fb3affbc0e33351dc233b3710">putFloatAt</a> (int index, float value)</td></tr>
<tr class="memdesc:ae59dd74fb3affbc0e33351dc233b3710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given byte index.  <a href="#ae59dd74fb3affbc0e33351dc233b3710"></a><br/></td></tr>
<tr class="memitem:adcca10347197d3e391c94c632534d2c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#adcca10347197d3e391c94c632534d2c0">putLong</a> (int index, long long value)</td></tr>
<tr class="memdesc:adcca10347197d3e391c94c632534d2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.  <a href="#adcca10347197d3e391c94c632534d2c0"></a><br/></td></tr>
<tr class="memitem:a2f3ac887d4e6c3fd1a7b60176cb95049"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a2f3ac887d4e6c3fd1a7b60176cb95049">putLongAt</a> (int index, long long value)</td></tr>
<tr class="memdesc:a2f3ac887d4e6c3fd1a7b60176cb95049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given byte index.  <a href="#a2f3ac887d4e6c3fd1a7b60176cb95049"></a><br/></td></tr>
<tr class="memitem:aedb948bdbcd08fc5faa57eb4297b977b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#aedb948bdbcd08fc5faa57eb4297b977b">putInt</a> (int index, int value)</td></tr>
<tr class="memdesc:aedb948bdbcd08fc5faa57eb4297b977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.  <a href="#aedb948bdbcd08fc5faa57eb4297b977b"></a><br/></td></tr>
<tr class="memitem:a5bec39a3dbaf86c534eb77410e7ec45e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a5bec39a3dbaf86c534eb77410e7ec45e">putIntAt</a> (int index, int value)</td></tr>
<tr class="memdesc:a5bec39a3dbaf86c534eb77410e7ec45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given byte index.  <a href="#a5bec39a3dbaf86c534eb77410e7ec45e"></a><br/></td></tr>
<tr class="memitem:a1ce00b38db02f687041d274a50b1d4f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#a1ce00b38db02f687041d274a50b1d4f1">putShort</a> (int index, short value)</td></tr>
<tr class="memdesc:a1ce00b38db02f687041d274a50b1d4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the given index.  <a href="#a1ce00b38db02f687041d274a50b1d4f1"></a><br/></td></tr>
<tr class="memitem:ab705235270f67acf6dc2323821a21fd9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html#ab705235270f67acf6dc2323821a21fd9">putShortAt</a> (int index, short value)</td></tr>
<tr class="memdesc:ab705235270f67acf6dc2323821a21fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the given byte index.  <a href="#ab705235270f67acf6dc2323821a21fd9"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on the same base byte array without copying data. </p>
<p>All the array types are mapped down to a byte array and methods are supplied for accessing the data in any of the primitive type forms.</p>
<p>Methods in this class that do not return a specific value return a reference to this object so that calls can be chained.</p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a129fc709f9c0dd4107afc2b4ded1d69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that is allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f1ee6fbf6c07881a5a1eca7af9df6ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8697a7ae20c23b149373a29c4a0da4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac733ad44be96cc14a9d64c275f81fa43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fc613305289bb100de9a5bce35e819f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a728d90f07cafdcbb940fd29e023b7807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a713178b4fa8a601d110f03c8729ad23b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09ca92ea3548903921e93dd804865a9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::util::ByteArrayAdapter::ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte array object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The physical array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">own</td><td>Indicates if this class is now the owner of the pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the size is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf0b78333ebfb2f49f043fd6f3b18948"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::util::ByteArrayAdapter::~ByteArrayAdapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a15e748c8c2f300b5c6669c391de6dcd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all data from that Array, setting the underlying bytes to zero. </p>

</div>
</div>
<a class="anchor" id="ae8a1a7092425a5b51f2181b7289c531b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char decaf::internal::util::ByteArrayAdapter::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute get method. </p>
<p>Reads the byte at the given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte that is located at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>If index is not smaller than the buffer's limit or is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c624ccc9090ed86206f513646fed8bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char* decaf::internal::util::ByteArrayAdapter::getByteArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an unsigned char* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f77697fb426146a7302f2ebee5e297c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="af999e971a4ea7f5bb1dc32cfc3b1f5d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::util::ByteArrayAdapter::getChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads one byte at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte that is located at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>If index is not smaller than the buffer's limit or is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78aa44ef21b2721025716d6977498d01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* decaf::internal::util::ByteArrayAdapter::getCharArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an char* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ec6e02f6a12c189fb0308c9893d88ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getCharCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array as if it contains chars. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a592d4bb8b2d5c76bec3754b34bcdfca4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::internal::util::ByteArrayAdapter::getDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads eight bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ec9dfb41f81a6652aa6b5aab651e4f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double* decaf::internal::util::ByteArrayAdapter::getDoubleArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an double* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4f899c3f36e51b69ebad06b206e7875"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::internal::util::ByteArrayAdapter::getDoubleAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads eight bytes at the given byte index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65a3d1a278ce5ef5846acb38e6607519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getDoubleCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array as if it contains doubles. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9f37f27dd2d7ee9574674fa7d72eeb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::internal::util::ByteArrayAdapter::getFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads four bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb4c0a6c062feda0bef44dc035d9b91e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float* decaf::internal::util::ByteArrayAdapter::getFloatArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an float* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a40fefaa23edba36a625f1dc285529bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::internal::util::ByteArrayAdapter::getFloatAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads four bytes at the given byte index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d300e5b319be6b52553205aba23509e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getFloatCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array as if it contains doubles. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6112c2b9c8f9887b40822292d567cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads four bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd942eeec67062fd63136ca2a1a9d5a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int* decaf::internal::util::ByteArrayAdapter::getIntArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an int* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d973809765ee8b5b33fd10a927c8b10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getIntAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads four bytes at the given byte index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0cbdaf8811b42b67d27c979053687d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getIntCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array as if it contains ints. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="aca8e87b3d2e0481ef7f87ce18ba7af0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::internal::util::ByteArrayAdapter::getLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads eight bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7acd75e86a282814f79e3dc2d69e553d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long* decaf::internal::util::ByteArrayAdapter::getLongArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an long long* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="a2688a33d7df9c95c1ecfe35895db2a81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::internal::util::ByteArrayAdapter::getLongAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads eight bytes at the given byte index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99d163d012791c43d190baa0b1476791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getLongCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array as if it contains doubles. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a50991610ce4f40ddbfdbc40b5701022c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::internal::util::ByteArrayAdapter::getShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads two bytes at the given index and returns it. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97b2e502b0ec09e58d9793852817fffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short* decaf::internal::util::ByteArrayAdapter::getShortArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pointer to the array we are wrapping. </p>
<p>Changes to the data in this array are reflected by all <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> objects that point to this array. </p>
<dl class="section return"><dt>Returns</dt><dd>an short* pointer to the array this object wraps. </dd></dl>

</div>
</div>
<a class="anchor" id="af7bde9ec83b4c69a6e164721dc665a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::internal::util::ByteArrayAdapter::getShortAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads two bytes at the given byte index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Buffer where the bytes are to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd2b054061171b2203eb6ae7f399d4f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::util::ByteArrayAdapter::getShortCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the underlying array as if it contains shorts. </p>
<dl class="section return"><dt>Returns</dt><dd>the size the array. </dd></dl>

</div>
</div>
<a class="anchor" id="ab07fac85b8d56ac42158fe5f99e156d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char&amp; decaf::internal::util::ByteArrayAdapter::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> to be indexed as a standard array. </p>
<p>calling the non constant version allows the user to change the value at index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the array to access, if the value is negative or greater than the size of the underlying array an IndexOutOfBoundsException is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of index are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a615c80f6585ed4ea2ca597be21860683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> unsigned char&amp; decaf::internal::util::ByteArrayAdapter::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7bd95554124bb5a28f19f3c71c9155d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given byte into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5423888295ce5eb22309f0799878b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes one byte containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04781d674d2904e7486b500199fbc880"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e8dcc06095daacc4fcb354ea2a65aee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putDoubleAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given byte index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c97675a65adb7d964b2acd460f08747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae59dd74fb3affbc0e33351dc233b3710"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putFloatAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given byte index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedb948bdbcd08fc5faa57eb4297b977b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bec39a3dbaf86c534eb77410e7ec45e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putIntAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given byte index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcca10347197d3e391c94c632534d2c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f3ac887d4e6c3fd1a7b60176cb95049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putLongAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given byte index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ce00b38db02f687041d274a50b1d4f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the given index. </p>
<p>The index is a relative to the size of the type to be read, in other words when accessing the element in the array index * sizeof( type ) if the actual start index of the type to be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab705235270f67acf6dc2323821a21fd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&amp; decaf::internal::util::ByteArrayAdapter::putShortAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the given byte index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the Buffer to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dfd6373e8c2b327057998fa91ebf79d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads from the Byte array starting at the specified offset and reading the specified length. </p>
<p>If the length is greater than the size of this underlying byte array then an BufferUnderflowException is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read data from this array into. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in this array to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to read from this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length exceeds the size. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer is null </td></tr>
    <tr><td class="paramname">BufferUnderflowException</td><td>if there is not enough data to read because the offset or the length is greater than the size of this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e4f9367846260c30f864e35336c7a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the underlying array to the new given size, preserving all the Data that was previously in the array, unless the resize is smaller than the current size in which case only the data that will fit into the new array is preserved. </p>
<p>A <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html" title="This class adapts primitive type arrays to a base byte array so that the classes can inter-operate on...">ByteArrayAdapter</a> can only be resized when it owns the underlying array, if it does not then it will throw an InvalidStateException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the size parameter is negative. </td></tr>
    <tr><td class="paramname">InvalidStateException</td><td>if this object does not own the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0857e62a493c01a56e926e2cca7025ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::util::ByteArrayAdapter::write </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes from the Byte array given, starting at the specified offset and writing the specified amount of data into this objects internal array. </p>
<p>. If the length is greater than the size of this underlying byte array then an BufferOverflowException is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read data from this array into. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in this array to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to read from this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length exceeds the size. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if buffer is null </td></tr>
    <tr><td class="paramname">BufferOverflowException</td><td>if the amount of data to be written to this array or the offset given are larger than this array's size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/util/<a class="el" href="_byte_array_adapter_8h_source.html">ByteArrayAdapter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a></li>
    <li class="footer">Generated on Mon Mar 4 2013 10:25:50 for activemq-cpp-3.6.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
