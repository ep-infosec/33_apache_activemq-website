<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>activemq-cpp-3.6.0: decaf::nio::ByteBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.6.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1nio_1_1_byte_buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">decaf::nio::ByteBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class defines six categories of operations upon byte buffers:  
 <a href="classdecaf_1_1nio_1_1_byte_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_buffer_8h_source.html">src/main/decaf/nio/ByteBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::nio::ByteBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1nio_1_1_byte_buffer__inherit__graph.png" border="0" usemap="#decaf_1_1nio_1_1_byte_buffer_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1nio_1_1_byte_buffer_inherit__map" id="decaf_1_1nio_1_1_byte_buffer_inherit__map">
<area shape="rect" id="node7" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:" alt="" coords="80,177,205,221"/><area shape="rect" id="node2" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type." alt="" coords="5,14,120,42"/><area shape="rect" id="node4" href="classdecaf_1_1lang_1_1_comparable.html" title="decaf::lang::Comparable\l\&lt; ByteBuffer \&gt;" alt="" coords="144,6,301,50"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a428c1ad4f7364ea2ae6b8e9fc8e544eb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a428c1ad4f7364ea2ae6b8e9fc8e544eb">~ByteBuffer</a> ()</td></tr>
<tr class="memitem:ab0775a27fbf1b127e80f75249a36b092"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ab0775a27fbf1b127e80f75249a36b092">toString</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:ab776f7db5d1f2e22e4dc0997377f89f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ab776f7db5d1f2e22e4dc0997377f89f6">get</a> (std::vector&lt; unsigned char &gt; buffer)</td></tr>
<tr class="memdesc:ab776f7db5d1f2e22e4dc0997377f89f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk get method.  <a href="#ab776f7db5d1f2e22e4dc0997377f89f6"></a><br/></td></tr>
<tr class="memitem:a36a8a51f5b194d433cbc510d8a6c4f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a36a8a51f5b194d433cbc510d8a6c4f96">get</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a36a8a51f5b194d433cbc510d8a6c4f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk get method.  <a href="#a36a8a51f5b194d433cbc510d8a6c4f96"></a><br/></td></tr>
<tr class="memitem:a8abb7f97eea20f14cd289b39265e60a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a8abb7f97eea20f14cd289b39265e60a1">put</a> (<a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;src)</td></tr>
<tr class="memdesc:a8abb7f97eea20f14cd289b39265e60a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers the bytes remaining in the given source buffer into this buffer.  <a href="#a8abb7f97eea20f14cd289b39265e60a1"></a><br/></td></tr>
<tr class="memitem:a5feff7dd9d00314f0f742a9a01c2876f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a5feff7dd9d00314f0f742a9a01c2876f">put</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a5feff7dd9d00314f0f742a9a01c2876f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers bytes into this buffer from the given source array.  <a href="#a5feff7dd9d00314f0f742a9a01c2876f"></a><br/></td></tr>
<tr class="memitem:ab3f24f2770ed98b51b0a070c6404df7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ab3f24f2770ed98b51b0a070c6404df7a">put</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:ab3f24f2770ed98b51b0a070c6404df7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers the entire content of the given source byte array into this buffer.  <a href="#ab3f24f2770ed98b51b0a070c6404df7a"></a><br/></td></tr>
<tr class="memitem:a71a16a78a10394b0c4ad2e50164449f4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a71a16a78a10394b0c4ad2e50164449f4">isReadOnly</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a71a16a78a10394b0c4ad2e50164449f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is read-only.  <a href="#a71a16a78a10394b0c4ad2e50164449f4"></a><br/></td></tr>
<tr class="memitem:a58f829960228ba89ce3c9960fee38588"><td class="memItemLeft" align="right" valign="top">virtual unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a58f829960228ba89ce3c9960fee38588">array</a> ()=0</td></tr>
<tr class="memdesc:a58f829960228ba89ce3c9960fee38588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte array that backs this buffer.  <a href="#a58f829960228ba89ce3c9960fee38588"></a><br/></td></tr>
<tr class="memitem:ac9c05f1b5e3852933a7fed5df3ed87c6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac9c05f1b5e3852933a7fed5df3ed87c6">arrayOffset</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:ac9c05f1b5e3852933a7fed5df3ed87c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing array of the first element of the buffer.  <a href="#ac9c05f1b5e3852933a7fed5df3ed87c6"></a><br/></td></tr>
<tr class="memitem:a9b0922b991f6c413dc51ed65be44143c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a9b0922b991f6c413dc51ed65be44143c">hasArray</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a9b0922b991f6c413dc51ed65be44143c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is backed by an accessible byte array.  <a href="#a9b0922b991f6c413dc51ed65be44143c"></a><br/></td></tr>
<tr class="memitem:a4fc24e890bf3ceb7ec3cf3f69153d89d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a4fc24e890bf3ceb7ec3cf3f69153d89d">asCharBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a4fc24e890bf3ceb7ec3cf3f69153d89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a char buffer.  <a href="#a4fc24e890bf3ceb7ec3cf3f69153d89d"></a><br/></td></tr>
<tr class="memitem:adba2171c8f780731d0f5a23fe5033e1a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#adba2171c8f780731d0f5a23fe5033e1a">asDoubleBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:adba2171c8f780731d0f5a23fe5033e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a double buffer.  <a href="#adba2171c8f780731d0f5a23fe5033e1a"></a><br/></td></tr>
<tr class="memitem:a3c020e22e86cc112b5293f845cf198a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a3c020e22e86cc112b5293f845cf198a1">asFloatBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a3c020e22e86cc112b5293f845cf198a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a float buffer.  <a href="#a3c020e22e86cc112b5293f845cf198a1"></a><br/></td></tr>
<tr class="memitem:aefd4b8e6f690e848310e32bdb969e655"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#aefd4b8e6f690e848310e32bdb969e655">asIntBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:aefd4b8e6f690e848310e32bdb969e655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a int buffer.  <a href="#aefd4b8e6f690e848310e32bdb969e655"></a><br/></td></tr>
<tr class="memitem:aa566e6db4d82627895f4d0f022771c83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#aa566e6db4d82627895f4d0f022771c83">asLongBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:aa566e6db4d82627895f4d0f022771c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a long buffer.  <a href="#aa566e6db4d82627895f4d0f022771c83"></a><br/></td></tr>
<tr class="memitem:ae5e28993426f4fda17a3c45e302de629"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ae5e28993426f4fda17a3c45e302de629">asShortBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:ae5e28993426f4fda17a3c45e302de629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a short buffer.  <a href="#ae5e28993426f4fda17a3c45e302de629"></a><br/></td></tr>
<tr class="memitem:afe697df87e754e2437e3cb9f538a7b7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#afe697df87e754e2437e3cb9f538a7b7d">asReadOnlyBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:afe697df87e754e2437e3cb9f538a7b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, read-only byte buffer that shares this buffer's content.  <a href="#afe697df87e754e2437e3cb9f538a7b7d"></a><br/></td></tr>
<tr class="memitem:a175bcc2bed9f5db43df078c4a2f5ab07"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a175bcc2bed9f5db43df078c4a2f5ab07">compact</a> ()=0</td></tr>
<tr class="memdesc:a175bcc2bed9f5db43df078c4a2f5ab07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts this buffer.  <a href="#a175bcc2bed9f5db43df078c4a2f5ab07"></a><br/></td></tr>
<tr class="memitem:a89f24a679360f0fd97e4b0be4fba6032"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a89f24a679360f0fd97e4b0be4fba6032">duplicate</a> ()=0</td></tr>
<tr class="memdesc:a89f24a679360f0fd97e4b0be4fba6032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new byte buffer that shares this buffer's content.  <a href="#a89f24a679360f0fd97e4b0be4fba6032"></a><br/></td></tr>
<tr class="memitem:a1021a589ff8a5a7b64396fddaf2ee417"><td class="memItemLeft" align="right" valign="top">virtual unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1021a589ff8a5a7b64396fddaf2ee417">get</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a1021a589ff8a5a7b64396fddaf2ee417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative get method.  <a href="#a1021a589ff8a5a7b64396fddaf2ee417"></a><br/></td></tr>
<tr class="memitem:a54eb6b93d99aee42723a1a7ee23370ef"><td class="memItemLeft" align="right" valign="top">virtual unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a54eb6b93d99aee42723a1a7ee23370ef">get</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a54eb6b93d99aee42723a1a7ee23370ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.  <a href="#a54eb6b93d99aee42723a1a7ee23370ef"></a><br/></td></tr>
<tr class="memitem:a4c8b75dc302195f745e163c25b51d55d"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a4c8b75dc302195f745e163c25b51d55d">getChar</a> ()=0</td></tr>
<tr class="memdesc:a4c8b75dc302195f745e163c25b51d55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next byte at this buffer's current position, and then increments the position by one.  <a href="#a4c8b75dc302195f745e163c25b51d55d"></a><br/></td></tr>
<tr class="memitem:ad6b7b8ee792ee3b84d454ee9457ce416"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ad6b7b8ee792ee3b84d454ee9457ce416">getChar</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:ad6b7b8ee792ee3b84d454ee9457ce416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte at the given index and returns it.  <a href="#ad6b7b8ee792ee3b84d454ee9457ce416"></a><br/></td></tr>
<tr class="memitem:aff2beacb86e0d6ba133903b98b7d7577"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#aff2beacb86e0d6ba133903b98b7d7577">getDouble</a> ()=0</td></tr>
<tr class="memdesc:aff2beacb86e0d6ba133903b98b7d7577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes at this buffer's current position, and then increments the position by that amount.  <a href="#aff2beacb86e0d6ba133903b98b7d7577"></a><br/></td></tr>
<tr class="memitem:a294cf335f19de2e22c4b055cfe90f036"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a294cf335f19de2e22c4b055cfe90f036">getDouble</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a294cf335f19de2e22c4b055cfe90f036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.  <a href="#a294cf335f19de2e22c4b055cfe90f036"></a><br/></td></tr>
<tr class="memitem:a6551924712e717a1a91363ee1b2bacb1"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a6551924712e717a1a91363ee1b2bacb1">getFloat</a> ()=0</td></tr>
<tr class="memdesc:a6551924712e717a1a91363ee1b2bacb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes at this buffer's current position, and then increments the position by that amount.  <a href="#a6551924712e717a1a91363ee1b2bacb1"></a><br/></td></tr>
<tr class="memitem:acf364fa00fd42d432a5380916aa2695c"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#acf364fa00fd42d432a5380916aa2695c">getFloat</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:acf364fa00fd42d432a5380916aa2695c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.  <a href="#acf364fa00fd42d432a5380916aa2695c"></a><br/></td></tr>
<tr class="memitem:ad24de40747a3e7b37a1de873cba78633"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ad24de40747a3e7b37a1de873cba78633">getLong</a> ()=0</td></tr>
<tr class="memdesc:ad24de40747a3e7b37a1de873cba78633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes at this buffer's current position, and then increments the position by that amount.  <a href="#ad24de40747a3e7b37a1de873cba78633"></a><br/></td></tr>
<tr class="memitem:a876ee8665b7273ebbd9f3afdca9e2318"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a876ee8665b7273ebbd9f3afdca9e2318">getLong</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a876ee8665b7273ebbd9f3afdca9e2318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.  <a href="#a876ee8665b7273ebbd9f3afdca9e2318"></a><br/></td></tr>
<tr class="memitem:a6c93fd1af57b77476e033366341b387f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a6c93fd1af57b77476e033366341b387f">getInt</a> ()=0</td></tr>
<tr class="memdesc:a6c93fd1af57b77476e033366341b387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes at this buffer's current position, and then increments the position by that amount.  <a href="#a6c93fd1af57b77476e033366341b387f"></a><br/></td></tr>
<tr class="memitem:ab83180c5e7213e6d5ea884a0a639b596"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ab83180c5e7213e6d5ea884a0a639b596">getInt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:ab83180c5e7213e6d5ea884a0a639b596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.  <a href="#ab83180c5e7213e6d5ea884a0a639b596"></a><br/></td></tr>
<tr class="memitem:ae4118e4a4d10a9809258361ed72604d2"><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ae4118e4a4d10a9809258361ed72604d2">getShort</a> ()=0</td></tr>
<tr class="memdesc:ae4118e4a4d10a9809258361ed72604d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next two bytes at this buffer's current position, and then increments the position by that amount.  <a href="#ae4118e4a4d10a9809258361ed72604d2"></a><br/></td></tr>
<tr class="memitem:afe70d35ca28a8c61f97fd69e833c85ca"><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#afe70d35ca28a8c61f97fd69e833c85ca">getShort</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:afe70d35ca28a8c61f97fd69e833c85ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads two bytes at the given index and returns it.  <a href="#afe70d35ca28a8c61f97fd69e833c85ca"></a><br/></td></tr>
<tr class="memitem:a39d985729bc52b8544017750524de848"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a39d985729bc52b8544017750524de848">put</a> (unsigned char value)=0</td></tr>
<tr class="memdesc:a39d985729bc52b8544017750524de848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte into this buffer at the current position, and then increments the position.  <a href="#a39d985729bc52b8544017750524de848"></a><br/></td></tr>
<tr class="memitem:ad37fa6fdd28d285ef95a49638a7a9533"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ad37fa6fdd28d285ef95a49638a7a9533">put</a> (int index, unsigned char value)=0</td></tr>
<tr class="memdesc:ad37fa6fdd28d285ef95a49638a7a9533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte into this buffer at the given index.  <a href="#ad37fa6fdd28d285ef95a49638a7a9533"></a><br/></td></tr>
<tr class="memitem:acb01d88222596127e6b04481753cbd93"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#acb01d88222596127e6b04481753cbd93">putChar</a> (char value)=0</td></tr>
<tr class="memdesc:acb01d88222596127e6b04481753cbd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte containing the given value, into this buffer at the current position, and then increments the position by one.  <a href="#acb01d88222596127e6b04481753cbd93"></a><br/></td></tr>
<tr class="memitem:a7cfd5a378186f655054b04c5fccc609a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a7cfd5a378186f655054b04c5fccc609a">putChar</a> (int index, char value)=0</td></tr>
<tr class="memdesc:a7cfd5a378186f655054b04c5fccc609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte containing the given value, into this buffer at the given index.  <a href="#a7cfd5a378186f655054b04c5fccc609a"></a><br/></td></tr>
<tr class="memitem:a1af3af332422adb4b5815b4e9b7aa530"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1af3af332422adb4b5815b4e9b7aa530">putDouble</a> (double value)=0</td></tr>
<tr class="memdesc:a1af3af332422adb4b5815b4e9b7aa530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight.  <a href="#a1af3af332422adb4b5815b4e9b7aa530"></a><br/></td></tr>
<tr class="memitem:a2e5fba824a16167a08a475f23dc209c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a2e5fba824a16167a08a475f23dc209c0">putDouble</a> (int index, double value)=0</td></tr>
<tr class="memdesc:a2e5fba824a16167a08a475f23dc209c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.  <a href="#a2e5fba824a16167a08a475f23dc209c0"></a><br/></td></tr>
<tr class="memitem:ac1590f34862aabd866511092e97d6c67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac1590f34862aabd866511092e97d6c67">putFloat</a> (float value)=0</td></tr>
<tr class="memdesc:ac1590f34862aabd866511092e97d6c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.  <a href="#ac1590f34862aabd866511092e97d6c67"></a><br/></td></tr>
<tr class="memitem:a1479865e4cc56ebd53a8631e01a09cc4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1479865e4cc56ebd53a8631e01a09cc4">putFloat</a> (int index, float value)=0</td></tr>
<tr class="memdesc:a1479865e4cc56ebd53a8631e01a09cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.  <a href="#a1479865e4cc56ebd53a8631e01a09cc4"></a><br/></td></tr>
<tr class="memitem:a2f54211693791fa27712c2ae1f4118b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a2f54211693791fa27712c2ae1f4118b8">putLong</a> (long long value)=0</td></tr>
<tr class="memdesc:a2f54211693791fa27712c2ae1f4118b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight.  <a href="#a2f54211693791fa27712c2ae1f4118b8"></a><br/></td></tr>
<tr class="memitem:a707363f3332e99c50588c115024e74bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a707363f3332e99c50588c115024e74bc">putLong</a> (int index, long long value)=0</td></tr>
<tr class="memdesc:a707363f3332e99c50588c115024e74bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.  <a href="#a707363f3332e99c50588c115024e74bc"></a><br/></td></tr>
<tr class="memitem:a0cdd7b6fe26dd2be2439ece7021e32e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a0cdd7b6fe26dd2be2439ece7021e32e0">putInt</a> (int value)=0</td></tr>
<tr class="memdesc:a0cdd7b6fe26dd2be2439ece7021e32e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.  <a href="#a0cdd7b6fe26dd2be2439ece7021e32e0"></a><br/></td></tr>
<tr class="memitem:a49586a0d91f0acaeee94686d62b353e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a49586a0d91f0acaeee94686d62b353e7">putInt</a> (int index, int value)=0</td></tr>
<tr class="memdesc:a49586a0d91f0acaeee94686d62b353e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.  <a href="#a49586a0d91f0acaeee94686d62b353e7"></a><br/></td></tr>
<tr class="memitem:a75f718c0f2d78861124f20f7096179ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a75f718c0f2d78861124f20f7096179ca">putShort</a> (short value)=0</td></tr>
<tr class="memdesc:a75f718c0f2d78861124f20f7096179ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the current position, and then increments the position by eight.  <a href="#a75f718c0f2d78861124f20f7096179ca"></a><br/></td></tr>
<tr class="memitem:affb006663301227c34cca892701eee5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#affb006663301227c34cca892701eee5b">putShort</a> (int index, short value)=0</td></tr>
<tr class="memdesc:affb006663301227c34cca892701eee5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the given index.  <a href="#affb006663301227c34cca892701eee5b"></a><br/></td></tr>
<tr class="memitem:a4cb7a384370045ad2376681d40db4c04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a4cb7a384370045ad2376681d40db4c04">slice</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a4cb7a384370045ad2376681d40db4c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new byte buffer whose content is a shared subsequence of this buffer's content.  <a href="#a4cb7a384370045ad2376681d40db4c04"></a><br/></td></tr>
<tr class="memitem:a2796762bd51a52934d477fa9c9f96989"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a2796762bd51a52934d477fa9c9f96989">compareTo</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2796762bd51a52934d477fa9c9f96989"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a2796762bd51a52934d477fa9c9f96989"></a><br/></td></tr>
<tr class="memitem:a1259f83508f2ede1bac255a4926eb62d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1259f83508f2ede1bac255a4926eb62d">equals</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a1259f83508f2ede1bac255a4926eb62d"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a1259f83508f2ede1bac255a4926eb62d"></a><br/></td></tr>
<tr class="memitem:a88e8e2413593b1d179df66f93bab8fde"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a88e8e2413593b1d179df66f93bab8fde">operator==</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a88e8e2413593b1d179df66f93bab8fde"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a88e8e2413593b1d179df66f93bab8fde"></a><br/></td></tr>
<tr class="memitem:a90cfa68e8432f6e9bbc283052f7aa095"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a90cfa68e8432f6e9bbc283052f7aa095">operator&lt;</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a90cfa68e8432f6e9bbc283052f7aa095"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a90cfa68e8432f6e9bbc283052f7aa095"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1nio_1_1_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1nio_1_1_buffer')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">decaf::nio::Buffer</a></td></tr>
<tr class="memitem:a8fcaea1822345689b015e19515b93b05 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a8fcaea1822345689b015e19515b93b05">Buffer</a> (int capactiy)</td></tr>
<tr class="memitem:a520c62546b6042aacaa0d50e271bca06 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a520c62546b6042aacaa0d50e271bca06">Buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;other)</td></tr>
<tr class="memitem:aa2900b83275cd9fb35009c5f5f232a2a inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#aa2900b83275cd9fb35009c5f5f232a2a">~Buffer</a> ()</td></tr>
<tr class="memitem:ad335471dcb4e7df652fbb556e59ea530 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ad335471dcb4e7df652fbb556e59ea530">capacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:ac3f3a9b58ba3c2986e0c7b3752b52c15 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a2bd74d7d5ea487a8cd5b0ab46273b14e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a2bd74d7d5ea487a8cd5b0ab46273b14e">position</a> (int newPosition)</td></tr>
<tr class="memdesc:a2bd74d7d5ea487a8cd5b0ab46273b14e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's position.  <a href="#a2bd74d7d5ea487a8cd5b0ab46273b14e"></a><br/></td></tr>
<tr class="memitem:a7517c02b4d27d040c44f970c307bf5b3 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a6d55516a05a08a813750fa4efc268708 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a6d55516a05a08a813750fa4efc268708">limit</a> (int newLimit)</td></tr>
<tr class="memdesc:a6d55516a05a08a813750fa4efc268708 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's limit.  <a href="#a6d55516a05a08a813750fa4efc268708"></a><br/></td></tr>
<tr class="memitem:aa5dccf3cd415e1c53cd0ab486877c9f7 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#aa5dccf3cd415e1c53cd0ab486877c9f7">mark</a> ()</td></tr>
<tr class="memdesc:aa5dccf3cd415e1c53cd0ab486877c9f7 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's mark at its position.  <a href="#aa5dccf3cd415e1c53cd0ab486877c9f7"></a><br/></td></tr>
<tr class="memitem:a11f11b3035d263fb9c48e3fbd58f4a4f inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a11f11b3035d263fb9c48e3fbd58f4a4f">reset</a> ()</td></tr>
<tr class="memdesc:a11f11b3035d263fb9c48e3fbd58f4a4f inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this buffer's position to the previously-marked position.  <a href="#a11f11b3035d263fb9c48e3fbd58f4a4f"></a><br/></td></tr>
<tr class="memitem:a86fcd3b1dc9b14bd98e9d0e38d505665 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a86fcd3b1dc9b14bd98e9d0e38d505665">clear</a> ()</td></tr>
<tr class="memdesc:a86fcd3b1dc9b14bd98e9d0e38d505665 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this buffer.  <a href="#a86fcd3b1dc9b14bd98e9d0e38d505665"></a><br/></td></tr>
<tr class="memitem:a39327161d79f0bde30467473eea0e4b5 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a39327161d79f0bde30467473eea0e4b5">flip</a> ()</td></tr>
<tr class="memdesc:a39327161d79f0bde30467473eea0e4b5 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips this buffer.  <a href="#a39327161d79f0bde30467473eea0e4b5"></a><br/></td></tr>
<tr class="memitem:a94ae44c9b90373b54fb6ee60451c453e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a94ae44c9b90373b54fb6ee60451c453e">rewind</a> ()</td></tr>
<tr class="memdesc:a94ae44c9b90373b54fb6ee60451c453e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds this buffer.  <a href="#a94ae44c9b90373b54fb6ee60451c453e"></a><br/></td></tr>
<tr class="memitem:a21cd75b27abc500af892a4078083c10e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e">remaining</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a21cd75b27abc500af892a4078083c10e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements between the current position and the limit.  <a href="#a21cd75b27abc500af892a4078083c10e"></a><br/></td></tr>
<tr class="memitem:ae490604c9e2caa90e20bac31b8ece696 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ae490604c9e2caa90e20bac31b8ece696">hasRemaining</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae490604c9e2caa90e20bac31b8ece696 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether there are any elements between the current position and the limit.  <a href="#ae490604c9e2caa90e20bac31b8ece696"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1lang_1_1_comparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1lang_1_1_comparable')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1lang_1_1_comparable.html">decaf::lang::Comparable< ByteBuffer ></a></td></tr>
<tr class="memitem:a4c6df497ab958b4c5d37cc665bad62e6 inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#a4c6df497ab958b4c5d37cc665bad62e6">~Comparable</a> ()</td></tr>
<tr class="memitem:a4b15bbd971c5a367ec645dcbe0f5828c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#a4b15bbd971c5a367ec645dcbe0f5828c">compareTo</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ByteBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a4b15bbd971c5a367ec645dcbe0f5828c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this object with the specified object for order.  <a href="#a4b15bbd971c5a367ec645dcbe0f5828c"></a><br/></td></tr>
<tr class="memitem:aade52c698a4a36f69c8fe4528e2c3f4f inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#aade52c698a4a36f69c8fe4528e2c3f4f">equals</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ByteBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memitem:aa75d69171dc24e84368f09d4b2b1fee3 inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#aa75d69171dc24e84368f09d4b2b1fee3">operator==</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ByteBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:aa75d69171dc24e84368f09d4b2b1fee3 inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares equality between this object and the one passed.  <a href="#aa75d69171dc24e84368f09d4b2b1fee3"></a><br/></td></tr>
<tr class="memitem:aa46ee7417a04ad1868953202f919d63c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#aa46ee7417a04ad1868953202f919d63c">operator&lt;</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ByteBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:aa46ee7417a04ad1868953202f919d63c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this object to another and returns true if this object is considered to be less than the one passed.  <a href="#aa46ee7417a04ad1868953202f919d63c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae9863941ab675d2ffa8df38bd79ae3f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ae9863941ab675d2ffa8df38bd79ae3f1">allocate</a> (int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ad335471dcb4e7df652fbb556e59ea530">capacity</a>)</td></tr>
<tr class="memdesc:ae9863941ab675d2ffa8df38bd79ae3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new byte buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#ae9863941ab675d2ffa8df38bd79ae3f1"></a><br/></td></tr>
<tr class="memitem:ada4ead524f93be19ba3792a2e9d35512"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ada4ead524f93be19ba3792a2e9d35512">wrap</a> (unsigned char *<a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a58f829960228ba89ce3c9960fee38588">array</a>, int size, int offset, int length)</td></tr>
<tr class="memdesc:ada4ead524f93be19ba3792a2e9d35512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>.  <a href="#ada4ead524f93be19ba3792a2e9d35512"></a><br/></td></tr>
<tr class="memitem:a9a5dc14f7daffa583fa9344da30867b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a9a5dc14f7daffa583fa9344da30867b7">wrap</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a9a5dc14f7daffa583fa9344da30867b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Byte Vector in a <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>.  <a href="#a9a5dc14f7daffa583fa9344da30867b7"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a36b36538ff711596c31d4a23b28af4fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a36b36538ff711596c31d4a23b28af4fd">ByteBuffer</a> (int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ad335471dcb4e7df652fbb556e59ea530">capacity</a>)</td></tr>
<tr class="memdesc:a36b36538ff711596c31d4a23b28af4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted.  <a href="#a36b36538ff711596c31d4a23b28af4fd"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classdecaf_1_1nio_1_1_buffer"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classdecaf_1_1nio_1_1_buffer')"><img src="closed.png" alt="-"/>&nbsp;Protected Attributes inherited from <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">decaf::nio::Buffer</a></td></tr>
<tr class="memitem:a99bdf8278f95d2fe0c16b2e743f3c65d inherit pro_attribs_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a99bdf8278f95d2fe0c16b2e743f3c65d">_position</a></td></tr>
<tr class="memitem:ae3a1d2c18db085baf5596f4cabd64fbc inherit pro_attribs_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ae3a1d2c18db085baf5596f4cabd64fbc">_capacity</a></td></tr>
<tr class="memitem:ae6c946fea1fa55b151141c75f463ba52 inherit pro_attribs_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ae6c946fea1fa55b151141c75f463ba52">_limit</a></td></tr>
<tr class="memitem:a9a970514fb1664b3e7d41bb760967f53 inherit pro_attribs_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a9a970514fb1664b3e7d41bb760967f53">_mark</a></td></tr>
<tr class="memitem:a15510c6918aac3ac0ca58ed9c39de46f inherit pro_attribs_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a15510c6918aac3ac0ca58ed9c39de46f">_markSet</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class defines six categories of operations upon byte buffers: </p>
<ol type="1">
<li>Absolute and relative get and put methods that read and write single bytes;</li>
<li>Relative bulk get methods that transfer contiguous sequences of bytes from this buffer into an array;</li>
<li>Relative bulk put methods that transfer contiguous sequences of bytes from a byte array or some other byte buffer into this buffer;</li>
<li>Absolute and relative get and put methods that read and write values of other primitive types, translating them to and from sequences of bytes in a particular byte order;</li>
<li>Methods for creating view buffers, which allow a byte buffer to be viewed as a buffer containing values of some other primitive type; and</li>
<li>Methods for compacting, duplicating, and slicing a byte buffer.</li>
</ol>
<p>Byte buffers can be created either by allocation, which allocates space for the buffer's content, or by wrapping an existing byte array into a buffer.</p>
<p>Access to binary data:</p>
<p>This class defines methods for reading and writing values of all other primitive types, except boolean. Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order.</p>
<p>For access to heterogeneous binary data, that is, sequences of values of different types, this class defines a family of absolute and relative get and put methods for each type. For 32-bit floating-point values, for example, this class defines:</p>
<p>float <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a6551924712e717a1a91363ee1b2bacb1" title="Reads the next four bytes at this buffer&#39;s current position, and then increments the position by that...">getFloat()</a> float getFloat(int index) void <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac1590f34862aabd866511092e97d6c67" title="Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.">putFloat(float f)</a> void <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1479865e4cc56ebd53a8631e01a09cc4" title="Writes four bytes containing the given value, into this buffer at the given index.">putFloat(int index, float f)</a></p>
<p>Corresponding methods are defined for the types char, short, int, long, and double. The index parameters of the absolute get and put methods are in terms of bytes rather than of the type being read or written.</p>
<p>For access to homogeneous binary data, that is, sequences of values of the same type, this class defines methods that can create views of a given byte buffer. A view buffer is simply another buffer whose content is backed by the byte buffer. Changes to the byte buffer's content will be visible in the view buffer, and vice versa; the two buffers' position, limit, and mark values are independent. The asFloatBuffer method, for example, creates an instance of the <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html" title="This class defines four categories of operations upon float buffers:">FloatBuffer</a> class that is backed by the byte buffer upon which the method is invoked. Corresponding view-creation methods are defined for the types char, short, int, long, and double.</p>
<p>View buffers have two important advantages over the families of type-specific get and put methods described above:</p>
<p>A view buffer is indexed not in terms of bytes but rather in terms of the type-specific size of its values;</p>
<p>A view buffer provides relative bulk get and put methods that can transfer contiguous sequences of values between a buffer and an array or some other buffer of the same type; and </p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a36b36538ff711596c31d4a23b28af4fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decaf::nio::ByteBuffer::ByteBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of the array, this is the limit we read and write to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if capacity is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a428c1ad4f7364ea2ae6b8e9fc8e544eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::nio::ByteBuffer::~ByteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="ae9863941ab675d2ffa8df38bd79ae3f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>* decaf::nio::ByteBuffer::allocate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new byte buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if capacity is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58f829960228ba89ce3c9960fee38588"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char* decaf::nio::ByteBuffer::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the byte array that backs this buffer. </p>
<p>Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.</p>
<p>Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.</p>
<dl class="section return"><dt>Returns</dt><dd>The array that backs this buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is backed by an array but is read-only </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if this buffer is not backed by an accessible array </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab872857f87d1e77d9e54c0a83e6cd8da">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c05f1b5e3852933a7fed5df3ed87c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::ByteBuffer::arrayOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset within this buffer's backing array of the first element of the buffer. </p>
<p>If this buffer is backed by an array then buffer position p corresponds to array index p + <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac9c05f1b5e3852933a7fed5df3ed87c6" title="Returns the offset within this buffer&#39;s backing array of the first element of the buffer...">arrayOffset()</a>.</p>
<p>Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.</p>
<dl class="section return"><dt>Returns</dt><dd>The offset within this buffer's array of the first element of the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is backed by an array but is read-only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if this buffer is not backed by an accessible array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a1d300022180c94d7adc08f61ff177d58">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a4fc24e890bf3ceb7ec3cf3f69153d89d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::ByteBuffer::asCharBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of this byte buffer as a char buffer. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the new Char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ae532f63b02904f8e6c1b9d3c59127615">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="adba2171c8f780731d0f5a23fe5033e1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">DoubleBuffer</a>* decaf::nio::ByteBuffer::asDoubleBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of this byte buffer as a double buffer. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the new double <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ae19e76b6cb171545a85a9785b14f3bde">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a3c020e22e86cc112b5293f845cf198a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">FloatBuffer</a>* decaf::nio::ByteBuffer::asFloatBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of this byte buffer as a float buffer. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the new float <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#adcabd9f4d7ea07108381f0fc640eb5d7">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aefd4b8e6f690e848310e32bdb969e655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">IntBuffer</a>* decaf::nio::ByteBuffer::asIntBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of this byte buffer as a int buffer. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the new int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5ac9532130690e47118f6fcfd0ef7907">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aa566e6db4d82627895f4d0f022771c83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">LongBuffer</a>* decaf::nio::ByteBuffer::asLongBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of this byte buffer as a long buffer. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the new long <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ae21a5d812ab2955bb489fbe308f2bec3">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="afe697df87e754e2437e3cb9f538a7b7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>* decaf::nio::ByteBuffer::asReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new, read-only byte buffer that shares this buffer's content. </p>
<p>The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.</p>
<p>If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.</p>
<p>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The new, read-only byte buffer which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a019e49e85d4c04f31eed42119cfa4c36">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae5e28993426f4fda17a3c45e302de629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">ShortBuffer</a>* decaf::nio::ByteBuffer::asShortBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of this byte buffer as a short buffer. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the new short <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aed21a9c70f2255bd98c5da01a0c6885d">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a175bcc2bed9f5db43df078c4a2f5ab07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compacts this buffer. </p>
<p>The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.</p>
<p>The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#afbaee538d7a19c626e53d8bbbd457fe2">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a2796762bd51a52934d477fa9c9f96989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::ByteBuffer::compareTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a89f24a679360f0fd97e4b0be4fba6032"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>* decaf::nio::ByteBuffer::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new byte buffer that shares this buffer's content. </p>
<p>The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>a new Byte <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#af9d7f25df35236782fe9eaa67a85efdf">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1259f83508f2ede1bac255a4926eb62d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::ByteBuffer::equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ab776f7db5d1f2e22e4dc0997377f89f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::get </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relative bulk get method. </p>
<p>This method transfers bytes from this buffer into the given destination vector. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation. The vector must be sized to the amount of data that is to be read, that is to say, the caller should call buffer.resize( N ) before calling this get method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this Byte <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are fewer than length bytes remaining in this buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36a8a51f5b194d433cbc510d8a6c4f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::get </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relative bulk get method. </p>
<p>This method transfers bytes from this buffer into the given destination array. If there are fewer bytes remaining in the buffer than are required to satisfy the request, that is, if length &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no bytes are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a> is thrown.</p>
<p>Otherwise, this method copies length bytes from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The pointer to an allocated buffer to fill. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the passed in <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the buffer to start filling. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to put in the passed buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of size, offset, or length are not met. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are fewer than length bytes remaining in this buffer. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the passed buffer is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1021a589ff8a5a7b64396fddaf2ee417"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char decaf::nio::ByteBuffer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative get method. </p>
<p>Reads the byte at this buffer's current position, and then increments the position.</p>
<dl class="section return"><dt>Returns</dt><dd>The byte at the buffer's current position.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if the buffer's current position is not smaller than its limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ad3d7ce119416783ca914675db93991be">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a54eb6b93d99aee42723a1a7ee23370ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char decaf::nio::ByteBuffer::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute get method. </p>
<p>Reads the byte at the given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte that is located at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a2cbfcd1386e1e219b679fe4ec2414eba">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a4c8b75dc302195f745e163c25b51d55d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::nio::ByteBuffer::getChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next byte at this buffer's current position, and then increments the position by one. </p>
<dl class="section return"><dt>Returns</dt><dd>the next char in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a716e6514c00647d3ba34a54d286e7f19">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad6b7b8ee792ee3b84d454ee9457ce416"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::nio::ByteBuffer::getChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads one byte at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the char at the given index in the buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a3eeed0099b82fe82ca66cf69614d2ba9">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aff2beacb86e0d6ba133903b98b7d7577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::nio::ByteBuffer::getDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next eight bytes at this buffer's current position, and then increments the position by that amount. </p>
<dl class="section return"><dt>Returns</dt><dd>the next double in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a1f52edcd8a4bc9dd2db604c149e4451c">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a294cf335f19de2e22c4b055cfe90f036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::nio::ByteBuffer::getDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads eight bytes at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#af167abba3f2a52b4b2d6d2ca2692a7fc">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a6551924712e717a1a91363ee1b2bacb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::nio::ByteBuffer::getFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next four bytes at this buffer's current position, and then increments the position by that amount. </p>
<dl class="section return"><dt>Returns</dt><dd>the next float in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ac22c51dc10d8e040ee3aca24469cb9e7">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="acf364fa00fd42d432a5380916aa2695c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::nio::ByteBuffer::getFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads four bytes at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#adbfc001c2239e604f43c0bd37a8ff9bb">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a6c93fd1af57b77476e033366341b387f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::ByteBuffer::getInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next four bytes at this buffer's current position, and then increments the position by that amount. </p>
<dl class="section return"><dt>Returns</dt><dd>the next int in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab7c93abc43c250a610943e987d6d4cec">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab83180c5e7213e6d5ea884a0a639b596"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::ByteBuffer::getInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads four bytes at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a07f6271ed0438e0fed8f74d31839ee10">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad24de40747a3e7b37a1de873cba78633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::nio::ByteBuffer::getLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next eight bytes at this buffer's current position, and then increments the position by that amount. </p>
<dl class="section return"><dt>Returns</dt><dd>the next long long in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a177d0e5939d7ff274efe110669c93a83">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a876ee8665b7273ebbd9f3afdca9e2318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::nio::ByteBuffer::getLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads eight bytes at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long long at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ac6fa5397b4c01cab3ecf066a2d498b2b">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae4118e4a4d10a9809258361ed72604d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::nio::ByteBuffer::getShort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next two bytes at this buffer's current position, and then increments the position by that amount. </p>
<dl class="section return"><dt>Returns</dt><dd>the next short in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aad66bb88a93fe63a04026860ac1fa641">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="afe70d35ca28a8c61f97fd69e833c85ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::nio::ByteBuffer::getShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads two bytes at the given index and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the short at the given index in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a7495ef1ffef98ecce4188770179daf6c">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a9b0922b991f6c413dc51ed65be44143c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::ByteBuffer::hasArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether or not this buffer is backed by an accessible byte array. </p>
<p>If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.</p>
<dl class="section return"><dt>Returns</dt><dd>true if, and only if, this buffer is backed by an array and is not read-only. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab88d3d871be65718a26bc10480fa1c00">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a71a16a78a10394b0c4ad2e50164449f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::ByteBuffer::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether or not this buffer is read-only. </p>
<dl class="section return"><dt>Returns</dt><dd>true if, and only if, this buffer is read-only </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a3cb8f27f48cae4bf41443d0d67b9e972">decaf::nio::Buffer</a>.</p>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a81ed73baffb070f694bcc9cd5496412a">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a90cfa68e8432f6e9bbc283052f7aa095"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::ByteBuffer::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a88e8e2413593b1d179df66f93bab8fde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::ByteBuffer::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a8abb7f97eea20f14cd289b39265e60a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method transfers the bytes remaining in the given source buffer into this buffer. </p>
<p>If there are more bytes remaining in the source buffer than in this buffer, that is, if src.remaining() &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no bytes are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a> is thrown.</p>
<p>Otherwise, this method copies n = src.remaining() bytes from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The buffer to take bytes from an place in this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is insufficient space in this buffer for the remaining bytes in the source buffer </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the source buffer is this buffer </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5feff7dd9d00314f0f742a9a01c2876f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method transfers bytes into this buffer from the given source array. </p>
<p>If there are more bytes to be copied from the array than remain in this buffer, that is, if length &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no bytes are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a> is thrown.</p>
<p>Otherwise, this method copies length bytes from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array from which bytes are to be read. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given array. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the array of the first byte to be read. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to be read from the given array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is insufficient space in this buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the passed buffer is null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of size, offset, or length are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3f24f2770ed98b51b0a070c6404df7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::put </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method transfers the entire content of the given source byte array into this buffer. </p>
<p>This is the same as calling put( &amp;buffer[0], buffer.size(), 0, buffer.size() )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer whose contents are copied to this <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is insufficient space in this buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39d985729bc52b8544017750524de848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::put </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given byte into this buffer at the current position, and then increments the position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the byte value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a6eea85981ad91107ceece849466a6e10">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad37fa6fdd28d285ef95a49638a7a9533"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given byte into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>- the byte to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aa34cd944bff34ae3968d15471d7b6072">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="acb01d88222596127e6b04481753cbd93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putChar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes one byte containing the given value, into this buffer at the current position, and then increments the position by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a940d4fe71592ea67e83d1d754f34e46f">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a7cfd5a378186f655054b04c5fccc609a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes one byte containing the given value, into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a58d45611f423e101722a99a4a7599faa">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1af3af332422adb4b5815b4e9b7aa530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putDouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5648f055607827df32cfdb8074e957f2">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a2e5fba824a16167a08a475f23dc209c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#adf4135569f27184cb922dfff238321c8">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac1590f34862aabd866511092e97d6c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a937d1ae4adcf0d609cd1c591fb4a30ec">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1479865e4cc56ebd53a8631e01a09cc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5108c794c9a9fd260ce4600c50630950">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a0cdd7b6fe26dd2be2439ece7021e32e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a29d457e7218784933a824c7b1e6f04bd">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a49586a0d91f0acaeee94686d62b353e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab310c1792f41c39f47cb5eabc8fee616">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a2f54211693791fa27712c2ae1f4118b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putLong </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a01dd135accd07d0f60fa71d1b7de2212">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a707363f3332e99c50588c115024e74bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a2c432f0586df4f41241234ec79cc94a8">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a75f718c0f2d78861124f20f7096179ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the current position, and then increments the position by eight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#acd90cd9ec81335165a2e7fdcc19d400f">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="affb006663301227c34cca892701eee5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>&amp; decaf::nio::ByteBuffer::putShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a8dfa4f8108273882549629e905ebae04">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb7a384370045ad2376681d40db4c04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>* decaf::nio::ByteBuffer::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new byte buffer whose content is a shared subsequence of this buffer's content. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> which the caller owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aeeca3e501a41ff17730aaf3e675ba6e5">decaf::internal::nio::ByteArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab0775a27fbf1b127e80f75249a36b092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string decaf::nio::ByteBuffer::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a std::string describing this object </dd></dl>

</div>
</div>
<a class="anchor" id="ada4ead524f93be19ba3792a2e9d35512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>* decaf::nio::ByteBuffer::wrap </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the provided array. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> that is backed by buffer, caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the array passed in is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of size, offset, or length are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a5dc14f7daffa583fa9344da30867b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a>* decaf::nio::ByteBuffer::wrap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Byte Vector in a <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/nio/<a class="el" href="_byte_buffer_8h_source.html">ByteBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1nio.html">nio</a></li><li class="navelem"><a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">ByteBuffer</a></li>
    <li class="footer">Generated on Mon Mar 4 2013 10:25:51 for activemq-cpp-3.6.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
