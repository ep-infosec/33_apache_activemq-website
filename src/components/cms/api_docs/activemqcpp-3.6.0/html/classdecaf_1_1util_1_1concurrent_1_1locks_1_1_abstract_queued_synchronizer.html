<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>activemq-cpp-3.6.0: decaf::util::concurrent::locks::AbstractQueuedSynchronizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.6.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">decaf::util::concurrent::locks::AbstractQueuedSynchronizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_abstract_queued_synchronizer_8h_source.html">src/main/decaf/util/concurrent/locks/AbstractQueuedSynchronizer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::locks::AbstractQueuedSynchronizer:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_inherit__map" id="decaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_inherit__map">
<area shape="rect" id="node5" title="Synchronization control for FutureTask." alt="" coords="12,193,233,237"/><area shape="rect" id="node2" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html" title="Base class for locks that provide the notion of Ownership, the types of locks that are implemented us..." alt="" coords="5,6,240,50"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">ConditionObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object for this Synchronizer, which serves as the basis for other <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html" title="Lock implementations provide more extensive locking operations than can be obtained using synchronize...">Lock</a> objects.  <a href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2f712d90466aab7c4de659a5967d8e7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ad2f712d90466aab7c4de659a5967d8e7">~AbstractQueuedSynchronizer</a> ()</td></tr>
<tr class="memitem:a1be987c73b4a0a769c17c5fdf6f181c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a1be987c73b4a0a769c17c5fdf6f181c2">acquire</a> (int arg)</td></tr>
<tr class="memdesc:a1be987c73b4a0a769c17c5fdf6f181c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock exclusively, ignoring interrupts.  <a href="#a1be987c73b4a0a769c17c5fdf6f181c2"></a><br/></td></tr>
<tr class="memitem:aeb4161b6d7c8ba177c0bf69da5a8f14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aeb4161b6d7c8ba177c0bf69da5a8f14c">acquireShared</a> (int arg)</td></tr>
<tr class="memdesc:aeb4161b6d7c8ba177c0bf69da5a8f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock in shared mode, ignoring interrupts.  <a href="#aeb4161b6d7c8ba177c0bf69da5a8f14c"></a><br/></td></tr>
<tr class="memitem:a88aad6ad12ddc0fb3d21555e70d12a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a88aad6ad12ddc0fb3d21555e70d12a6a">acquireInterruptibly</a> (int arg)</td></tr>
<tr class="memdesc:a88aad6ad12ddc0fb3d21555e70d12a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock exclusively, allowing for interrupts.  <a href="#a88aad6ad12ddc0fb3d21555e70d12a6a"></a><br/></td></tr>
<tr class="memitem:aa2a44101b40ee35c1e3fa628f415835b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aa2a44101b40ee35c1e3fa628f415835b">acquireSharedInterruptibly</a> (int arg)</td></tr>
<tr class="memdesc:aa2a44101b40ee35c1e3fa628f415835b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock in shared mode, allowing interruption.  <a href="#aa2a44101b40ee35c1e3fa628f415835b"></a><br/></td></tr>
<tr class="memitem:adb8eeb89ba3f170d68bbe5cc8c657230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a><br class="typebreak"/>
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#adb8eeb89ba3f170d68bbe5cc8c657230">getExclusiveQueuedThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:adb8eeb89ba3f170d68bbe5cc8c657230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains only those threads that may be waiting to acquire this Synchronization in exclusive mode.  <a href="#adb8eeb89ba3f170d68bbe5cc8c657230"></a><br/></td></tr>
<tr class="memitem:a378bff4b892583429766cefbf6f75cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a><br class="typebreak"/>
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a378bff4b892583429766cefbf6f75cab">getSharedQueuedThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a378bff4b892583429766cefbf6f75cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains only those threads that may be waiting to acquire this Synchronization in shared mode.  <a href="#a378bff4b892583429766cefbf6f75cab"></a><br/></td></tr>
<tr class="memitem:a773b92033fadf3db450988ae12dde775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a773b92033fadf3db450988ae12dde775">getFirstQueuedThread</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a773b92033fadf3db450988ae12dde775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first thread queue (the thread that's been waiting the longest) if there are currently no queued threads this method returns NULL.  <a href="#a773b92033fadf3db450988ae12dde775"></a><br/></td></tr>
<tr class="memitem:a58e2869b7fab52e3775a70a6f12d148a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a><br class="typebreak"/>
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a58e2869b7fab52e3775a70a6f12d148a">getQueuedThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a58e2869b7fab52e3775a70a6f12d148a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains a best effort snapshot of the threads that are currently waiting to acquire.  <a href="#a58e2869b7fab52e3775a70a6f12d148a"></a><br/></td></tr>
<tr class="memitem:ae74d39146aa232e4a20346f3e217903b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ae74d39146aa232e4a20346f3e217903b">getQueueLength</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae74d39146aa232e4a20346f3e217903b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an estimated count of the number of threads that are currently waiting to acquire, this value changes dynamically so the result of this method can be invalid immediately after it is called.  <a href="#ae74d39146aa232e4a20346f3e217903b"></a><br/></td></tr>
<tr class="memitem:a40df179a45a2a21c34443ee05d8663be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a><br class="typebreak"/>
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a40df179a45a2a21c34443ee05d8663be">getWaitingThreads</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a40df179a45a2a21c34443ee05d8663be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains all the threads that may be waiting on the given ConditionOject instance at the time this method is called.  <a href="#a40df179a45a2a21c34443ee05d8663be"></a><br/></td></tr>
<tr class="memitem:a577e3cc9e7dc4d2f8226327e4bc407ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a577e3cc9e7dc4d2f8226327e4bc407ad">getWaitQueueLength</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a577e3cc9e7dc4d2f8226327e4bc407ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an estimated count of the number of threads that are currently waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a>, this value changes dynamically so the result of this method can be invalid immediately after it is called.  <a href="#a577e3cc9e7dc4d2f8226327e4bc407ad"></a><br/></td></tr>
<tr class="memitem:a14c81c9fc71fda61ef77fb526f53fc70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a14c81c9fc71fda61ef77fb526f53fc70">hasContended</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a82159ccf09a7a816e213d71c13264834"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a82159ccf09a7a816e213d71c13264834">hasQueuedThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a8b8e460b97f6c72c2cf1d443f766c9c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a8b8e460b97f6c72c2cf1d443f766c9c4">hasWaiters</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a8b8e460b97f6c72c2cf1d443f766c9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are any threads that are currently waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a>, the condition must be associated with this synchronizer instance.  <a href="#a8b8e460b97f6c72c2cf1d443f766c9c4"></a><br/></td></tr>
<tr class="memitem:aa399ef456e6c01061975ff086f35f803"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aa399ef456e6c01061975ff086f35f803">isQueued</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *thread) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:aa399ef456e6c01061975ff086f35f803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> if waiting threads to see if the given thread is present.  <a href="#aa399ef456e6c01061975ff086f35f803"></a><br/></td></tr>
<tr class="memitem:a1c25cee40f56842eb3e3bb0e2fdd483c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a1c25cee40f56842eb3e3bb0e2fdd483c">owns</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a1c25cee40f56842eb3e3bb0e2fdd483c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> uses this Synchronizer as its lock object.  <a href="#a1c25cee40f56842eb3e3bb0e2fdd483c"></a><br/></td></tr>
<tr class="memitem:adfa5722cf52746af9de1fff4387151a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#adfa5722cf52746af9de1fff4387151a0">release</a> (int arg)</td></tr>
<tr class="memdesc:adfa5722cf52746af9de1fff4387151a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">When held in exclusive mode this method releases the Synchronizer.  <a href="#adfa5722cf52746af9de1fff4387151a0"></a><br/></td></tr>
<tr class="memitem:aa94cc4031257aefc3dc8d2d13477d277"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aa94cc4031257aefc3dc8d2d13477d277">releaseShared</a> (int arg)</td></tr>
<tr class="memdesc:aa94cc4031257aefc3dc8d2d13477d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">When held in shared mode this method releases the Synchronizer.  <a href="#aa94cc4031257aefc3dc8d2d13477d277"></a><br/></td></tr>
<tr class="memitem:a72e5b69fe58d2741675024f98092af00"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a72e5b69fe58d2741675024f98092af00">toString</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a72e5b69fe58d2741675024f98092af00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string that identifies this Synchronizer along with its present state.  <a href="#a72e5b69fe58d2741675024f98092af00"></a><br/></td></tr>
<tr class="memitem:adc3e1b653ca760c9a386cac0d3c1811b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#adc3e1b653ca760c9a386cac0d3c1811b">tryAcquireNanos</a> (int arg, long long nanos)</td></tr>
<tr class="memdesc:adc3e1b653ca760c9a386cac0d3c1811b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires in exclusive mode if possible, first checking if the calling thread has already been interrupted or not, then calling <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a2a6970a8a9eda013b318acd16180056d" title="Performs the actual work of attempting to acquire the lock in exclusive mode.">tryAcquire(int)</a> at least one time and possibly more up to the given timeout, or until the calling thread is interrupted.  <a href="#adc3e1b653ca760c9a386cac0d3c1811b"></a><br/></td></tr>
<tr class="memitem:ad3d43f436738bfeec6ce66e54b9eeece"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ad3d43f436738bfeec6ce66e54b9eeece">tryAcquireSharedNanos</a> (int arg, long long nanos)</td></tr>
<tr class="memdesc:ad3d43f436738bfeec6ce66e54b9eeece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires in shared mode if possible, first checking if the calling thread has already been interrupted or not, then calling <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ac087783c351650e3160c6bf4274ba1d1" title="Performs the actual work of attempting to acquire the lock in shared mode.">tryAcquireShared(int)</a> at least one time and possibly more up to the given timeout, or until the calling thread is interrupted.  <a href="#ad3d43f436738bfeec6ce66e54b9eeece"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html">decaf::util::concurrent::locks::AbstractOwnableSynchronizer</a></td></tr>
<tr class="memitem:a59137dd58c9ee0b73cd4b435de02129d inherit pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html#a59137dd58c9ee0b73cd4b435de02129d">~AbstractOwnableSynchronizer</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4a5af541659ee16455bfbe70f5c13cda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a4a5af541659ee16455bfbe70f5c13cda">AbstractQueuedSynchronizer</a> ()</td></tr>
<tr class="memitem:a26737c6f333a5279cd168935376711ab"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a26737c6f333a5279cd168935376711ab">getState</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a26737c6f333a5279cd168935376711ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets and returns the currently set value of this object Synchronization sate.  <a href="#a26737c6f333a5279cd168935376711ab"></a><br/></td></tr>
<tr class="memitem:a0c3e1da0ada25fd02832d99f2c162c60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a0c3e1da0ada25fd02832d99f2c162c60">setState</a> (int value)</td></tr>
<tr class="memdesc:a0c3e1da0ada25fd02832d99f2c162c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the synchronization state to the given value.  <a href="#a0c3e1da0ada25fd02832d99f2c162c60"></a><br/></td></tr>
<tr class="memitem:a55bdf048635c2a816028acf8852aa80a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a55bdf048635c2a816028acf8852aa80a">compareAndSetState</a> (int expect, int update)</td></tr>
<tr class="memdesc:a55bdf048635c2a816028acf8852aa80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the synchronization state to the specified value if the current value is equal to the expected value given, otherwise no change is made.  <a href="#a55bdf048635c2a816028acf8852aa80a"></a><br/></td></tr>
<tr class="memitem:a92244396c16cbbcfb0d982f36f914c51"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a92244396c16cbbcfb0d982f36f914c51">isHeldExclusively</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a92244396c16cbbcfb0d982f36f914c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the calling thread hold an exclusive lock on this synchronization then this method returns true, false otherwise.  <a href="#a92244396c16cbbcfb0d982f36f914c51"></a><br/></td></tr>
<tr class="memitem:a2a6970a8a9eda013b318acd16180056d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a2a6970a8a9eda013b318acd16180056d">tryAcquire</a> (int arg)</td></tr>
<tr class="memdesc:a2a6970a8a9eda013b318acd16180056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the actual work of attempting to acquire the lock in exclusive mode.  <a href="#a2a6970a8a9eda013b318acd16180056d"></a><br/></td></tr>
<tr class="memitem:ac087783c351650e3160c6bf4274ba1d1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ac087783c351650e3160c6bf4274ba1d1">tryAcquireShared</a> (int arg)</td></tr>
<tr class="memdesc:ac087783c351650e3160c6bf4274ba1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the actual work of attempting to acquire the lock in shared mode.  <a href="#ac087783c351650e3160c6bf4274ba1d1"></a><br/></td></tr>
<tr class="memitem:aa937ba519e25658dd38e834a72bde802"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aa937ba519e25658dd38e834a72bde802">tryRelease</a> (int arg)</td></tr>
<tr class="memdesc:aa937ba519e25658dd38e834a72bde802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a release for the calling thread in exclusive mode.  <a href="#aa937ba519e25658dd38e834a72bde802"></a><br/></td></tr>
<tr class="memitem:a755ce96c4ffbbad9e288292766d00a67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a755ce96c4ffbbad9e288292766d00a67">tryReleaseShared</a> (int arg)</td></tr>
<tr class="memdesc:a755ce96c4ffbbad9e288292766d00a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a release for the calling thread in shared mode.  <a href="#a755ce96c4ffbbad9e288292766d00a67"></a><br/></td></tr>
<tr class="memitem:a150422f89768c654112a41ef3ade2c5f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">ConditionObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a150422f89768c654112a41ef3ade2c5f">createDefaultConditionObject</a> ()</td></tr>
<tr class="memdesc:a150422f89768c654112a41ef3ade2c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a means for derived classes to create a <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> implemented by the basic logic implemented inside this class.  <a href="#a150422f89768c654112a41ef3ade2c5f"></a><br/></td></tr>
<tr class="memitem:a1f3d2f9b602a6f1355bb8e22be7a5fbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a1f3d2f9b602a6f1355bb8e22be7a5fbe">hasQueuedPredecessors</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a1f3d2f9b602a6f1355bb8e22be7a5fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether any threads have been waiting to acquire longer than the current thread.  <a href="#a1f3d2f9b602a6f1355bb8e22be7a5fbe"></a><br/></td></tr>
<tr class="inherit_header pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html">decaf::util::concurrent::locks::AbstractOwnableSynchronizer</a></td></tr>
<tr class="memitem:a852723df8106bad7119009e5fb4eab65 inherit pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html#a852723df8106bad7119009e5fb4eab65">AbstractOwnableSynchronizer</a> ()</td></tr>
<tr class="memitem:aca1d24ab9dd0a9274fcce9342ddb55e5 inherit pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html#aca1d24ab9dd0a9274fcce9342ddb55e5">getExclusiveOwnerThread</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:aca1d24ab9dd0a9274fcce9342ddb55e5 inherit pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Thread that was last set using the setExclusiveOwnerThread method, or NULL if no Thread has been made the exclusive owner.  <a href="#aca1d24ab9dd0a9274fcce9342ddb55e5"></a><br/></td></tr>
<tr class="memitem:af377b1c680393c7412fc31c5995a862b inherit pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html#af377b1c680393c7412fc31c5995a862b">setExclusiveOwnerThread</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *thread)</td></tr>
<tr class="memdesc:af377b1c680393c7412fc31c5995a862b inherit pro_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Thread that has exclusive ownership of this Synchronizer, can be NULL to indicate that no Thread now owns this Synchronizer.  <a href="#af377b1c680393c7412fc31c5995a862b"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abbdec5d3f61a150d2b4d6735836e8a71"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#abbdec5d3f61a150d2b4d6735836e8a71">SynchronizerState</a></td></tr>
</table>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a5af541659ee16455bfbe70f5c13cda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::concurrent::locks::AbstractQueuedSynchronizer::AbstractQueuedSynchronizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2f712d90466aab7c4de659a5967d8e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::util::concurrent::locks::AbstractQueuedSynchronizer::~AbstractQueuedSynchronizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a1be987c73b4a0a769c17c5fdf6f181c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquire </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the lock exclusively, ignoring interrupts. </p>
<p>This method will call tryAcquire at least once and return if that succeeds, otherwise it can block and possibly spin until the lock is acquired. This method can serve as the basis for a <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html#aaf5e33af82d33690f732c05b090ac47d" title="Acquires the lock.">Lock.lock()</a> implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument passed to tryAcquire, value is not interpreted by this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88aad6ad12ddc0fb3d21555e70d12a6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquireInterruptibly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the lock exclusively, allowing for interrupts. </p>
<p>If the interrupt state is not already set this method will call tryAcquire at least once and return if that succeeds, otherwise it can block and possibly spin until the lock is acquired or the Thread is interrupted. This method can serve as the basis for a <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html#a82bc56cbfa50892f16c9352f08afd195" title="Acquires the lock unless the current thread is interrupted.">Lock.lockInterruptibly()</a> implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument passed to tryAcquire, value is not interpreted by this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the calling Thread is interrupted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb4161b6d7c8ba177c0bf69da5a8f14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquireShared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the lock in shared mode, ignoring interrupts. </p>
<p>This method will call tryAcquireShared at least once and return if that succeeds, otherwise it can block and possibly spin until the lock is acquired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument passed to tryAcquireShared, value is not interpreted by this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2a44101b40ee35c1e3fa628f415835b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::concurrent::locks::AbstractQueuedSynchronizer::acquireSharedInterruptibly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the lock in shared mode, allowing interruption. </p>
<p>If the interrupt state is not already set this method will call tryAcquireShared at least once and return if that succeeds, otherwise it can block and possibly spin until the lock is acquired or the Thread is interrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument passed to tryAcquireShared, value is not interpreted by this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the calling Thread is interrupted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55bdf048635c2a816028acf8852aa80a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::compareAndSetState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the synchronization state to the specified value if the current value is equal to the expected value given, otherwise no change is made. </p>
<p>This method is Atomic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expect</td><td>The value that state must have if the update is made. </td></tr>
    <tr><td class="paramname">update</td><td>The new value to assign the state if the current value matches the expected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a change is made, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a150422f89768c654112a41ef3ade2c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">ConditionObject</a>* decaf::util::concurrent::locks::AbstractQueuedSynchronizer::createDefaultConditionObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a means for derived classes to create a <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> implemented by the basic logic implemented inside this class. </p>
<p>Can be overridden by derived classes that wish to provide their own implementation of a <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> that is owned by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="adb8eeb89ba3f170d68bbe5cc8c657230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getExclusiveQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains only those threads that may be waiting to acquire this Synchronization in exclusive mode. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> pointer that contains waiting threads for exclusive acquisition. The caller owns the returned pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a773b92033fadf3db450988ae12dde775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>* decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getFirstQueuedThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first thread queue (the thread that's been waiting the longest) if there are currently no queued threads this method returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>the first thread in the queue or NULL if none are currently waiting. </dd></dl>

</div>
</div>
<a class="anchor" id="a58e2869b7fab52e3775a70a6f12d148a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains a best effort snapshot of the threads that are currently waiting to acquire. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> pointer that contains waiting threads for lock acquisition. The caller owns the returned pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae74d39146aa232e4a20346f3e217903b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getQueueLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an estimated count of the number of threads that are currently waiting to acquire, this value changes dynamically so the result of this method can be invalid immediately after it is called. </p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of waiting threads. </dd></dl>

</div>
</div>
<a class="anchor" id="a378bff4b892583429766cefbf6f75cab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getSharedQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains only those threads that may be waiting to acquire this Synchronization in shared mode. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> pointer that contains waiting threads for shared acquisition. The caller owns the returned pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a26737c6f333a5279cd168935376711ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets and returns the currently set value of this object Synchronization sate. </p>
<dl class="section return"><dt>Returns</dt><dd>the value of the synchronization sate. </dd></dl>

</div>
</div>
<a class="anchor" id="a40df179a45a2a21c34443ee05d8663be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getWaitingThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> object that contains all the threads that may be waiting on the given ConditionOject instance at the time this method is called. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> pointer that contains waiting threads on given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a>. The caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> pointer is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> is not associated with this Synchronizer. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not hold exclusive synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a577e3cc9e7dc4d2f8226327e4bc407ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::AbstractQueuedSynchronizer::getWaitQueueLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an estimated count of the number of threads that are currently waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a>, this value changes dynamically so the result of this method can be invalid immediately after it is called. </p>
<p>The <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> must be associated with this <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html">AbstractQueuedSynchronizer</a> or an exception will be thrown.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of waiting threads.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> pointer is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> is not associated with this Synchronizer. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not hold exclusive synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14c81c9fc71fda61ef77fb526f53fc70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::hasContended </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there has ever been the need for the acquire method to block. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f3d2f9b602a6f1355bb8e22be7a5fbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::hasQueuedPredecessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether any threads have been waiting to acquire longer than the current thread. </p>
<p>Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that some other thread will acquire before the current thread. Likewise, it is possible for another thread to win a race to enqueue after this method has returned false, due to the queue being empty.</p>
<p>This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer's tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:</p>
<pre> <div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a2a6970a8a9eda013b318acd16180056d" title="Performs the actual work of attempting to acquire the lock in exclusive mode.">tryAcquire</a>(<span class="keywordtype">int</span> arg) {</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a92244396c16cbbcfb0d982f36f914c51" title="If the calling thread hold an exclusive lock on this synchronization then this method returns true...">isHeldExclusively</a>()) {</div>
<div class="line">    <span class="comment">// A reentrant acquire; increment hold count</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a1f3d2f9b602a6f1355bb8e22be7a5fbe" title="Queries whether any threads have been waiting to acquire longer than the current thread.">hasQueuedPredecessors</a>()) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// try to acquire normally</span></div>
<div class="line">  }</div>
<div class="line">} </div>
</div><!-- fragment --> 
</pre><dl class="section return"><dt>Returns</dt><dd>true if there is a queued thread preceding the current thread, and false if the current thread is at the head of the queue or the queue is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a82159ccf09a7a816e213d71c13264834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::hasQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there are threads that are currently waiting to acquire. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8e460b97f6c72c2cf1d443f766c9c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::hasWaiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are any threads that are currently waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a>, the condition must be associated with this synchronizer instance. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the condition object has waiting threads.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> pointer is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> is not associated with this Synchronizer. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not hold exclusive synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92244396c16cbbcfb0d982f36f914c51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::isHeldExclusively </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the calling thread hold an exclusive lock on this synchronization then this method returns true, false otherwise. </p>
<p>The default behavior is to throw an UnsupportedOperation exception as this method is only needed when <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> is supported.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this synchronization is held exclusively by the current thread.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> objects are not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa399ef456e6c01061975ff086f35f803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::isQueued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> if waiting threads to see if the given thread is present. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the given thread is in the wait <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the thread pointer is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c25cee40f56842eb3e3bb0e2fdd483c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::owns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html">AbstractQueuedSynchronizer::ConditionObject</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> uses this Synchronizer as its lock object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer_1_1_condition_object.html" title="Condition object for this Synchronizer, which serves as the basis for other Lock objects.">ConditionObject</a> uses this Synchronizer as its lock.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the condition pointer is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfa5722cf52746af9de1fff4387151a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::release </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When held in exclusive mode this method releases the Synchronizer. </p>
<p>This method calls <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aa937ba519e25658dd38e834a72bde802" title="Performs a release for the calling thread in exclusive mode.">tryRelease(int)</a> and if one or more threads is unblocked it returns true. This method forms the basis of <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html#a7342edc9e65c3983e2fb35ccb36c0ae6" title="Releases the lock.">Lock.unlock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A value used to release, it is passed to tryRelease and not interpreted by this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result that is returned from a call to <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#aa937ba519e25658dd38e834a72bde802" title="Performs a release for the calling thread in exclusive mode.">tryRelease(int)</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa94cc4031257aefc3dc8d2d13477d277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::releaseShared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When held in shared mode this method releases the Synchronizer. </p>
<p>This method calls <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a755ce96c4ffbbad9e288292766d00a67" title="Performs a release for the calling thread in shared mode.">tryReleaseShared(int)</a> and if one or more threads is unblocked it returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A value used to release, it is passed to tryReleaseShared and not interpreted by this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result that is returned from a call to <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a755ce96c4ffbbad9e288292766d00a67" title="Performs a release for the calling thread in shared mode.">tryReleaseShared(int)</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c3e1da0ada25fd02832d99f2c162c60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::util::concurrent::locks::AbstractQueuedSynchronizer::setState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the synchronization state to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new value to assign to the synchronization state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72e5b69fe58d2741675024f98092af00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string decaf::util::concurrent::locks::AbstractQueuedSynchronizer::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string that identifies this Synchronizer along with its present state. </p>
<p>The string contains the state in a bracketed form that contains "State =" and the result of <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a26737c6f333a5279cd168935376711ab" title="Gets and returns the currently set value of this object Synchronization sate.">getState()</a> and also contains the indicators "nonempty" or "empty" based on whether the thread queue is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd>a string value that identifies this <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html">AbstractQueuedSynchronizer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a6970a8a9eda013b318acd16180056d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::tryAcquire </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the actual work of attempting to acquire the lock in exclusive mode. </p>
<p>The implementation should acquire the lock in exclusive mode based on its current state or the capabilities of the lock being implemented.</p>
<p>Whenever a thread calls acquire this method is invoked. If the method fails then the acquire method can decide to block the calling thread until signaled that another attempt to acquire should be made.</p>
<p>The default implementation always throws UnsupportedOperationException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value passed to the acquire method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the acquire succeeded, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the acquire places the object in an invalid state. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if exclusive mode is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc3e1b653ca760c9a386cac0d3c1811b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::tryAcquireNanos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires in exclusive mode if possible, first checking if the calling thread has already been interrupted or not, then calling <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a2a6970a8a9eda013b318acd16180056d" title="Performs the actual work of attempting to acquire the lock in exclusive mode.">tryAcquire(int)</a> at least one time and possibly more up to the given timeout, or until the calling thread is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Value to be passed to <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#a2a6970a8a9eda013b318acd16180056d" title="Performs the actual work of attempting to acquire the lock in exclusive mode.">tryAcquire(int)</a> its meaning is uninterpreted here. </td></tr>
    <tr><td class="paramname">nanos</td><td>Time in nanoseconds to wait before reporting the acquisition as failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the acquire succeeded, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the calling thread is interrupted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac087783c351650e3160c6bf4274ba1d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::util::concurrent::locks::AbstractQueuedSynchronizer::tryAcquireShared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the actual work of attempting to acquire the lock in shared mode. </p>
<p>The implementation should acquire the lock in exclusive mode based on its current state or the capabilities of the lock being implemented.</p>
<p>Whenever a thread calls acquire this method is invoked. If the method fails then the acquire method can decide to block the calling thread until signaled that another attempt to acquire should be made.</p>
<p>The default implementation always throws UnsupportedOperationException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value passed to the acquire method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a negative value if the acquire failed, zero if it did succeed but no additional shared mode acquires can, or a positive number if success and future calls amy also succeed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the acquire places the object in an invalid state. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if shared mode is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3d43f436738bfeec6ce66e54b9eeece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::tryAcquireSharedNanos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires in shared mode if possible, first checking if the calling thread has already been interrupted or not, then calling <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ac087783c351650e3160c6bf4274ba1d1" title="Performs the actual work of attempting to acquire the lock in shared mode.">tryAcquireShared(int)</a> at least one time and possibly more up to the given timeout, or until the calling thread is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Value to be passed to <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html#ac087783c351650e3160c6bf4274ba1d1" title="Performs the actual work of attempting to acquire the lock in shared mode.">tryAcquireShared(int)</a> its meaning is uninterpreted here. </td></tr>
    <tr><td class="paramname">nanos</td><td>Time in nanoseconds to wait before reporting the acquisition as failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the acquire succeeded, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the calling thread is interrupted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa937ba519e25658dd38e834a72bde802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::tryRelease </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a release for the calling thread in exclusive mode. </p>
<p>For any thread that performs a release this method will always be invoked.</p>
<p>The default implementation always throws UnsupportedOperationException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value that was passed to the release method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the synchronization is now fully released such that waiting threads can now attempt to acquire it, false if not fully released.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the release places the object in an invalid state. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if exclusive mode is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a755ce96c4ffbbad9e288292766d00a67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::util::concurrent::locks::AbstractQueuedSynchronizer::tryReleaseShared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a release for the calling thread in shared mode. </p>
<p>For any thread that performs a release this method will always be invoked.</p>
<p>The default implementation always throws UnsupportedOperationException.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The value that was passed to the release method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the synchronization is now fully released such that waiting threads can now attempt to acquire it, false if not fully released.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the release places the object in an invalid state. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if shared mode is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="abbdec5d3f61a150d2b4d6735836e8a71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SynchronizerState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/locks/<a class="el" href="_abstract_queued_synchronizer_8h_source.html">AbstractQueuedSynchronizer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent_1_1locks.html">locks</a></li><li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html">AbstractQueuedSynchronizer</a></li>
    <li class="footer">Generated on Mon Mar 4 2013 10:25:52 for activemq-cpp-3.6.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
