<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>activemq-cpp-3.6.0: decaf::util::BitSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.6.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1util_1_1_bit_set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">decaf::util::BitSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a vector of bits that grows as needed.  
 <a href="classdecaf_1_1util_1_1_bit_set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_bit_set_8h_source.html">src/main/decaf/util/BitSet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fdd63a411f90f760b00fc2284cdd996"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a5fdd63a411f90f760b00fc2284cdd996">BitSet</a> ()</td></tr>
<tr class="memdesc:a5fdd63a411f90f760b00fc2284cdd996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> whose bits are all false.  <a href="#a5fdd63a411f90f760b00fc2284cdd996"></a><br/></td></tr>
<tr class="memitem:ab33df8cdcef76806158ec1b8bdaf2814"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#ab33df8cdcef76806158ec1b8bdaf2814">BitSet</a> (int bitCount)</td></tr>
<tr class="memdesc:ab33df8cdcef76806158ec1b8bdaf2814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range 0 through bitCount-1.  <a href="#ab33df8cdcef76806158ec1b8bdaf2814"></a><br/></td></tr>
<tr class="memitem:af2dbb1c9dc86d97ae3fbc6531245f6e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#af2dbb1c9dc86d97ae3fbc6531245f6e9">BitSet</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>)</td></tr>
<tr class="memdesc:af2dbb1c9dc86d97ae3fbc6531245f6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#af2dbb1c9dc86d97ae3fbc6531245f6e9"></a><br/></td></tr>
<tr class="memitem:a0c383a779598ce49d576889e7b2ae19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a0c383a779598ce49d576889e7b2ae19f">operator=</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>)</td></tr>
<tr class="memdesc:a0c383a779598ce49d576889e7b2ae19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="#a0c383a779598ce49d576889e7b2ae19f"></a><br/></td></tr>
<tr class="memitem:ab363da8c7d2828dafed33971f5d727e1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#ab363da8c7d2828dafed33971f5d727e1">~BitSet</a> ()</td></tr>
<tr class="memitem:af2284aff6aa0bc6d2fa3b348cf3cd7c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#af2284aff6aa0bc6d2fa3b348cf3cd7c4">AND</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>)</td></tr>
<tr class="memdesc:af2284aff6aa0bc6d2fa3b348cf3cd7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a logical AND of this target bit set with the argument bit set.  <a href="#af2284aff6aa0bc6d2fa3b348cf3cd7c4"></a><br/></td></tr>
<tr class="memitem:ab5d03ba5547a08ccce3b6f3c5a3273ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#ab5d03ba5547a08ccce3b6f3c5a3273ea">OR</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>)</td></tr>
<tr class="memdesc:ab5d03ba5547a08ccce3b6f3c5a3273ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a logical OR of this bit set with the bit set argument.  <a href="#ab5d03ba5547a08ccce3b6f3c5a3273ea"></a><br/></td></tr>
<tr class="memitem:aeb7135a97e5b42f0e6dc3ab856870417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#aeb7135a97e5b42f0e6dc3ab856870417">andNot</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>)</td></tr>
<tr class="memdesc:aeb7135a97e5b42f0e6dc3ab856870417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all of the bits in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> whose corresponding bit is set in the specified <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>.  <a href="#aeb7135a97e5b42f0e6dc3ab856870417"></a><br/></td></tr>
<tr class="memitem:a5d5fd8a44a64c0c8e3c117befff4bb38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a5d5fd8a44a64c0c8e3c117befff4bb38">cardinality</a> ()</td></tr>
<tr class="memdesc:a5d5fd8a44a64c0c8e3c117befff4bb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits set to true in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>.  <a href="#a5d5fd8a44a64c0c8e3c117befff4bb38"></a><br/></td></tr>
<tr class="memitem:a42e79d0ee8b77863a9b0dbababca6428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a42e79d0ee8b77863a9b0dbababca6428">clear</a> ()</td></tr>
<tr class="memdesc:a42e79d0ee8b77863a9b0dbababca6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all of the bits in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to false.  <a href="#a42e79d0ee8b77863a9b0dbababca6428"></a><br/></td></tr>
<tr class="memitem:aca9eb068d2f4c9b818fe10bad4740c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#aca9eb068d2f4c9b818fe10bad4740c3b">clear</a> (int index)</td></tr>
<tr class="memdesc:aca9eb068d2f4c9b818fe10bad4740c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit specified by the index to false.  <a href="#aca9eb068d2f4c9b818fe10bad4740c3b"></a><br/></td></tr>
<tr class="memitem:adef0dafb9dcaa98213f066bb0779cd20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#adef0dafb9dcaa98213f066bb0779cd20">clear</a> (int fromIndex, int toIndex)</td></tr>
<tr class="memdesc:adef0dafb9dcaa98213f066bb0779cd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to false.  <a href="#adef0dafb9dcaa98213f066bb0779cd20"></a><br/></td></tr>
<tr class="memitem:a6a9a3e62415075b8101e6fb35d9b328f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a6a9a3e62415075b8101e6fb35d9b328f">equals</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a6a9a3e62415075b8101e6fb35d9b328f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this object against the specified object.  <a href="#a6a9a3e62415075b8101e6fb35d9b328f"></a><br/></td></tr>
<tr class="memitem:afa7b5b3264cc628d85eb07c273553c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#afa7b5b3264cc628d85eb07c273553c34">flip</a> (int index)</td></tr>
<tr class="memdesc:afa7b5b3264cc628d85eb07c273553c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit at the specified index to the complement of its current value.  <a href="#afa7b5b3264cc628d85eb07c273553c34"></a><br/></td></tr>
<tr class="memitem:a99e9afa76f5ea283370470ae11f3b4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a99e9afa76f5ea283370470ae11f3b4a3">flip</a> (int fromIndex, int toIndex)</td></tr>
<tr class="memdesc:a99e9afa76f5ea283370470ae11f3b4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each bit from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to the complement of its current value.  <a href="#a99e9afa76f5ea283370470ae11f3b4a3"></a><br/></td></tr>
<tr class="memitem:a2d20826160359e94c1884cba722905bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a2d20826160359e94c1884cba722905bf">get</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2d20826160359e94c1884cba722905bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the bit with the specified index.  <a href="#a2d20826160359e94c1884cba722905bf"></a><br/></td></tr>
<tr class="memitem:a2ad07d36234dfcc4bdac4bc3d16c917e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a2ad07d36234dfcc4bdac4bc3d16c917e">get</a> (int fromIndex, int toIndex) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2ad07d36234dfcc4bdac4bc3d16c917e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> composed of bits from this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> from fromIndex (inclusive) to toIndex (exclusive).  <a href="#a2ad07d36234dfcc4bdac4bc3d16c917e"></a><br/></td></tr>
<tr class="memitem:a57e5f0340f2f086cca28f3d2ac0cde93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a57e5f0340f2f086cca28f3d2ac0cde93">intersects</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a57e5f0340f2f086cca28f3d2ac0cde93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> has any bits set to true that are also set to true in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>.  <a href="#a57e5f0340f2f086cca28f3d2ac0cde93"></a><br/></td></tr>
<tr class="memitem:a0c9c61c56b3d17bbf9b05183193e7e5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a0c9c61c56b3d17bbf9b05183193e7e5b">isEmpty</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a0c9c61c56b3d17bbf9b05183193e7e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> contains no bits that are set to true.  <a href="#a0c9c61c56b3d17bbf9b05183193e7e5b"></a><br/></td></tr>
<tr class="memitem:ad9fee2c12e8c5a86646e79bb93376847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#ad9fee2c12e8c5a86646e79bb93376847">length</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ad9fee2c12e8c5a86646e79bb93376847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "logical size" of this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>: the index of the highest set bit in the <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> plus one.  <a href="#ad9fee2c12e8c5a86646e79bb93376847"></a><br/></td></tr>
<tr class="memitem:af448fac800d459e2c196e7249d5103f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#af448fac800d459e2c196e7249d5103f2">nextClearBit</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:af448fac800d459e2c196e7249d5103f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first bit that is set to false that occurs on or after the specified starting index.  <a href="#af448fac800d459e2c196e7249d5103f2"></a><br/></td></tr>
<tr class="memitem:acc95d3f485237e2b5504f0d25b768388"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#acc95d3f485237e2b5504f0d25b768388">nextSetBit</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:acc95d3f485237e2b5504f0d25b768388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first bit that is set to true that occurs on or after the specified starting index.  <a href="#acc95d3f485237e2b5504f0d25b768388"></a><br/></td></tr>
<tr class="memitem:a3ff5eb26ddc487b1c7065ca4bc30d742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a> (int index)</td></tr>
<tr class="memdesc:a3ff5eb26ddc487b1c7065ca4bc30d742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit at the specified index to true.  <a href="#a3ff5eb26ddc487b1c7065ca4bc30d742"></a><br/></td></tr>
<tr class="memitem:a2d6354cf81ff5cade48126f7739bd1be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a2d6354cf81ff5cade48126f7739bd1be">set</a> (int index, bool value)</td></tr>
<tr class="memdesc:a2d6354cf81ff5cade48126f7739bd1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit at the specified index to the specified value.  <a href="#a2d6354cf81ff5cade48126f7739bd1be"></a><br/></td></tr>
<tr class="memitem:a18d297e722c1337c2e1f1bbfb51e0e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a18d297e722c1337c2e1f1bbfb51e0e73">set</a> (int fromIndex, int toIndex)</td></tr>
<tr class="memdesc:a18d297e722c1337c2e1f1bbfb51e0e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to true.  <a href="#a18d297e722c1337c2e1f1bbfb51e0e73"></a><br/></td></tr>
<tr class="memitem:a7b0fbede76f5b9adca7df3b514009cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a7b0fbede76f5b9adca7df3b514009cd6">set</a> (int fromIndex, int toIndex, bool value)</td></tr>
<tr class="memdesc:a7b0fbede76f5b9adca7df3b514009cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to the value given.  <a href="#a7b0fbede76f5b9adca7df3b514009cd6"></a><br/></td></tr>
<tr class="memitem:a8c8288cb2aee644206d14e3693fe73e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a8c8288cb2aee644206d14e3693fe73e7">size</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a8c8288cb2aee644206d14e3693fe73e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits of space actually in use by this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to represent bit values.  <a href="#a8c8288cb2aee644206d14e3693fe73e7"></a><br/></td></tr>
<tr class="memitem:ac2e469bf4ae574ffbfd5d9bfe8440885"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#ac2e469bf4ae574ffbfd5d9bfe8440885">toString</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ac2e469bf4ae574ffbfd5d9bfe8440885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this bit set.  <a href="#ac2e469bf4ae574ffbfd5d9bfe8440885"></a><br/></td></tr>
<tr class="memitem:a19c0169a052abada2f9fc0683a576b66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a19c0169a052abada2f9fc0683a576b66">XOR</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;<a class="el" href="classdecaf_1_1util_1_1_bit_set.html#a3ff5eb26ddc487b1c7065ca4bc30d742">set</a>)</td></tr>
<tr class="memdesc:a19c0169a052abada2f9fc0683a576b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a logical XOR of this bit set with the bit set argument.  <a href="#a19c0169a052abada2f9fc0683a576b66"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class implements a vector of bits that grows as needed. </p>
<p>Each component of the bit set has a boolean value. The bits of a <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> are indexed by nonnegative integers. Individual indexed bits can be examined, set, or cleared. One <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> may be used to modify the contents of another <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> through logical AND, logical inclusive OR, and logical exclusive OR operations.</p>
<p>By default, all bits in the set initially have the value false.</p>
<p>Every bit set has a current size, which is the number of bits of space currently in use by the bit set. Note that the size is related to the implementation of a bit set, so it may change with implementation. The length of a bit set relates to logical length of a bit set and is defined independently of implementation.</p>
<p>A <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> is not safe for multi-threaded use without external synchronization.</p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fdd63a411f90f760b00fc2284cdd996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::BitSet::BitSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> whose bits are all false. </p>

</div>
</div>
<a class="anchor" id="ab33df8cdcef76806158ec1b8bdaf2814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::BitSet::BitSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range 0 through bitCount-1. </p>
<p>All bits are initially false. If the bitCount is not a multiple of 64 then the count is rounded to the next closest multiple of 64.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> should hold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NegativeArraySizeException</td><td>if bitCount is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2dbb1c9dc86d97ae3fbc6531245f6e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::BitSet::BitSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor. </p>

</div>
</div>
<a class="anchor" id="ab363da8c7d2828dafed33971f5d727e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::util::BitSet::~BitSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="af2284aff6aa0bc6d2fa3b348cf3cd7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::AND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a logical AND of this target bit set with the argument bit set. </p>
<p>This bit set is modified so that each bit in it has the value true if and only if it both initially had the value true and the corresponding bit in the bit set argument also had the value true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to perform this action against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb7135a97e5b42f0e6dc3ab856870417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::andNot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all of the bits in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> whose corresponding bit is set in the specified <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to perform this action against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d5fd8a44a64c0c8e3c117befff4bb38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::BitSet::cardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits set to true in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bits set to true in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a42e79d0ee8b77863a9b0dbababca6428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all of the bits in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to false. </p>

</div>
</div>
<a class="anchor" id="aca9eb068d2f4c9b818fe10bad4740c3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::clear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bit specified by the index to false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the bit whose value is to be set to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adef0dafb9dcaa98213f066bb0779cd20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::clear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromIndex</td><td>The index (inclusive) to start setting bits to false. </td></tr>
    <tr><td class="paramname">toIndex</td><td>The index (exclusive) to stop setting bits to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if fromIndex is negative, or toIndex is negative, or fromIndex is larger than toIndex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a9a3e62415075b8101e6fb35d9b328f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::BitSet::equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this object against the specified object. </p>
<p>The result is true if and only if is a Bitset object that has exactly the same set of bits set to true as this bit set. That is, for every nonnegative int index k,</p>
<p>set.get(k) == this-&gt;get(k)</p>
<p>must be true. The current sizes of the two bit sets are not compared.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the sets are the same, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afa7b5b3264cc628d85eb07c273553c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::flip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bit at the specified index to the complement of its current value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the bit whose value is to be set to its compliment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99e9afa76f5ea283370470ae11f3b4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::flip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets each bit from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to the complement of its current value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromIndex</td><td>The index (inclusive) to start setting bits to its compliment. </td></tr>
    <tr><td class="paramname">toIndex</td><td>The index (exclusive) to stop setting bits to its compliment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if fromIndex is negative, or toIndex is negative, or fromIndex is larger than toIndex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d20826160359e94c1884cba722905bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::BitSet::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the bit with the specified index. </p>
<p>The value is true if the bit with the given index is currently set in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>; otherwise, the result is false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the bit in question.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the bit with the specified index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ad07d36234dfcc4bdac4bc3d16c917e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> decaf::util::BitSet::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> composed of bits from this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> from fromIndex (inclusive) to toIndex (exclusive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromIndex</td><td>The index (inclusive) to start at. </td></tr>
    <tr><td class="paramname">toIndex</td><td>The index (exclusive) to stop at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> containing the specified values.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if fromIndex is negative, or toIndex is negative, or fromIndex is larger than toIndex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57e5f0340f2f086cca28f3d2ac0cde93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::BitSet::intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> has any bits set to true that are also set to true in this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td><a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to intersect with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean indicating whether this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> intersects the specified <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c9c61c56b3d17bbf9b05183193e7e5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::BitSet::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> contains no bits that are set to true. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the set is empty, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9fee2c12e8c5a86646e79bb93376847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::BitSet::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the "logical size" of this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>: the index of the highest set bit in the <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> plus one. </p>
<p>Returns zero if the <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> contains no set bits.</p>
<dl class="section return"><dt>Returns</dt><dd>the logical size of the <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af448fac800d459e2c196e7249d5103f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::BitSet::nextClearBit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the first bit that is set to false that occurs on or after the specified starting index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to start the search from (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the next clear bit.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc95d3f485237e2b5504f0d25b768388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::BitSet::nextSetBit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the first bit that is set to true that occurs on or after the specified starting index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to start the search from (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the next set bit.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c383a779598ce49d576889e7b2ae19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a>&amp; decaf::util::BitSet::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment. </p>

</div>
</div>
<a class="anchor" id="ab5d03ba5547a08ccce3b6f3c5a3273ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::OR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a logical OR of this bit set with the bit set argument. </p>
<p>This bit set is modified so that a bit in it has the value true if and only if it either already had the value true or the corresponding bit in the bit set argument has the value true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to perform this action against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ff5eb26ddc487b1c7065ca4bc30d742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bit at the specified index to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to set to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d6354cf81ff5cade48126f7739bd1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bit at the specified index to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to set. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the given bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18d297e722c1337c2e1f1bbfb51e0e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromIndex</td><td>The index (inclusive) to start at. </td></tr>
    <tr><td class="paramname">toIndex</td><td>The index (exclusive) to stop at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if fromIndex is negative, or toIndex is negative, or fromIndex is larger than toIndex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b0fbede76f5b9adca7df3b514009cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to the value given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromIndex</td><td>The index (inclusive) to start at. </td></tr>
    <tr><td class="paramname">toIndex</td><td>The index (exclusive) to stop at. </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value to assign to the target bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if fromIndex is negative, or toIndex is negative, or fromIndex is larger than toIndex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c8288cb2aee644206d14e3693fe73e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::BitSet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits of space actually in use by this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to represent bit values. </p>
<p>The maximum element in the set is the size - 1st element.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of bits currently in this bit set. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2e469bf4ae574ffbfd5d9bfe8440885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string decaf::util::BitSet::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of this bit set. </p>
<p>For every index for which this <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> contains a bit in the set state, the decimal representation of that index is included in the result. Such indices are listed in order from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual mathematical notation for a set of integers.</p>
<dl class="section return"><dt>Returns</dt><dd>string representation of the <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a19c0169a052abada2f9fc0683a576b66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::BitSet::XOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a logical XOR of this bit set with the bit set argument. </p>
<p>This bit set is modified so that a bit in it has the value true if and only if one of the following statements holds:</p>
<ul>
<li>The bit initially has the value true, and the corresponding bit in the argument has the value false.</li>
<li>The bit initially has the value false, and the corresponding bit in the argument has the value true.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The <a class="el" href="classdecaf_1_1util_1_1_bit_set.html" title="This class implements a vector of bits that grows as needed.">BitSet</a> to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/<a class="el" href="_bit_set_8h_source.html">BitSet.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classdecaf_1_1util_1_1_bit_set.html">BitSet</a></li>
    <li class="footer">Generated on Mon Mar 4 2013 10:25:51 for activemq-cpp-3.6.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
