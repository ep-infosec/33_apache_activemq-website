<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>activemq-cpp-3.6.0: decaf::internal::nio::CharArrayBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.6.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">decaf::internal::nio::CharArrayBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_char_array_buffer_8h_source.html">src/main/decaf/internal/nio/CharArrayBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::internal::nio::CharArrayBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer__inherit__graph.png" border="0" usemap="#decaf_1_1internal_1_1nio_1_1_char_array_buffer_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1internal_1_1nio_1_1_char_array_buffer_inherit__map" id="decaf_1_1internal_1_1nio_1_1_char_array_buffer_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:" alt="" coords="231,81,372,109"/><area shape="rect" id="node4" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type." alt="" coords="36,5,151,33"/><area shape="rect" id="node6" href="classdecaf_1_1lang_1_1_char_sequence.html" title="A CharSequence is a readable sequence of char values." alt="" coords="7,55,180,83"/><area shape="rect" id="node8" href="classdecaf_1_1lang_1_1_appendable.html" title="An object to which char sequences and values can be appended." alt="" coords="15,106,172,134"/><area shape="rect" id="node10" href="classdecaf_1_1lang_1_1_comparable.html" title="decaf::lang::Comparable\l\&lt; CharBuffer \&gt;" alt="" coords="15,157,172,201"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02363d5242435b69f8ca8e71abd585ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a02363d5242435b69f8ca8e71abd585ac">CharArrayBuffer</a> (int size, bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a>=false)</td></tr>
<tr class="memdesc:a02363d5242435b69f8ca8e71abd585ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted.  <a href="#a02363d5242435b69f8ca8e71abd585ac"></a><br/></td></tr>
<tr class="memitem:acf23117e4d795a2ca00a2a2da479581a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#acf23117e4d795a2ca00a2a2da479581a">CharArrayBuffer</a> (char *<a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a2a962ba127c31943dd075327142a8402">array</a>, int size, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">offset</a>, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">length</a>, bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a>=false)</td></tr>
<tr class="memdesc:acf23117e4d795a2ca00a2a2da479581a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that wraps the given array.  <a href="#acf23117e4d795a2ca00a2a2da479581a"></a><br/></td></tr>
<tr class="memitem:ab4a28845aa83dfe9c2c9e802006d47a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ab4a28845aa83dfe9c2c9e802006d47a8">CharArrayBuffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt; &amp;<a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a2a962ba127c31943dd075327142a8402">array</a>, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">offset</a>, int <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">length</a>, bool <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a>=false)</td></tr>
<tr class="memdesc:ab4a28845aa83dfe9c2c9e802006d47a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte buffer that wraps the passed ByteArrayAdapter and start at the given offset.  <a href="#ab4a28845aa83dfe9c2c9e802006d47a8"></a><br/></td></tr>
<tr class="memitem:a0e751518499478ef5da9ec29d8eea337"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a0e751518499478ef5da9ec29d8eea337">CharArrayBuffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:a0e751518499478ef5da9ec29d8eea337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> that mirrors this one, meaning it shares a reference to this buffers ByteArrayAdapter and when changes are made to that data it is reflected in both.  <a href="#a0e751518499478ef5da9ec29d8eea337"></a><br/></td></tr>
<tr class="memitem:a780a85507dbdf2259d1acd7e5aadf1bd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a780a85507dbdf2259d1acd7e5aadf1bd">~CharArrayBuffer</a> ()</td></tr>
<tr class="memitem:a2a962ba127c31943dd075327142a8402"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a2a962ba127c31943dd075327142a8402">array</a> ()</td></tr>
<tr class="memdesc:a2a962ba127c31943dd075327142a8402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character array that backs this buffer (optional operation).Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="section return"><dt>Returns</dt><dd>the array that backs this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a2a962ba127c31943dd075327142a8402"></a><br/></td></tr>
<tr class="memitem:ae6dabe5e2cc564bfe8a38de3f057ab3b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ae6dabe5e2cc564bfe8a38de3f057ab3b">arrayOffset</a> ()</td></tr>
<tr class="memdesc:ae6dabe5e2cc564bfe8a38de3f057ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing array of the first element of the buffer (optional operation).Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="section return"><dt>Returns</dt><dd>The offset into the backing array where index zero starts.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ae6dabe5e2cc564bfe8a38de3f057ab3b"></a><br/></td></tr>
<tr class="memitem:a9ac96e6fac08527174b0702cab373a39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a9ac96e6fac08527174b0702cab373a39">asReadOnlyBuffer</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a9ac96e6fac08527174b0702cab373a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, read-only char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.<dl class="section return"><dt>Returns</dt><dd>The new, read-only char buffer which the caller then owns.</dd></dl>
  <a href="#a9ac96e6fac08527174b0702cab373a39"></a><br/></td></tr>
<tr class="memitem:a69d68ff242c2619d90782d287206cfb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a69d68ff242c2619d90782d287206cfb3">compact</a> ()</td></tr>
<tr class="memdesc:a69d68ff242c2619d90782d287206cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts this buffer.The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.<dl class="section return"><dt>Returns</dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>- If this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a69d68ff242c2619d90782d287206cfb3"></a><br/></td></tr>
<tr class="memitem:acf2117fe9c621d2569aa6bf5880bdf8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#acf2117fe9c621d2569aa6bf5880bdf8d">duplicate</a> ()</td></tr>
<tr class="memdesc:acf2117fe9c621d2569aa6bf5880bdf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="section return"><dt>Returns</dt><dd>a new char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns.</dd></dl>
  <a href="#acf2117fe9c621d2569aa6bf5880bdf8d"></a><br/></td></tr>
<tr class="memitem:a22a5f51cf8da460d264e91afaad64813"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a22a5f51cf8da460d264e91afaad64813">get</a> ()</td></tr>
<tr class="memdesc:a22a5f51cf8da460d264e91afaad64813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative get method.Reads the character at this buffer's current position, and then increments the position.<dl class="section return"><dt>Returns</dt><dd>the char at the current position.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there no more data to return</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a22a5f51cf8da460d264e91afaad64813"></a><br/></td></tr>
<tr class="memitem:a5da481d2f474ac00496f458abf719fea"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a5da481d2f474ac00496f458abf719fea">get</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a5da481d2f474ac00496f458abf719fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.Reads the char at the given index.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the char is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the char that is located at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit or is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a5da481d2f474ac00496f458abf719fea"></a><br/></td></tr>
<tr class="memitem:a9e39462b5ed584c2556b686fd3c5e830"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a9e39462b5ed584c2556b686fd3c5e830">hasArray</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a9e39462b5ed584c2556b686fd3c5e830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is backed by an accessible char array.If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.<dl class="section return"><dt>Returns</dt><dd>true if, and only if, this buffer is backed by an array and is not read-only</dd></dl>
  <a href="#a9e39462b5ed584c2556b686fd3c5e830"></a><br/></td></tr>
<tr class="memitem:a479f8f91fa141921980f2002e1ca39f6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a479f8f91fa141921980f2002e1ca39f6">isReadOnly</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a479f8f91fa141921980f2002e1ca39f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is read-only.<dl class="section return"><dt>Returns</dt><dd>true if, and only if, this buffer is read-only.</dd></dl>
  <a href="#a479f8f91fa141921980f2002e1ca39f6"></a><br/></td></tr>
<tr class="memitem:ac7000bacc913fbd14e1c957f80ec9b14"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac7000bacc913fbd14e1c957f80ec9b14">put</a> (char value)</td></tr>
<tr class="memdesc:ac7000bacc913fbd14e1c957f80ec9b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given char into this buffer at the current position, and then increments the position.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ac7000bacc913fbd14e1c957f80ec9b14"></a><br/></td></tr>
<tr class="memitem:ad2d2a97ee0cd5061f7eb428f8238821c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ad2d2a97ee0cd5061f7eb428f8238821c">put</a> (int index, char value)</td></tr>
<tr class="memdesc:ad2d2a97ee0cd5061f7eb428f8238821c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given char into this buffer at the given index.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The char to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ad2d2a97ee0cd5061f7eb428f8238821c"></a><br/></td></tr>
<tr class="memitem:a50e69c403797e5d6e0c3491f0e34a8a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a50e69c403797e5d6e0c3491f0e34a8a4">slice</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a50e69c403797e5d6e0c3491f0e34a8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> whose content is a shared subsequence of this buffer's content.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="section return"><dt>Returns</dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> which the caller owns.</dd></dl>
  <a href="#a50e69c403797e5d6e0c3491f0e34a8a4"></a><br/></td></tr>
<tr class="memitem:aeb7ba1e4d009af1a76ba212f8fdc2dd3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#aeb7ba1e4d009af1a76ba212f8fdc2dd3">subSequence</a> (int start, int end) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:aeb7ba1e4d009af1a76ba212f8fdc2dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position.The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + start, and its limit will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + end. The new <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> will be read-only if, and only if, this buffer is read-only.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index, relative to the current position, of the first character in the subsequence; must be non-negative and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>. </td></tr>
    <tr><td class="paramname">end</td><td>The index, relative to the current position, of the character following the last character in the subsequence; must be no smaller than start and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new character buffer, caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions on start and end fail.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aeb7ba1e4d009af1a76ba212f8fdc2dd3"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1nio_1_1_char_buffer')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a></td></tr>
<tr class="memitem:a5417d463b730a98746e5fa2da86c4717 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a5417d463b730a98746e5fa2da86c4717">~CharBuffer</a> ()</td></tr>
<tr class="memitem:ac9d893569151fc3df6be047c56773a5a inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ac9d893569151fc3df6be047c56773a5a">toString</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a111e96c79e42a1819a6351cdb81b5eee inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a111e96c79e42a1819a6351cdb81b5eee">append</a> (char value)</td></tr>
<tr class="memdesc:a111e96c79e42a1819a6351cdb81b5eee inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the specified character to this buffer.  <a href="#a111e96c79e42a1819a6351cdb81b5eee"></a><br/></td></tr>
<tr class="memitem:a64a84931af4b394bc630a55f111e6e28 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a64a84931af4b394bc630a55f111e6e28">append</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *value)</td></tr>
<tr class="memdesc:a64a84931af4b394bc630a55f111e6e28 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the specified character sequence to this buffer.  <a href="#a64a84931af4b394bc630a55f111e6e28"></a><br/></td></tr>
<tr class="memitem:a7fe67a6a2ea5e27ef74067d4699805e8 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a7fe67a6a2ea5e27ef74067d4699805e8">append</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *value, int start, int end)</td></tr>
<tr class="memdesc:a7fe67a6a2ea5e27ef74067d4699805e8 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a subsequence of the specified character sequence to this buffer If value is Null the the string "null" is appended to the buffer.  <a href="#a7fe67a6a2ea5e27ef74067d4699805e8"></a><br/></td></tr>
<tr class="memitem:a25eec827719157c32a4310e2694c6fc9 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a25eec827719157c32a4310e2694c6fc9">charAt</a> (int index) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a25eec827719157c32a4310e2694c6fc9 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the character at the given index relative to the current position.  <a href="#a25eec827719157c32a4310e2694c6fc9"></a><br/></td></tr>
<tr class="memitem:a232c547933fb2bffdcdeeeeeda72a75d inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a232c547933fb2bffdcdeeeeeda72a75d">get</a> (std::vector&lt; char &gt; buffer)</td></tr>
<tr class="memdesc:a232c547933fb2bffdcdeeeeeda72a75d inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk get method.  <a href="#a232c547933fb2bffdcdeeeeeda72a75d"></a><br/></td></tr>
<tr class="memitem:ab5897935ac46197fe85afb7a9643adde inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab5897935ac46197fe85afb7a9643adde">get</a> (char *buffer, int size, int offset, int <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab4c525f4eca223186eee72767c30e02f">length</a>)</td></tr>
<tr class="memdesc:ab5897935ac46197fe85afb7a9643adde inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk get method.  <a href="#ab5897935ac46197fe85afb7a9643adde"></a><br/></td></tr>
<tr class="memitem:ab4c525f4eca223186eee72767c30e02f inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab4c525f4eca223186eee72767c30e02f">length</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ab4c525f4eca223186eee72767c30e02f inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of this character buffer.  <a href="#ab4c525f4eca223186eee72767c30e02f"></a><br/></td></tr>
<tr class="memitem:a755c004daca91a64eef4120d786adc03 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a755c004daca91a64eef4120d786adc03">put</a> (<a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;src)</td></tr>
<tr class="memdesc:a755c004daca91a64eef4120d786adc03 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers the chars remaining in the given source buffer into this buffer.  <a href="#a755c004daca91a64eef4120d786adc03"></a><br/></td></tr>
<tr class="memitem:a789aa4ed5e347bf213d8ddc560a5a1d4 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a789aa4ed5e347bf213d8ddc560a5a1d4">put</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *buffer, int size, int offset, int <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab4c525f4eca223186eee72767c30e02f">length</a>)</td></tr>
<tr class="memdesc:a789aa4ed5e347bf213d8ddc560a5a1d4 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers chars into this buffer from the given source array.  <a href="#a789aa4ed5e347bf213d8ddc560a5a1d4"></a><br/></td></tr>
<tr class="memitem:a14ea79cd111419462580db32249ee6f8 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a14ea79cd111419462580db32249ee6f8">put</a> (std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a14ea79cd111419462580db32249ee6f8 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers the entire content of the given source char array into this buffer.  <a href="#a14ea79cd111419462580db32249ee6f8"></a><br/></td></tr>
<tr class="memitem:a8c2a830221dc44a26c15eb9ec4c835fc inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a8c2a830221dc44a26c15eb9ec4c835fc">put</a> (std::string &amp;src, int start, int end)</td></tr>
<tr class="memdesc:a8c2a830221dc44a26c15eb9ec4c835fc inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk put method (optional operation).  <a href="#a8c2a830221dc44a26c15eb9ec4c835fc"></a><br/></td></tr>
<tr class="memitem:a825cd6d51ea13a6380aa837e00709e95 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a825cd6d51ea13a6380aa837e00709e95">put</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;src)</td></tr>
<tr class="memdesc:a825cd6d51ea13a6380aa837e00709e95 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk put method (optional operation).  <a href="#a825cd6d51ea13a6380aa837e00709e95"></a><br/></td></tr>
<tr class="memitem:ae78624aa928094734a1df4df0255003e inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ae78624aa928094734a1df4df0255003e">read</a> (<a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *target)</td></tr>
<tr class="memdesc:ae78624aa928094734a1df4df0255003e inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read characters into the specified character buffer.  <a href="#ae78624aa928094734a1df4df0255003e"></a><br/></td></tr>
<tr class="memitem:a59a398415926d78da8c8bed0da9ec587 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a59a398415926d78da8c8bed0da9ec587">compareTo</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a59a398415926d78da8c8bed0da9ec587 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a59a398415926d78da8c8bed0da9ec587"></a><br/></td></tr>
<tr class="memitem:a52d8a0a7fbbf147c75046dc55589a183 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a52d8a0a7fbbf147c75046dc55589a183">equals</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a52d8a0a7fbbf147c75046dc55589a183 inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a52d8a0a7fbbf147c75046dc55589a183"></a><br/></td></tr>
<tr class="memitem:a3425d642d79f2a677748a966e6cb690b inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a3425d642d79f2a677748a966e6cb690b">operator==</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a3425d642d79f2a677748a966e6cb690b inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a3425d642d79f2a677748a966e6cb690b"></a><br/></td></tr>
<tr class="memitem:abc095d9943bcfe41bac7a3fe45cdc9da inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#abc095d9943bcfe41bac7a3fe45cdc9da">operator&lt;</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:abc095d9943bcfe41bac7a3fe45cdc9da inherit pub_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#abc095d9943bcfe41bac7a3fe45cdc9da"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1nio_1_1_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1nio_1_1_buffer')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">decaf::nio::Buffer</a></td></tr>
<tr class="memitem:a8fcaea1822345689b015e19515b93b05 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a8fcaea1822345689b015e19515b93b05">Buffer</a> (int capactiy)</td></tr>
<tr class="memitem:a520c62546b6042aacaa0d50e271bca06 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a520c62546b6042aacaa0d50e271bca06">Buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;other)</td></tr>
<tr class="memitem:aa2900b83275cd9fb35009c5f5f232a2a inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#aa2900b83275cd9fb35009c5f5f232a2a">~Buffer</a> ()</td></tr>
<tr class="memitem:ad335471dcb4e7df652fbb556e59ea530 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ad335471dcb4e7df652fbb556e59ea530">capacity</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:ac3f3a9b58ba3c2986e0c7b3752b52c15 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a2bd74d7d5ea487a8cd5b0ab46273b14e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a2bd74d7d5ea487a8cd5b0ab46273b14e">position</a> (int newPosition)</td></tr>
<tr class="memdesc:a2bd74d7d5ea487a8cd5b0ab46273b14e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's position.  <a href="#a2bd74d7d5ea487a8cd5b0ab46273b14e"></a><br/></td></tr>
<tr class="memitem:a7517c02b4d27d040c44f970c307bf5b3 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memitem:a6d55516a05a08a813750fa4efc268708 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a6d55516a05a08a813750fa4efc268708">limit</a> (int newLimit)</td></tr>
<tr class="memdesc:a6d55516a05a08a813750fa4efc268708 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's limit.  <a href="#a6d55516a05a08a813750fa4efc268708"></a><br/></td></tr>
<tr class="memitem:aa5dccf3cd415e1c53cd0ab486877c9f7 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#aa5dccf3cd415e1c53cd0ab486877c9f7">mark</a> ()</td></tr>
<tr class="memdesc:aa5dccf3cd415e1c53cd0ab486877c9f7 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's mark at its position.  <a href="#aa5dccf3cd415e1c53cd0ab486877c9f7"></a><br/></td></tr>
<tr class="memitem:a11f11b3035d263fb9c48e3fbd58f4a4f inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a11f11b3035d263fb9c48e3fbd58f4a4f">reset</a> ()</td></tr>
<tr class="memdesc:a11f11b3035d263fb9c48e3fbd58f4a4f inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this buffer's position to the previously-marked position.  <a href="#a11f11b3035d263fb9c48e3fbd58f4a4f"></a><br/></td></tr>
<tr class="memitem:a86fcd3b1dc9b14bd98e9d0e38d505665 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a86fcd3b1dc9b14bd98e9d0e38d505665">clear</a> ()</td></tr>
<tr class="memdesc:a86fcd3b1dc9b14bd98e9d0e38d505665 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this buffer.  <a href="#a86fcd3b1dc9b14bd98e9d0e38d505665"></a><br/></td></tr>
<tr class="memitem:a39327161d79f0bde30467473eea0e4b5 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a39327161d79f0bde30467473eea0e4b5">flip</a> ()</td></tr>
<tr class="memdesc:a39327161d79f0bde30467473eea0e4b5 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips this buffer.  <a href="#a39327161d79f0bde30467473eea0e4b5"></a><br/></td></tr>
<tr class="memitem:a94ae44c9b90373b54fb6ee60451c453e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a94ae44c9b90373b54fb6ee60451c453e">rewind</a> ()</td></tr>
<tr class="memdesc:a94ae44c9b90373b54fb6ee60451c453e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds this buffer.  <a href="#a94ae44c9b90373b54fb6ee60451c453e"></a><br/></td></tr>
<tr class="memitem:a21cd75b27abc500af892a4078083c10e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e">remaining</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a21cd75b27abc500af892a4078083c10e inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements between the current position and the limit.  <a href="#a21cd75b27abc500af892a4078083c10e"></a><br/></td></tr>
<tr class="memitem:ae490604c9e2caa90e20bac31b8ece696 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ae490604c9e2caa90e20bac31b8ece696">hasRemaining</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae490604c9e2caa90e20bac31b8ece696 inherit pub_methods_classdecaf_1_1nio_1_1_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether there are any elements between the current position and the limit.  <a href="#ae490604c9e2caa90e20bac31b8ece696"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1lang_1_1_char_sequence"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1lang_1_1_char_sequence')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">decaf::lang::CharSequence</a></td></tr>
<tr class="memitem:ae80097d18bb54b7be5023085776f3caa inherit pub_methods_classdecaf_1_1lang_1_1_char_sequence"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html#ae80097d18bb54b7be5023085776f3caa">~CharSequence</a> ()</td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1lang_1_1_appendable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1lang_1_1_appendable')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1lang_1_1_appendable.html">decaf::lang::Appendable</a></td></tr>
<tr class="memitem:a728fe23982e7f78aa8cd78695ac65a09 inherit pub_methods_classdecaf_1_1lang_1_1_appendable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_appendable.html#a728fe23982e7f78aa8cd78695ac65a09">~Appendable</a> ()</td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1lang_1_1_comparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1lang_1_1_comparable')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classdecaf_1_1lang_1_1_comparable.html">decaf::lang::Comparable< CharBuffer ></a></td></tr>
<tr class="memitem:a4c6df497ab958b4c5d37cc665bad62e6 inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#a4c6df497ab958b4c5d37cc665bad62e6">~Comparable</a> ()</td></tr>
<tr class="memitem:a4b15bbd971c5a367ec645dcbe0f5828c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#a4b15bbd971c5a367ec645dcbe0f5828c">compareTo</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> CharBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:a4b15bbd971c5a367ec645dcbe0f5828c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this object with the specified object for order.  <a href="#a4b15bbd971c5a367ec645dcbe0f5828c"></a><br/></td></tr>
<tr class="memitem:aade52c698a4a36f69c8fe4528e2c3f4f inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#aade52c698a4a36f69c8fe4528e2c3f4f">equals</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> CharBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memitem:aa75d69171dc24e84368f09d4b2b1fee3 inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#aa75d69171dc24e84368f09d4b2b1fee3">operator==</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> CharBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:aa75d69171dc24e84368f09d4b2b1fee3 inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares equality between this object and the one passed.  <a href="#aa75d69171dc24e84368f09d4b2b1fee3"></a><br/></td></tr>
<tr class="memitem:aa46ee7417a04ad1868953202f919d63c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1lang_1_1_comparable.html#aa46ee7417a04ad1868953202f919d63c">operator&lt;</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> CharBuffer &amp;value) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> =0</td></tr>
<tr class="memdesc:aa46ee7417a04ad1868953202f919d63c inherit pub_methods_classdecaf_1_1lang_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this object to another and returns true if this object is considered to be less than the one passed.  <a href="#aa46ee7417a04ad1868953202f919d63c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad160fde41808391c1237a67aee9659be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ad160fde41808391c1237a67aee9659be">setReadOnly</a> (bool value)</td></tr>
<tr class="memdesc:ad160fde41808391c1237a67aee9659be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> as Read-Only.  <a href="#ad160fde41808391c1237a67aee9659be"></a><br/></td></tr>
<tr class="inherit_header pro_methods_classdecaf_1_1nio_1_1_char_buffer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdecaf_1_1nio_1_1_char_buffer')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a></td></tr>
<tr class="memitem:a599d21e279737af12336858d9c81d7bf inherit pro_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> (int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ad335471dcb4e7df652fbb556e59ea530">capacity</a>)</td></tr>
<tr class="memdesc:a599d21e279737af12336858d9c81d7bf inherit pro_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted.  <a href="#a599d21e279737af12336858d9c81d7bf"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a177ea1ae3ce47a89e01a3daa6888fff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a><br class="typebreak"/>
&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a177ea1ae3ce47a89e01a3daa6888fff6">_array</a></td></tr>
<tr class="memitem:a4dd0e76b88bb81045aff8af4b9795690"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a4dd0e76b88bb81045aff8af4b9795690">offset</a></td></tr>
<tr class="memitem:af27acc91350dc6eee2796f299cd99e6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#af27acc91350dc6eee2796f299cd99e6a">length</a></td></tr>
<tr class="memitem:ac2da0f1500b27e4cc79d54eb2fd8f522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac2da0f1500b27e4cc79d54eb2fd8f522">readOnly</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdecaf_1_1nio_1_1_char_buffer')"><img src="closed.png" alt="-"/>&nbsp;Static Public Member Functions inherited from <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a></td></tr>
<tr class="memitem:ae84e49c09e88a68a889041bcd5d4d17f inherit pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ae84e49c09e88a68a889041bcd5d4d17f">allocate</a> (int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ad335471dcb4e7df652fbb556e59ea530">capacity</a>)</td></tr>
<tr class="memdesc:ae84e49c09e88a68a889041bcd5d4d17f inherit pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new character buffer.  <a href="#ae84e49c09e88a68a889041bcd5d4d17f"></a><br/></td></tr>
<tr class="memitem:aea41b929ded16d16196f17fc06b74cb4 inherit pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#aea41b929ded16d16196f17fc06b74cb4">wrap</a> (char *<a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#aeeedbd0a8bf248eb5435faf62da61e13">array</a>, int size, int offset, int <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab4c525f4eca223186eee72767c30e02f">length</a>)</td></tr>
<tr class="memdesc:aea41b929ded16d16196f17fc06b74cb4 inherit pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.  <a href="#aea41b929ded16d16196f17fc06b74cb4"></a><br/></td></tr>
<tr class="memitem:a30f53e388e6b5dfb089feb1946f38f7b inherit pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a30f53e388e6b5dfb089feb1946f38f7b">wrap</a> (std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a30f53e388e6b5dfb089feb1946f38f7b inherit pub_static_methods_classdecaf_1_1nio_1_1_char_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL char Vector in a <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.  <a href="#a30f53e388e6b5dfb089feb1946f38f7b"></a><br/></td></tr>
</table>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02363d5242435b69f8ca8e71abd585ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this buffer should be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if the capacity value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf23117e4d795a2ca00a2a2da479581a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> object that wraps the given array. </p>
<p>If the own flag is set then it will delete this array when this object is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The actual array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given array. </td></tr>
    <tr><td class="paramname">offset</td><td>The position that is this buffers start position. </td></tr>
    <tr><td class="paramname">length</td><td>The limit of how many bytes into the array this Buffer can write. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this buffer should be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset is greater than array capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4a28845aa83dfe9c2c9e802006d47a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a byte buffer that wraps the passed ByteArrayAdapter and start at the given offset. </p>
<p>The capacity and limit of the new <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> will be that of the remaining capacity of the passed buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The ByteArrayAdapter to wrap. </td></tr>
    <tr><td class="paramname">offset</td><td>The position that is this buffers start position. </td></tr>
    <tr><td class="paramname">length</td><td>The limit of how many bytes into the array this Buffer can write. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this buffer should be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if array is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset + length is greater than array size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e751518499478ef5da9ec29d8eea337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::CharArrayBuffer::CharArrayBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> that mirrors this one, meaning it shares a reference to this buffers ByteArrayAdapter and when changes are made to that data it is reflected in both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> this one is to mirror. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a780a85507dbdf2259d1acd7e5aadf1bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::nio::CharArrayBuffer::~CharArrayBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a2a962ba127c31943dd075327142a8402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* decaf::internal::nio::CharArrayBuffer::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the character array that backs this buffer (optional operation).Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="section return"><dt>Returns</dt><dd>the array that backs this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#aeeedbd0a8bf248eb5435faf62da61e13">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae6dabe5e2cc564bfe8a38de3f057ab3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::nio::CharArrayBuffer::arrayOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset within this buffer's backing array of the first element of the buffer (optional operation).Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="section return"><dt>Returns</dt><dd>The offset into the backing array where index zero starts.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a86cffeecea297e1ea495cd99e4900c67">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a9ac96e6fac08527174b0702cab373a39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a>* decaf::internal::nio::CharArrayBuffer::asReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new, read-only char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.<dl class="section return"><dt>Returns</dt><dd>The new, read-only char buffer which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a4fe36b72b26a5f5e5e1078fa764b408f">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a69d68ff242c2619d90782d287206cfb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a>&amp; decaf::internal::nio::CharArrayBuffer::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compacts this buffer.The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.<dl class="section return"><dt>Returns</dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>- If this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ad9986f7f6866aabf327f7b5454fd3a5e">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="acf2117fe9c621d2569aa6bf5880bdf8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a>* decaf::internal::nio::CharArrayBuffer::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new char buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="section return"><dt>Returns</dt><dd>a new char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a75c1941edd0a2c97a48c27c71f2c368b">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a22a5f51cf8da460d264e91afaad64813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::nio::CharArrayBuffer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative get method.Reads the character at this buffer's current position, and then increments the position.<dl class="section return"><dt>Returns</dt><dd>the char at the current position.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there no more data to return</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a2b97bd1d26c39d08f1f58c12d72c5b51">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a5da481d2f474ac00496f458abf719fea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::nio::CharArrayBuffer::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute get method.Reads the char at the given index.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the char is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the char that is located at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit or is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a473c75666831b132703413ee1ab96fb1">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a9e39462b5ed584c2556b686fd3c5e830"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::nio::CharArrayBuffer::hasArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether or not this buffer is backed by an accessible char array.If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.<dl class="section return"><dt>Returns</dt><dd>true if, and only if, this buffer is backed by an array and is not read-only</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a72e3273f23313d1ceedaeee2ff1435e3">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a479f8f91fa141921980f2002e1ca39f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::nio::CharArrayBuffer::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether or not this buffer is read-only.<dl class="section return"><dt>Returns</dt><dd>true if, and only if, this buffer is read-only.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a3cb8f27f48cae4bf41443d0d67b9e972">decaf::nio::Buffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac7000bacc913fbd14e1c957f80ec9b14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a>&amp; decaf::internal::nio::CharArrayBuffer::put </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given char into this buffer at the current position, and then increments the position.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ad7f8e07c4c460376cbfec0f143c94caa">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad2d2a97ee0cd5061f7eb428f8238821c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a>&amp; decaf::internal::nio::CharArrayBuffer::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given char into this buffer at the given index.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The char to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a39a42ad53cebf0c96a3e1b911193ed59">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad160fde41808391c1237a67aee9659be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::nio::CharArrayBuffer::setReadOnly </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a> as Read-Only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Boolean value, true if this buffer is to be read-only, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50e69c403797e5d6e0c3491f0e34a8a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a>* decaf::internal::nio::CharArrayBuffer::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> whose content is a shared subsequence of this buffer's content.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="section return"><dt>Returns</dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> which the caller owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a5d2d8c90d964c4968f8f350f5551f037">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aeb7ba1e4d009af1a76ba212f8fdc2dd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a>* decaf::internal::nio::CharArrayBuffer::subSequence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position.The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + start, and its limit will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + end. The new <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> will be read-only if, and only if, this buffer is read-only.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index, relative to the current position, of the first character in the subsequence; must be non-negative and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>. </td></tr>
    <tr><td class="paramname">end</td><td>The index, relative to the current position, of the character following the last character in the subsequence; must be no smaller than start and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new character buffer, caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions on start and end fail.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a1d31acb1522ee27f91e415874b9489cf">decaf::nio::CharBuffer</a>.</p>

</div>
</div>
<h2>Field Documentation</h2>
<a class="anchor" id="a177ea1ae3ce47a89e01a3daa6888fff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt;<a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a>&gt; decaf::internal::nio::CharArrayBuffer::_array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af27acc91350dc6eee2796f299cd99e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::internal::nio::CharArrayBuffer::length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dd0e76b88bb81045aff8af4b9795690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::internal::nio::CharArrayBuffer::offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2da0f1500b27e4cc79d54eb2fd8f522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::internal::nio::CharArrayBuffer::readOnly</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/nio/<a class="el" href="_char_array_buffer_8h_source.html">CharArrayBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1nio.html">nio</a></li><li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html">CharArrayBuffer</a></li>
    <li class="footer">Generated on Mon Mar 4 2013 10:25:50 for activemq-cpp-3.6.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
