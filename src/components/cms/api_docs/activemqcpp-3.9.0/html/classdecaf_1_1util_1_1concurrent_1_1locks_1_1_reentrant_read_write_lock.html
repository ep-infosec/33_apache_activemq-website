<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>activemq-cpp-3.9.0: decaf::util::concurrent::locks::ReentrantReadWriteLock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.9.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">decaf::util::concurrent::locks::ReentrantReadWriteLock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_reentrant_read_write_lock_8h_source.html">src/main/decaf/util/concurrent/locks/ReentrantReadWriteLock.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::locks::ReentrantReadWriteLock:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_inherit__map" id="decaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html" title="A ReadWriteLock maintains a pair of associated locks, one for read&#45;only operations and one for writin..." alt="" coords="34,6,192,47"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb52ea2f3aacf78dbb3c8876d07da154"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#afb52ea2f3aacf78dbb3c8876d07da154">ReentrantReadWriteLock</a> ()</td></tr>
<tr class="memdesc:afb52ea2f3aacf78dbb3c8876d07da154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html">ReentrantReadWriteLock</a> with the default ordering property of Not-Fair.  <a href="#afb52ea2f3aacf78dbb3c8876d07da154">More...</a><br /></td></tr>
<tr class="separator:afb52ea2f3aacf78dbb3c8876d07da154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2adfa98509ae5865e4655670496446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#afa2adfa98509ae5865e4655670496446">ReentrantReadWriteLock</a> (bool fair)</td></tr>
<tr class="memdesc:afa2adfa98509ae5865e4655670496446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html">ReentrantReadWriteLock</a> with the given fairness policy.  <a href="#afa2adfa98509ae5865e4655670496446">More...</a><br /></td></tr>
<tr class="separator:afa2adfa98509ae5865e4655670496446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4019d9ed40166625ed5ea8a086a5beb0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a4019d9ed40166625ed5ea8a086a5beb0">~ReentrantReadWriteLock</a> ()</td></tr>
<tr class="separator:a4019d9ed40166625ed5ea8a086a5beb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbcef08e5014568cc6b173f9b4721ad"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak" />
<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html">decaf::util::concurrent::locks::Lock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#acbbcef08e5014568cc6b173f9b4721ad">readLock</a> ()</td></tr>
<tr class="memdesc:acbbcef08e5014568cc6b173f9b4721ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock used for reading.<dl class="section return"><dt>Returns</dt><dd>the lock used for reading.</dd></dl>
  <a href="#acbbcef08e5014568cc6b173f9b4721ad">More...</a><br /></td></tr>
<tr class="separator:acbbcef08e5014568cc6b173f9b4721ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896cf45c4c0820ac06e228a1ca73b6a2"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak" />
<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html">decaf::util::concurrent::locks::Lock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a896cf45c4c0820ac06e228a1ca73b6a2">writeLock</a> ()</td></tr>
<tr class="memdesc:a896cf45c4c0820ac06e228a1ca73b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock used for writing.<dl class="section return"><dt>Returns</dt><dd>the lock used for writing.</dd></dl>
  <a href="#a896cf45c4c0820ac06e228a1ca73b6a2">More...</a><br /></td></tr>
<tr class="separator:a896cf45c4c0820ac06e228a1ca73b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1075c9fdbbe6a7a892d30475f0c831"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#afa1075c9fdbbe6a7a892d30475f0c831">isFair</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:afa1075c9fdbbe6a7a892d30475f0c831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this lock has fairness set true.  <a href="#afa1075c9fdbbe6a7a892d30475f0c831">More...</a><br /></td></tr>
<tr class="separator:afa1075c9fdbbe6a7a892d30475f0c831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b53462ead53ba5ec4676cc0801cafab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a3b53462ead53ba5ec4676cc0801cafab">getReadLockCount</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a3b53462ead53ba5ec4676cc0801cafab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the number of read locks held for this lock.  <a href="#a3b53462ead53ba5ec4676cc0801cafab">More...</a><br /></td></tr>
<tr class="separator:a3b53462ead53ba5ec4676cc0801cafab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2665f80331e0c46a98290fa4e191c80e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a2665f80331e0c46a98290fa4e191c80e">isWriteLocked</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2665f80331e0c46a98290fa4e191c80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if the write lock is held by any thread.  <a href="#a2665f80331e0c46a98290fa4e191c80e">More...</a><br /></td></tr>
<tr class="separator:a2665f80331e0c46a98290fa4e191c80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3272e3ae81c7e5e661f6637680ba16f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a3272e3ae81c7e5e661f6637680ba16f3">isWriteLockedByCurrentThread</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a3272e3ae81c7e5e661f6637680ba16f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if the write lock is held by the current thread.  <a href="#a3272e3ae81c7e5e661f6637680ba16f3">More...</a><br /></td></tr>
<tr class="separator:a3272e3ae81c7e5e661f6637680ba16f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83d20e11dcb2bc9cc3ea883d9aac6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a7b83d20e11dcb2bc9cc3ea883d9aac6a">getWriteHoldCount</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a7b83d20e11dcb2bc9cc3ea883d9aac6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the number of reentrant write holds on this lock by the current thread.  <a href="#a7b83d20e11dcb2bc9cc3ea883d9aac6a">More...</a><br /></td></tr>
<tr class="separator:a7b83d20e11dcb2bc9cc3ea883d9aac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfce2b7f6b8587d72c9dcf7bfceb08a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a1bfce2b7f6b8587d72c9dcf7bfceb08a">getReadHoldCount</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a1bfce2b7f6b8587d72c9dcf7bfceb08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the number of reentrant read holds on this lock by the current thread.  <a href="#a1bfce2b7f6b8587d72c9dcf7bfceb08a">More...</a><br /></td></tr>
<tr class="separator:a1bfce2b7f6b8587d72c9dcf7bfceb08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710815e992e88d217cc7f01244199dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a3710815e992e88d217cc7f01244199dc">hasWaiters</a> (<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a3710815e992e88d217cc7f01244199dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether any threads are waiting on the given condition associated with the write lock.  <a href="#a3710815e992e88d217cc7f01244199dc">More...</a><br /></td></tr>
<tr class="separator:a3710815e992e88d217cc7f01244199dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205066411019e2ba2c43b7f66b164d76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a205066411019e2ba2c43b7f66b164d76">getWaitQueueLength</a> (<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a205066411019e2ba2c43b7f66b164d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an estimated count of the number of threads that are currently waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object, this value changes dynamically so the result of this method can be invalid immediately after it is called.  <a href="#a205066411019e2ba2c43b7f66b164d76">More...</a><br /></td></tr>
<tr class="separator:a205066411019e2ba2c43b7f66b164d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b72f1232256832ac313ed6120d9449"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a90b72f1232256832ac313ed6120d9449">toString</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a90b72f1232256832ac313ed6120d9449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string identifying this lock, as well as its lock state.  <a href="#a90b72f1232256832ac313ed6120d9449">More...</a><br /></td></tr>
<tr class="separator:a90b72f1232256832ac313ed6120d9449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb3e4f40cc7a6bb1f542e704ec0591e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#acdb3e4f40cc7a6bb1f542e704ec0591e">hasQueuedThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:acdb3e4f40cc7a6bb1f542e704ec0591e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether any threads are waiting to acquire the read or write lock.  <a href="#acdb3e4f40cc7a6bb1f542e704ec0591e">More...</a><br /></td></tr>
<tr class="separator:acdb3e4f40cc7a6bb1f542e704ec0591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca00d9adee67cae1e90df785fdc1a6f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#aca00d9adee67cae1e90df785fdc1a6f0">hasQueuedThread</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *thread) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:aca00d9adee67cae1e90df785fdc1a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether the given thread is waiting to acquire either the read or write lock.  <a href="#aca00d9adee67cae1e90df785fdc1a6f0">More...</a><br /></td></tr>
<tr class="separator:aca00d9adee67cae1e90df785fdc1a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3020143c8a5d75cbf420db86dfe32c06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a3020143c8a5d75cbf420db86dfe32c06">getQueueLength</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a3020143c8a5d75cbf420db86dfe32c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimate of the number of threads waiting to acquire either the read or write lock.  <a href="#a3020143c8a5d75cbf420db86dfe32c06">More...</a><br /></td></tr>
<tr class="separator:a3020143c8a5d75cbf420db86dfe32c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html">decaf::util::concurrent::locks::ReadWriteLock</a></td></tr>
<tr class="memitem:a6eb75a0c0209f9794d9e7e3b96104ef9 inherit pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html#a6eb75a0c0209f9794d9e7e3b96104ef9">~ReadWriteLock</a> ()</td></tr>
<tr class="separator:a6eb75a0c0209f9794d9e7e3b96104ef9 inherit pub_methods_classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b074199a1a58ab18d31dd5bb5890757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a><br class="typebreak" />
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a4b074199a1a58ab18d31dd5bb5890757">getWaitingThreads</a> (<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> *condition) <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a4b074199a1a58ab18d31dd5bb5890757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy. ">Collection</a> object that contains all the threads that may be waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object instance at the time this method is called.  <a href="#a4b074199a1a58ab18d31dd5bb5890757">More...</a><br /></td></tr>
<tr class="separator:a4b074199a1a58ab18d31dd5bb5890757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e696bf852d079e986e07f775185f7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a><br class="typebreak" />
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a2e696bf852d079e986e07f775185f7d5">getQueuedThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a2e696bf852d079e986e07f775185f7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection containing threads that may be waiting to acquire either the read or write lock.  <a href="#a2e696bf852d079e986e07f775185f7d5">More...</a><br /></td></tr>
<tr class="separator:a2e696bf852d079e986e07f775185f7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf884aabca262edb519630cd984950de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a><br class="typebreak" />
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adf884aabca262edb519630cd984950de">getQueuedWriterThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:adf884aabca262edb519630cd984950de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection containing threads that may be waiting to acquire the write lock.  <a href="#adf884aabca262edb519630cd984950de">More...</a><br /></td></tr>
<tr class="separator:adf884aabca262edb519630cd984950de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e74d19e0383d07d1d4e5f2c7861d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a><br class="typebreak" />
&lt; <a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a51e74d19e0383d07d1d4e5f2c7861d33">getQueuedReaderThreads</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:a51e74d19e0383d07d1d4e5f2c7861d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection containing threads that may be waiting to acquire the read lock.  <a href="#a51e74d19e0383d07d1d4e5f2c7861d33">More...</a><br /></td></tr>
<tr class="separator:a51e74d19e0383d07d1d4e5f2c7861d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c9d48ca1e2efe5299c28eea2083f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#ae6c9d48ca1e2efe5299c28eea2083f07">getOwner</a> () <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> </td></tr>
<tr class="memdesc:ae6c9d48ca1e2efe5299c28eea2083f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread that currently owns the write lock, or NULL if not owned.  <a href="#ae6c9d48ca1e2efe5299c28eea2083f07">More...</a><br /></td></tr>
<tr class="separator:ae6c9d48ca1e2efe5299c28eea2083f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb52ea2f3aacf78dbb3c8876d07da154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::concurrent::locks::ReentrantReadWriteLock::ReentrantReadWriteLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html">ReentrantReadWriteLock</a> with the default ordering property of Not-Fair. </p>

</div>
</div>
<a class="anchor" id="afa2adfa98509ae5865e4655670496446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::concurrent::locks::ReentrantReadWriteLock::ReentrantReadWriteLock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html">ReentrantReadWriteLock</a> with the given fairness policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fair</td><td>Boolean value indicating whether this lock uses a fair or non-fair policy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4019d9ed40166625ed5ea8a086a5beb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::util::concurrent::locks::ReentrantReadWriteLock::~ReentrantReadWriteLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae6c9d48ca1e2efe5299c28eea2083f07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>* decaf::util::concurrent::locks::ReentrantReadWriteLock::getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the thread that currently owns the write lock, or NULL if not owned. </p>
<p>When this method is called by a thread that is not the owner, the return value reflects a best-effort approximation of current lock status. For example, the owner may be momentarily NULL even if there are threads trying to acquire the lock but have not yet done so. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the owner thread pointer, or NULL if not currently owned. </dd></dl>

</div>
</div>
<a class="anchor" id="a51e74d19e0383d07d1d4e5f2c7861d33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::ReentrantReadWriteLock::getQueuedReaderThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection containing threads that may be waiting to acquire the read lock. </p>
<p>Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>

</div>
</div>
<a class="anchor" id="a2e696bf852d079e986e07f775185f7d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::ReentrantReadWriteLock::getQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection containing threads that may be waiting to acquire either the read or write lock. </p>
<p>Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>

</div>
</div>
<a class="anchor" id="adf884aabca262edb519630cd984950de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::ReentrantReadWriteLock::getQueuedWriterThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection containing threads that may be waiting to acquire the write lock. </p>
<p>Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>

</div>
</div>
<a class="anchor" id="a3020143c8a5d75cbf420db86dfe32c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::ReentrantReadWriteLock::getQueueLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an estimate of the number of threads waiting to acquire either the read or write lock. </p>
<p>The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring of the system state, not for synchronization control.</p>
<dl class="section return"><dt>Returns</dt><dd>the estimated number of threads waiting for this lock </dd></dl>

</div>
</div>
<a class="anchor" id="a1bfce2b7f6b8587d72c9dcf7bfceb08a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::ReentrantReadWriteLock::getReadHoldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the number of reentrant read holds on this lock by the current thread. </p>
<p>A reader thread has a hold on a lock for each lock action that is not matched by an unlock action.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of holds on the read lock by the current thread, or zero if the read lock is not held by the current thread </dd></dl>

</div>
</div>
<a class="anchor" id="a3b53462ead53ba5ec4676cc0801cafab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::ReentrantReadWriteLock::getReadLockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the number of read locks held for this lock. </p>
<p>This method is designed for use in monitoring system state, not for synchronization control.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of read locks held. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b074199a1a58ab18d31dd5bb5890757"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_collection.html">decaf::util::Collection</a>&lt;<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a>*&gt;* decaf::util::concurrent::locks::ReentrantReadWriteLock::getWaitingThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a new <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy. ">Collection</a> object that contains all the threads that may be waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object instance at the time this method is called. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy. ">Collection</a> pointer that contains waiting threads on given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object. The caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the ConditionObject pointer is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the ConditionObject is not associated with this Synchronizer. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not hold exclusive synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a205066411019e2ba2c43b7f66b164d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::ReentrantReadWriteLock::getWaitQueueLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an estimated count of the number of threads that are currently waiting on the given <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object, this value changes dynamically so the result of this method can be invalid immediately after it is called. </p>
<p>The <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html" title="Condition factors out the Mutex monitor methods (wait, notify and notifyAll) into distinct objects to...">Condition</a> object must be associated with this <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html" title="Lock implementations provide more extensive locking operations than can be obtained using synchronize...">Lock</a> or an exception will be thrown.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the number of waiting threads.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the ConditionObject pointer is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the ConditionObject is not associated with this Synchronizer. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not hold exclusive synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b83d20e11dcb2bc9cc3ea883d9aac6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::concurrent::locks::ReentrantReadWriteLock::getWriteHoldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the number of reentrant write holds on this lock by the current thread. </p>
<p>A writer thread has a hold on a lock for each lock action that is not matched by an unlock action.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of holds on the write lock by the current thread, or zero if the write lock is not held by the current thread </dd></dl>

</div>
</div>
<a class="anchor" id="aca00d9adee67cae1e90df785fdc1a6f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::ReentrantReadWriteLock::hasQueuedThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries whether the given thread is waiting to acquire either the read or write lock. </p>
<p>Note that because cancellations may occur at any time, a true return does not guarantee that this thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread that will be queried for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given thread is queued waiting for this lock</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the thread is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdb3e4f40cc7a6bb1f542e704ec0591e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::ReentrantReadWriteLock::hasQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries whether any threads are waiting to acquire the read or write lock. </p>
<p>Note that because cancellations may occur at any time, a true return does not guarantee that any other thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.</p>
<dl class="section return"><dt>Returns</dt><dd>if there may be other threads waiting to acquire the lock </dd></dl>

</div>
</div>
<a class="anchor" id="a3710815e992e88d217cc7f01244199dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::ReentrantReadWriteLock::hasWaiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries whether any threads are waiting on the given condition associated with the write lock. </p>
<p>Note that because timeouts and interrupts may occur at any time, a true return does not guarantee that a future signal will awaken any threads. This method is designed primarily for use in monitoring of the system state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The condition to be queried for waiters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are any waiting threads</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the ConditionObject pointer is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the ConditionObject is not associated with this <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html" title="Lock implementations provide more extensive locking operations than can be obtained using synchronize...">Lock</a>. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not hold exclusive synchronization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa1075c9fdbbe6a7a892d30475f0c831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::ReentrantReadWriteLock::isFair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this lock has fairness set true. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html" title="Lock implementations provide more extensive locking operations than can be obtained using synchronize...">Lock</a> uses a fair policy otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a2665f80331e0c46a98290fa4e191c80e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::ReentrantReadWriteLock::isWriteLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries if the write lock is held by any thread. </p>
<p>This method is designed for use in monitoring system state, not for synchronization control.</p>
<dl class="section return"><dt>Returns</dt><dd>true if any thread holds the write lock and false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a3272e3ae81c7e5e661f6637680ba16f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::concurrent::locks::ReentrantReadWriteLock::isWriteLockedByCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries if the write lock is held by the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the current thread holds the write lock and false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acbbcef08e5014568cc6b173f9b4721ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html">decaf::util::concurrent::locks::Lock</a>&amp; decaf::util::concurrent::locks::ReentrantReadWriteLock::readLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lock used for reading.<dl class="section return"><dt>Returns</dt><dd>the lock used for reading.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html#a3e3a755dbaf6a41058f5c0fd7bacde9c">decaf::util::concurrent::locks::ReadWriteLock</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9d1a9ed9c5c7ee9130d742c63f91c7bd">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::contains()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a335e703f5eaa0d9c5de377a0b275f9c2">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a8adaf616d9b83c3bc9f748c20fa2692a">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::indexOf()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a52634c38931211d1935e409c23923805">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::isEmpty()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a2014e3565818f0ba96696c81f78b3cda">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::iterator()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ab1bc60cf328e1b5e12b1f5cacea02eee">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::lastIndexOf()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a737d8a95f14b1ced78223dd572cdba29">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::listIterator()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ae2846f1693ccf81c5c935b389858209c">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::size()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a00ef7324a7dd2436bbcf2efca83db88d">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::toArray()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a3e9aadb858a9ac5734cb92fe5f262b5b">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::toString()</a>.</p>

</div>
</div>
<a class="anchor" id="a90b72f1232256832ac313ed6120d9449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string decaf::util::concurrent::locks::ReentrantReadWriteLock::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string identifying this lock, as well as its lock state. </p>
<p>The state, in brackets, includes the String "Write locks =" followed by the number of reentrantly held write locks, and the String "Read locks =" followed by the number of held read locks.</p>
<dl class="section return"><dt>Returns</dt><dd>a string identifying this lock, as well as its lock state </dd></dl>

</div>
</div>
<a class="anchor" id="a896cf45c4c0820ac06e228a1ca73b6a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_lock.html">decaf::util::concurrent::locks::Lock</a>&amp; decaf::util::concurrent::locks::ReentrantReadWriteLock::writeLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lock used for writing.<dl class="section return"><dt>Returns</dt><dd>the lock used for writing.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html#ab5aa0d9630e6318e41f632ab9a116e0b">decaf::util::concurrent::locks::ReadWriteLock</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1348b8a92975ef48222727245f6f4474">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#abb7d73a4cd2d1eb5736d1b263ce10a0f">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::addAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::addAllAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7ec6efcb0c6fcfa7f7ea144a3e928a97">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::addIfAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7e7ad15476b1088cc4fb9d675686ebb1">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::clear()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ad7f23a66e492777f92e0b8f7be6ab0b5">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::copy()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a996887273387f18849afdc8699ff5e29">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::CopyOnWriteArrayList()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a6057a5c7d3843eefd2731e4f5a618283">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::lock()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a174136c43ddf0df59a7712d3e2a0198a">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::operator=()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a679f08a5ca71cdfc31752c31afd728a8">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::remove()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afaa8a997b2001dd3eac1393ab0ed24ca">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::removeAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a09dc6cc12d27c0099ba772cb1d805d62">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::removeAt()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9e7261248ccbbf2271773a027435037e">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::retainAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1155ffa7088e44b057e4525ecbc475ce">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::set()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aef1ce4a7101e660b9f4016e3fe28958b">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::tryLock()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a3f16177058f4033cf60af91c1d88faa1">decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::unlock()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/locks/<a class="el" href="_reentrant_read_write_lock_8h_source.html">ReentrantReadWriteLock.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent_1_1locks.html">locks</a></li><li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html">ReentrantReadWriteLock</a></li>
    <li class="footer">Generated on Sun Aug 16 2015 17:10:39 for activemq-cpp-3.9.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
