<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>activemq-cpp-3.9.0: decaf::internal::nio::BufferFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.9.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">decaf::internal::nio::BufferFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Factory class used by static methods in the <a class="el" href="namespacedecaf_1_1nio.html">decaf::nio</a> package to create the various default version of the NIO interfaces.  
 <a href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_buffer_factory_8h_source.html">src/main/decaf/internal/nio/BufferFactory.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44589bb67396cb8f8b5938bdbd0bcd0b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a44589bb67396cb8f8b5938bdbd0bcd0b">~BufferFactory</a> ()</td></tr>
<tr class="separator:a44589bb67396cb8f8b5938bdbd0bcd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a81ca8266bd013b23e09253d53b3b0604"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a81ca8266bd013b23e09253d53b3b0604">createByteBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:a81ca8266bd013b23e09253d53b3b0604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new byte buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a81ca8266bd013b23e09253d53b3b0604">More...</a><br /></td></tr>
<tr class="separator:a81ca8266bd013b23e09253d53b3b0604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac367fd1eaf75b62f48d81cdfa69ef38b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#ac367fd1eaf75b62f48d81cdfa69ef38b">createByteBuffer</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:ac367fd1eaf75b62f48d81cdfa69ef38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new ByteBuffer.  <a href="#ac367fd1eaf75b62f48d81cdfa69ef38b">More...</a><br /></td></tr>
<tr class="separator:ac367fd1eaf75b62f48d81cdfa69ef38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa299eac2edbc5bc9039958439be8a2a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#aa299eac2edbc5bc9039958439be8a2a5">createByteBuffer</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:aa299eac2edbc5bc9039958439be8a2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Byte Vector in a ByteBuffer.  <a href="#aa299eac2edbc5bc9039958439be8a2a5">More...</a><br /></td></tr>
<tr class="separator:aa299eac2edbc5bc9039958439be8a2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773d72f35d0ed7123c9e1776e61cfb4f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a773d72f35d0ed7123c9e1776e61cfb4f">createCharBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:a773d72f35d0ed7123c9e1776e61cfb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new char buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a773d72f35d0ed7123c9e1776e61cfb4f">More...</a><br /></td></tr>
<tr class="separator:a773d72f35d0ed7123c9e1776e61cfb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c16867c4982251dcfda414f98f08780"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a3c16867c4982251dcfda414f98f08780">createCharBuffer</a> (char *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a3c16867c4982251dcfda414f98f08780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new CharBuffer.  <a href="#a3c16867c4982251dcfda414f98f08780">More...</a><br /></td></tr>
<tr class="separator:a3c16867c4982251dcfda414f98f08780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c0c9ded98d3942a7bc7f334c2d69ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a01c0c9ded98d3942a7bc7f334c2d69ab">createCharBuffer</a> (std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a01c0c9ded98d3942a7bc7f334c2d69ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Byte Vector in a CharBuffer.  <a href="#a01c0c9ded98d3942a7bc7f334c2d69ab">More...</a><br /></td></tr>
<tr class="separator:a01c0c9ded98d3942a7bc7f334c2d69ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b903fc76e64ef59f728fb08b10458a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a91b903fc76e64ef59f728fb08b10458a">createDoubleBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:a91b903fc76e64ef59f728fb08b10458a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new double buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a91b903fc76e64ef59f728fb08b10458a">More...</a><br /></td></tr>
<tr class="separator:a91b903fc76e64ef59f728fb08b10458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065486057caaab4e75f8bf536949ba13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a065486057caaab4e75f8bf536949ba13">createDoubleBuffer</a> (double *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a065486057caaab4e75f8bf536949ba13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new DoubleBuffer.  <a href="#a065486057caaab4e75f8bf536949ba13">More...</a><br /></td></tr>
<tr class="separator:a065486057caaab4e75f8bf536949ba13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016dcf7bd76dd369efdf36bb5768e1b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a016dcf7bd76dd369efdf36bb5768e1b0">createDoubleBuffer</a> (std::vector&lt; double &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a016dcf7bd76dd369efdf36bb5768e1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Double Vector in a DoubleBuffer.  <a href="#a016dcf7bd76dd369efdf36bb5768e1b0">More...</a><br /></td></tr>
<tr class="separator:a016dcf7bd76dd369efdf36bb5768e1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f5096f9aecd298f206efe41f44511c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a91f5096f9aecd298f206efe41f44511c">createFloatBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:a91f5096f9aecd298f206efe41f44511c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new float buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a91f5096f9aecd298f206efe41f44511c">More...</a><br /></td></tr>
<tr class="separator:a91f5096f9aecd298f206efe41f44511c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090a447d5908e7fd25510a717441153a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a090a447d5908e7fd25510a717441153a">createFloatBuffer</a> (float *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a090a447d5908e7fd25510a717441153a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new FloatBuffer.  <a href="#a090a447d5908e7fd25510a717441153a">More...</a><br /></td></tr>
<tr class="separator:a090a447d5908e7fd25510a717441153a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534f43f7dc112d19135f60895bec4cc7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a534f43f7dc112d19135f60895bec4cc7">createFloatBuffer</a> (std::vector&lt; float &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a534f43f7dc112d19135f60895bec4cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Float Vector in a FloatBuffer.  <a href="#a534f43f7dc112d19135f60895bec4cc7">More...</a><br /></td></tr>
<tr class="separator:a534f43f7dc112d19135f60895bec4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2a0d5d5d268f9406df68e7dd7c148b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a9e2a0d5d5d268f9406df68e7dd7c148b">createLongBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:a9e2a0d5d5d268f9406df68e7dd7c148b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new long long buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a9e2a0d5d5d268f9406df68e7dd7c148b">More...</a><br /></td></tr>
<tr class="separator:a9e2a0d5d5d268f9406df68e7dd7c148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad4bffc68dae978d039ca2bb5ae510"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#aa2ad4bffc68dae978d039ca2bb5ae510">createLongBuffer</a> (long long *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:aa2ad4bffc68dae978d039ca2bb5ae510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new LongBuffer.  <a href="#aa2ad4bffc68dae978d039ca2bb5ae510">More...</a><br /></td></tr>
<tr class="separator:aa2ad4bffc68dae978d039ca2bb5ae510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9605cfff316fa852ebecab999455be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a0a9605cfff316fa852ebecab999455be">createLongBuffer</a> (std::vector&lt; long long &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a0a9605cfff316fa852ebecab999455be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Long Vector in a LongBuffer.  <a href="#a0a9605cfff316fa852ebecab999455be">More...</a><br /></td></tr>
<tr class="separator:a0a9605cfff316fa852ebecab999455be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bad30ab070e85dd5d6757e2b2b8513"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#ad3bad30ab070e85dd5d6757e2b2b8513">createIntBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:ad3bad30ab070e85dd5d6757e2b2b8513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new int buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#ad3bad30ab070e85dd5d6757e2b2b8513">More...</a><br /></td></tr>
<tr class="separator:ad3bad30ab070e85dd5d6757e2b2b8513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce5f8877bb139772360ac92902c9372"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a8ce5f8877bb139772360ac92902c9372">createIntBuffer</a> (int *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a8ce5f8877bb139772360ac92902c9372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new IntBuffer.  <a href="#a8ce5f8877bb139772360ac92902c9372">More...</a><br /></td></tr>
<tr class="separator:a8ce5f8877bb139772360ac92902c9372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a0f97af31e266b8a08a455723a2e66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a74a0f97af31e266b8a08a455723a2e66">createIntBuffer</a> (std::vector&lt; int &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a74a0f97af31e266b8a08a455723a2e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL int Vector in a IntBuffer.  <a href="#a74a0f97af31e266b8a08a455723a2e66">More...</a><br /></td></tr>
<tr class="separator:a74a0f97af31e266b8a08a455723a2e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2050beb72a66c46b9fbf7ef767c7e9ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a2050beb72a66c46b9fbf7ef767c7e9ab">createShortBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:a2050beb72a66c46b9fbf7ef767c7e9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new short buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a2050beb72a66c46b9fbf7ef767c7e9ab">More...</a><br /></td></tr>
<tr class="separator:a2050beb72a66c46b9fbf7ef767c7e9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac9871200d3ec5dac012015f50ec0a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a1ac9871200d3ec5dac012015f50ec0a8">createShortBuffer</a> (short *buffer, int size, int offset, int length)</td></tr>
<tr class="memdesc:a1ac9871200d3ec5dac012015f50ec0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new ShortBuffer.  <a href="#a1ac9871200d3ec5dac012015f50ec0a8">More...</a><br /></td></tr>
<tr class="separator:a1ac9871200d3ec5dac012015f50ec0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ba803fe5baee34152fdce316e2651a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#af3ba803fe5baee34152fdce316e2651a">createShortBuffer</a> (std::vector&lt; short &gt; &amp;buffer)</td></tr>
<tr class="memdesc:af3ba803fe5baee34152fdce316e2651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Short Vector in a ShortBuffer.  <a href="#af3ba803fe5baee34152fdce316e2651a">More...</a><br /></td></tr>
<tr class="separator:af3ba803fe5baee34152fdce316e2651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Factory class used by static methods in the <a class="el" href="namespacedecaf_1_1nio.html">decaf::nio</a> package to create the various default version of the NIO interfaces. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a44589bb67396cb8f8b5938bdbd0bcd0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::nio::BufferFactory::~BufferFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a81ca8266bd013b23e09253d53b3b0604"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a>* decaf::internal::nio::BufferFactory::createByteBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new byte buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated ByteBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac367fd1eaf75b62f48d81cdfa69ef38b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a>* decaf::internal::nio::BufferFactory::createByteBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new ByteBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new ByteBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa299eac2edbc5bc9039958439be8a2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a>* decaf::internal::nio::BufferFactory::createByteBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Byte Vector in a ByteBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new ByteBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a773d72f35d0ed7123c9e1776e61cfb4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::BufferFactory::createCharBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new char buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated CharBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c16867c4982251dcfda414f98f08780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::BufferFactory::createCharBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new CharBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new CharBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01c0c9ded98d3942a7bc7f334c2d69ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::BufferFactory::createCharBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Byte Vector in a CharBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new CharBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a91b903fc76e64ef59f728fb08b10458a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::BufferFactory::createDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new double buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated DoubleBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a065486057caaab4e75f8bf536949ba13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::BufferFactory::createDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new DoubleBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new DoubleBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a016dcf7bd76dd369efdf36bb5768e1b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::BufferFactory::createDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Double Vector in a DoubleBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new DoubleBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a91f5096f9aecd298f206efe41f44511c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::BufferFactory::createFloatBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new float buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated FloatBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a090a447d5908e7fd25510a717441153a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::BufferFactory::createFloatBuffer </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new FloatBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new FloatBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a534f43f7dc112d19135f60895bec4cc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::BufferFactory::createFloatBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Float Vector in a FloatBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new FloatBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3bad30ab070e85dd5d6757e2b2b8513"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::BufferFactory::createIntBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new int buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated IntBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ce5f8877bb139772360ac92902c9372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::BufferFactory::createIntBuffer </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new IntBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new IntBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74a0f97af31e266b8a08a455723a2e66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::BufferFactory::createIntBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL int Vector in a IntBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new IntBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e2a0d5d5d268f9406df68e7dd7c148b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::BufferFactory::createLongBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new long long buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>- the internal buffer's capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated DoubleBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2ad4bffc68dae978d039ca2bb5ae510"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::BufferFactory::createLongBuffer </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new LongBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new LongBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a9605cfff316fa852ebecab999455be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::BufferFactory::createLongBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long long &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Long Vector in a LongBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new LongBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a2050beb72a66c46b9fbf7ef767c7e9ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::BufferFactory::createShortBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new short buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated ShortBuffer which the caller owns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ac9871200d3ec5dac012015f50ec0a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::BufferFactory::createShortBuffer </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed buffer with a new ShortBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new ShortBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3ba803fe5baee34152fdce316e2651a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::BufferFactory::createShortBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the passed STL Short Vector in a ShortBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new DoubleBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/nio/<a class="el" href="_buffer_factory_8h_source.html">BufferFactory.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1nio.html">nio</a></li><li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html">BufferFactory</a></li>
    <li class="footer">Generated on Sun Aug 16 2015 17:10:37 for activemq-cpp-3.9.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
