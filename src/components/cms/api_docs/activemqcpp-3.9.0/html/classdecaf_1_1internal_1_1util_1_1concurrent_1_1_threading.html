<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>activemq-cpp-3.9.0: decaf::internal::util::concurrent::Threading Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.9.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">decaf::internal::util::concurrent::Threading Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_threading_8h_source.html">src/main/decaf/internal/util/concurrent/Threading.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5236193df8c51ceb0256ccd385b8c064"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a5236193df8c51ceb0256ccd385b8c064">initialize</a> ()</td></tr>
<tr class="memdesc:a5236193df8c51ceb0256ccd385b8c064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the Decaf Runtime at startup to allow the Platform <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> code to initialize any necessary <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> constructs needed to support the features of this class.  <a href="#a5236193df8c51ceb0256ccd385b8c064">More...</a><br /></td></tr>
<tr class="separator:a5236193df8c51ceb0256ccd385b8c064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa290220e82eb5bf9badfc5e6d699b8b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#aa290220e82eb5bf9badfc5e6d699b8b6">shutdown</a> ()</td></tr>
<tr class="memdesc:aa290220e82eb5bf9badfc5e6d699b8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the Decaf Runtime at Shutdown to allow the Platform <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> code to return any resources that were allocated at startup for the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library.  <a href="#aa290220e82eb5bf9badfc5e6d699b8b6">More...</a><br /></td></tr>
<tr class="separator:aa290220e82eb5bf9badfc5e6d699b8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044b09793604176e27befced944b56f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a044b09793604176e27befced944b56f8">lockThreadsLib</a> ()</td></tr>
<tr class="memdesc:a044b09793604176e27befced944b56f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library allowing an object to perform some operations safely in a multi-threaded environment.  <a href="#a044b09793604176e27befced944b56f8">More...</a><br /></td></tr>
<tr class="separator:a044b09793604176e27befced944b56f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab513346c21ec8a96e554561acea458ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ab513346c21ec8a96e554561acea458ca">unlockThreadsLib</a> ()</td></tr>
<tr class="memdesc:ab513346c21ec8a96e554561acea458ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library when locked.  <a href="#ab513346c21ec8a96e554561acea458ca">More...</a><br /></td></tr>
<tr class="separator:ab513346c21ec8a96e554561acea458ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579247cbb8670d546784d78d590a0160"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a579247cbb8670d546784d78d590a0160">dumpRunningThreads</a> ()</td></tr>
<tr class="memdesc:a579247cbb8670d546784d78d590a0160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic method dumps all threads info to console.  <a href="#a579247cbb8670d546784d78d590a0160">More...</a><br /></td></tr>
<tr class="separator:a579247cbb8670d546784d78d590a0160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add89aa666968f0e2246cb52c2c7ce8f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#add89aa666968f0e2246cb52c2c7ce8f4">takeMonitor</a> (bool alreadyLocked=false)</td></tr>
<tr class="memdesc:add89aa666968f0e2246cb52c2c7ce8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a monitor for use as a locking mechanism.  <a href="#add89aa666968f0e2246cb52c2c7ce8f4">More...</a><br /></td></tr>
<tr class="separator:add89aa666968f0e2246cb52c2c7ce8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55fb0ec9b90367513f4a840333b88d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#af55fb0ec9b90367513f4a840333b88d3">returnMonitor</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor, bool alreadyLocked=false)</td></tr>
<tr class="memdesc:af55fb0ec9b90367513f4a840333b88d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a given monitor to the Monitor pool after the Monitor is no longer needed.  <a href="#af55fb0ec9b90367513f4a840333b88d3">More...</a><br /></td></tr>
<tr class="separator:af55fb0ec9b90367513f4a840333b88d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e26b0003b98c1ad6f189f9369677a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a79e26b0003b98c1ad6f189f9369677a4">enterMonitor</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor)</td></tr>
<tr class="memdesc:a79e26b0003b98c1ad6f189f9369677a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor locking method.  <a href="#a79e26b0003b98c1ad6f189f9369677a4">More...</a><br /></td></tr>
<tr class="separator:a79e26b0003b98c1ad6f189f9369677a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e75ac9be7790069aea67b1638e5ccc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a80e75ac9be7790069aea67b1638e5ccc">tryEnterMonitor</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor)</td></tr>
<tr class="memdesc:a80e75ac9be7790069aea67b1638e5ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor locking method.  <a href="#a80e75ac9be7790069aea67b1638e5ccc">More...</a><br /></td></tr>
<tr class="separator:a80e75ac9be7790069aea67b1638e5ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bc44e0bc2d6442b267fd3d9cf81c6e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ad4bc44e0bc2d6442b267fd3d9cf81c6e">exitMonitor</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor)</td></tr>
<tr class="memdesc:ad4bc44e0bc2d6442b267fd3d9cf81c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the acquired monitor giving up the lock that is held and allowing other threads to acquire the monitor.  <a href="#ad4bc44e0bc2d6442b267fd3d9cf81c6e">More...</a><br /></td></tr>
<tr class="separator:ad4bc44e0bc2d6442b267fd3d9cf81c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a0bff599252aa9a0a5a9d7d3fe8ee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a0d9a0bff599252aa9a0a5a9d7d3fe8ee">waitOnMonitor</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor, long long mills, int nanos)</td></tr>
<tr class="memdesc:a0d9a0bff599252aa9a0a5a9d7d3fe8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a monitor to be signaled by another thread.  <a href="#a0d9a0bff599252aa9a0a5a9d7d3fe8ee">More...</a><br /></td></tr>
<tr class="separator:a0d9a0bff599252aa9a0a5a9d7d3fe8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5e46bfefe5f632697bf79241ffbc0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#afd5e46bfefe5f632697bf79241ffbc0b">notifyWaiter</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor)</td></tr>
<tr class="memdesc:afd5e46bfefe5f632697bf79241ffbc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a single waiter on the given Monitor instance, if there is no thread currently waiting on the specified monitor then no action is taken.  <a href="#afd5e46bfefe5f632697bf79241ffbc0b">More...</a><br /></td></tr>
<tr class="separator:afd5e46bfefe5f632697bf79241ffbc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aae4aab571e43256ef5abb00b6933cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a6aae4aab571e43256ef5abb00b6933cc">notifyAllWaiters</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor)</td></tr>
<tr class="memdesc:a6aae4aab571e43256ef5abb00b6933cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all waiting threads for the given Monitor.  <a href="#a6aae4aab571e43256ef5abb00b6933cc">More...</a><br /></td></tr>
<tr class="separator:a6aae4aab571e43256ef5abb00b6933cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2027e7d7f6a06ba42052499498f9e2ec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a2027e7d7f6a06ba42052499498f9e2ec">isMonitorLocked</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *monitor)</td></tr>
<tr class="memdesc:a2027e7d7f6a06ba42052499498f9e2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the monitor object to determine if it is currently locked.  <a href="#a2027e7d7f6a06ba42052499498f9e2ec">More...</a><br /></td></tr>
<tr class="separator:a2027e7d7f6a06ba42052499498f9e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace043d3141ec3b12ff9d82b092e29513"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ace043d3141ec3b12ff9d82b092e29513">createNewThread</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *parant, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name, long long stackSize)</td></tr>
<tr class="memdesc:ace043d3141ec3b12ff9d82b092e29513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread instance with the given Thread object as its parent, assigning it the given name and stack size.  <a href="#ace043d3141ec3b12ff9d82b092e29513">More...</a><br /></td></tr>
<tr class="separator:ace043d3141ec3b12ff9d82b092e29513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8453276f9bc1fbda590c960975b38db7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a8453276f9bc1fbda590c960975b38db7">start</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="memdesc:a8453276f9bc1fbda590c960975b38db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the given thread running, if the thread is already running then this method has no effect.  <a href="#a8453276f9bc1fbda590c960975b38db7">More...</a><br /></td></tr>
<tr class="separator:a8453276f9bc1fbda590c960975b38db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b1a23ec95611cb4daca8e986895f70"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#aa7b1a23ec95611cb4daca8e986895f70">join</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread, long long mills, int nanos)</td></tr>
<tr class="memdesc:aa7b1a23ec95611cb4daca8e986895f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the given thread instance and waits for it to either terminate or for the given timeout period to expire.  <a href="#aa7b1a23ec95611cb4daca8e986895f70">More...</a><br /></td></tr>
<tr class="separator:aa7b1a23ec95611cb4daca8e986895f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0376c605eee46f93d40474834f8e060"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ab0376c605eee46f93d40474834f8e060">interrupt</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:ab0376c605eee46f93d40474834f8e060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe516e05618b38876fe2b97d39328dd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#abbe516e05618b38876fe2b97d39328dd">interrupted</a> ()</td></tr>
<tr class="separator:abbe516e05618b38876fe2b97d39328dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870da060b915e69815e8ea7a8b6f7643"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a870da060b915e69815e8ea7a8b6f7643">isInterrupted</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread, bool reset)</td></tr>
<tr class="separator:a870da060b915e69815e8ea7a8b6f7643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c2577e9af0eb7e9cc2118dec671b30"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#aa3c2577e9af0eb7e9cc2118dec671b30">yeild</a> ()</td></tr>
<tr class="separator:aa3c2577e9af0eb7e9cc2118dec671b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0041a840b7788533af07eaa3198c10b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ac0041a840b7788533af07eaa3198c10b">sleep</a> (long long mills, int nanos)</td></tr>
<tr class="separator:ac0041a840b7788533af07eaa3198c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584cc351ffbe61dab1fb35849cc843ad"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a584cc351ffbe61dab1fb35849cc843ad">getThreadId</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:a584cc351ffbe61dab1fb35849cc843ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac836ba7882719ddac65534fcbcc4805a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ac836ba7882719ddac65534fcbcc4805a">getThreadPriority</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:ac836ba7882719ddac65534fcbcc4805a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bb9aaeb78544947dac4bf1971ff53a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ae6bb9aaeb78544947dac4bf1971ff53a">setThreadPriority</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread, int priority)</td></tr>
<tr class="separator:ae6bb9aaeb78544947dac4bf1971ff53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f94c415a4b323d336fc6373550dd43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ad4f94c415a4b323d336fc6373550dd43">getThreadName</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:ad4f94c415a4b323d336fc6373550dd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a276aaad53d2380afb48dc7678de6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a58a276aaad53d2380afb48dc7678de6a">setThreadName</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="separator:a58a276aaad53d2380afb48dc7678de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f7f03e0e9d8285ed390c84584abc5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1lang_1_1_thread.html#a5ed73b0037b677da2e3e242c5587746b">Thread::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#af3f7f03e0e9d8285ed390c84584abc5e">getThreadState</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:af3f7f03e0e9d8285ed390c84584abc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af958a8633c5006891703e6de2e6fca61"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#af958a8633c5006891703e6de2e6fca61">isThreadAlive</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:af958a8633c5006891703e6de2e6fca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c93daa72c4b8d5662852b2fe505a6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a93c93daa72c4b8d5662852b2fe505a6b">destroyThread</a> (<a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *thread)</td></tr>
<tr class="separator:a93c93daa72c4b8d5662852b2fe505a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac452efd5f5b2d147544e5ae66dd8b564"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ac452efd5f5b2d147544e5ae66dd8b564">createThreadWrapper</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *parent, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="memdesc:ac452efd5f5b2d147544e5ae66dd8b564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> that references the currently running thread.  <a href="#ac452efd5f5b2d147544e5ae66dd8b564">More...</a><br /></td></tr>
<tr class="separator:ac452efd5f5b2d147544e5ae66dd8b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5642866c1f79cd54d0afb04509dcf318"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a5642866c1f79cd54d0afb04509dcf318">getCurrentThread</a> ()</td></tr>
<tr class="separator:a5642866c1f79cd54d0afb04509dcf318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5dc1b987304723435f408c5107f13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a68b5dc1b987304723435f408c5107f13">getCurrentThreadHandle</a> ()</td></tr>
<tr class="separator:a68b5dc1b987304723435f408c5107f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9400f316b130c98fa966417fe3d6c525"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a9400f316b130c98fa966417fe3d6c525">park</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *thread)</td></tr>
<tr class="memdesc:a9400f316b130c98fa966417fe3d6c525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given thread from scheduling unless a call to unpark has already reset the park token in which case this method simple consumes the unpark token and returned.  <a href="#a9400f316b130c98fa966417fe3d6c525">More...</a><br /></td></tr>
<tr class="separator:a9400f316b130c98fa966417fe3d6c525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e3811ec49a137666f3b3161048ad71"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#ad2e3811ec49a137666f3b3161048ad71">park</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *thread, long long mills, int nanos)</td></tr>
<tr class="memdesc:ad2e3811ec49a137666f3b3161048ad71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given thread from scheduling unless a call to unpark has already reset the park token in which case this method simple consumes the unpark token and returned.  <a href="#ad2e3811ec49a137666f3b3161048ad71">More...</a><br /></td></tr>
<tr class="separator:ad2e3811ec49a137666f3b3161048ad71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748ec7a2b10ce5650b8d82187d3ecb38"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a748ec7a2b10ce5650b8d82187d3ecb38">unpark</a> (<a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *thread)</td></tr>
<tr class="memdesc:a748ec7a2b10ce5650b8d82187d3ecb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the target thread is not currently parked then this method sets the un-park token for the thread and returns.  <a href="#a748ec7a2b10ce5650b8d82187d3ecb38">More...</a><br /></td></tr>
<tr class="separator:a748ec7a2b10ce5650b8d82187d3ecb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa0206c5ff2386c013896268c9c094d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#acaa0206c5ff2386c013896268c9c094d">createThreadLocalSlot</a> (<a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> *threadLocal)</td></tr>
<tr class="memdesc:acaa0206c5ff2386c013896268c9c094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a slot in the library for a new <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> to store its values for each thread.  <a href="#acaa0206c5ff2386c013896268c9c094d">More...</a><br /></td></tr>
<tr class="separator:acaa0206c5ff2386c013896268c9c094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e62ecf3a3649ecb755b06d8bbf9cde3"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a7e62ecf3a3649ecb755b06d8bbf9cde3">getThreadLocalValue</a> (int slot)</td></tr>
<tr class="separator:a7e62ecf3a3649ecb755b06d8bbf9cde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc94a881672e6a1292b950393066fc9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a1cc94a881672e6a1292b950393066fc9">setThreadLocalValue</a> (int slot, void *value)</td></tr>
<tr class="separator:a1cc94a881672e6a1292b950393066fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced0cb7e10ca35a631aab349bada429a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#aced0cb7e10ca35a631aab349bada429a">destoryThreadLocalSlot</a> (int slot)</td></tr>
<tr class="separator:aced0cb7e10ca35a631aab349bada429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4953d018e7d1fb89aad2b46d3911c1b4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html#a4953d018e7d1fb89aad2b46d3911c1b4">releaseCurrentThreadHandle</a> ()</td></tr>
<tr class="separator:a4953d018e7d1fb89aad2b46d3911c1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace043d3141ec3b12ff9d82b092e29513"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a>* decaf::internal::util::concurrent::Threading::createNewThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>parant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>stackSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new thread instance with the given Thread object as its parent, assigning it the given name and stack size. </p>
<p>The Thread class provides its own main Runnable for executing task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent Thread object that the new thread is owned by. </td></tr>
    <tr><td class="paramname">name</td><td>Name given to the new Thread, used for debugging purposes. </td></tr>
    <tr><td class="paramname">stackSize</td><td>The size to allocate for the new thread's stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> that identifies the thread and allows the parent to interact with it. </dd></dl>

</div>
</div>
<a class="anchor" id="acaa0206c5ff2386c013896268c9c094d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int decaf::internal::util::concurrent::Threading::createThreadLocalSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> *&#160;</td>
          <td class="paramname"><em>threadLocal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a slot in the library for a new <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> to store its values for each thread. </p>
<p>The parent <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> is stored so that the library can call each <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> to cleanup its resources if there are active objects at the time the library is shutdown or the Thread terminates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadLocal</td><td>The <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a> to assign a storage slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new storage slot Id for the given <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_local_impl.html">ThreadLocalImpl</a>'s value to be assigned. </dd></dl>

</div>
</div>
<a class="anchor" id="ac452efd5f5b2d147544e5ae66dd8b564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a>* decaf::internal::util::concurrent::Threading::createThreadWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">decaf::lang::Thread</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> that references the currently running thread. </p>
<p>This method is called to obtain a <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> that references an thread that was not created using the Decaf Thread class. A parent Thread instance is passed to associate with the target thread so that a call to getCurrentThread can return a Decaf Thread as it would for any thread created using Thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The Decaf thread instace to associate with this thread handle. </td></tr>
    <tr><td class="paramname">name</td><td>The name to assign to the returned <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> instance for the parent Decaf Thread. </dd></dl>

</div>
</div>
<a class="anchor" id="aced0cb7e10ca35a631aab349bada429a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::destoryThreadLocalSlot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93c93daa72c4b8d5662852b2fe505a6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::destroyThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a579247cbb8670d546784d78d590a0160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::dumpRunningThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagnostic method dumps all threads info to console. </p>

</div>
</div>
<a class="anchor" id="a79e26b0003b98c1ad6f189f9369677a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::enterMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monitor locking method. </p>
<p>The calling thread blocks until it acquires the monitor. A thread can enter the same monitor more than once, but must then exit the monitor the same number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>The handle to the monitor that the current thread is attempting to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4bc44e0bc2d6442b267fd3d9cf81c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::exitMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exit the acquired monitor giving up the lock that is held and allowing other threads to acquire the monitor. </p>
<p>If the calling thread has entered the monitor more than once then it must exit that monitor the same number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Handle to the monitor instance that is to be excited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller is not the owner of the monitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5642866c1f79cd54d0afb04509dcf318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a>* decaf::internal::util::concurrent::Threading::getCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the Decaf Thread pointer instance for the currently running thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a68b5dc1b987304723435f408c5107f13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a>* decaf::internal::util::concurrent::Threading::getCurrentThreadHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> instance for the currently running thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a584cc351ffbe61dab1fb35849cc843ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long long decaf::internal::util::concurrent::Threading::getThreadId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e62ecf3a3649ecb755b06d8bbf9cde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* decaf::internal::util::concurrent::Threading::getThreadLocalValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4f94c415a4b323d336fc6373550dd43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char* decaf::internal::util::concurrent::Threading::getThreadName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac836ba7882719ddac65534fcbcc4805a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int decaf::internal::util::concurrent::Threading::getThreadPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af3f7f03e0e9d8285ed390c84584abc5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1lang_1_1_thread.html#a5ed73b0037b677da2e3e242c5587746b">Thread::State</a> decaf::internal::util::concurrent::Threading::getThreadState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5236193df8c51ceb0256ccd385b8c064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the Decaf Runtime at startup to allow the Platform <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> code to initialize any necessary <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> constructs needed to support the features of this class. </p>

</div>
</div>
<a class="anchor" id="ab0376c605eee46f93d40474834f8e060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbe516e05618b38876fe2b97d39328dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::interrupted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a870da060b915e69815e8ea7a8b6f7643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::isInterrupted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2027e7d7f6a06ba42052499498f9e2ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::isMonitorLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the monitor object to determine if it is currently locked. </p>
<p>This method is a mainly a diagnostic tool and its return value is not guaranteed to reflect the locked state after its been called as the state can change quickly. </p>

</div>
</div>
<a class="anchor" id="af958a8633c5006891703e6de2e6fca61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::isThreadAlive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7b1a23ec95611cb4daca8e986895f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>mills</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins the given thread instance and waits for it to either terminate or for the given timeout period to expire. </p>
<p>If the value of of the timeout is zero then this method waits forever.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread to join. </td></tr>
    <tr><td class="paramname">mills</td><td>The number of milliseconds to wait. </td></tr>
    <tr><td class="paramname">nanos</td><td>The number of nanoseconds to wait [0-999999].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timeout period expired, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the Join was interrupted. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the value of mills or nanos is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a044b09793604176e27befced944b56f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::lockThreadsLib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library allowing an object to perform some operations safely in a multi-threaded environment. </p>

</div>
</div>
<a class="anchor" id="a6aae4aab571e43256ef5abb00b6933cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::notifyAllWaiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies all waiting threads for the given Monitor. </p>
<p>If there are no threads currently waiting on the given monitor instance then no action is taken. The calling thread must own the given monitor otherwise an IllegalMonitorStateException is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>The monitor handle that is to have all of its waiting thread signaled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not own the monitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd5e46bfefe5f632697bf79241ffbc0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::notifyWaiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify a single waiter on the given Monitor instance, if there is no thread currently waiting on the specified monitor then no action is taken. </p>
<p>The calling thread must own the given monitor otherwise an IllegalMonitorStateException is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>The monitor handle that is to have a single waiting thread signaled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not own the monitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9400f316b130c98fa966417fe3d6c525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::park </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given thread from scheduling unless a call to unpark has already reset the park token in which case this method simple consumes the unpark token and returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread to park. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2e3811ec49a137666f3b3161048ad71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::park </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>mills</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given thread from scheduling unless a call to unpark has already reset the park token in which case this method simple consumes the unpark token and returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread to park. </td></tr>
    <tr><td class="paramname">mills</td><td>The time in milliseconds to park the target thread. </td></tr>
    <tr><td class="paramname">nanos</td><td>The additional time in nanoseconds to park the target thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4953d018e7d1fb89aad2b46d3911c1b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::releaseCurrentThreadHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af55fb0ec9b90367513f4a840333b88d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::returnMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alreadyLocked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a given monitor to the Monitor pool after the Monitor is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>The handle of the Monitor to return to the Monitor pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the monitor is in use when returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cc94a881672e6a1292b950393066fc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::setThreadLocalValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58a276aaad53d2380afb48dc7678de6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::setThreadName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6bb9aaeb78544947dac4bf1971ff53a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::setThreadPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa290220e82eb5bf9badfc5e6d699b8b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the Decaf Runtime at Shutdown to allow the Platform <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> code to return any resources that were allocated at startup for the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library. </p>

</div>
</div>
<a class="anchor" id="ac0041a840b7788533af07eaa3198c10b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::sleep </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>mills</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8453276f9bc1fbda590c960975b38db7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the given thread running, if the thread is already running then this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread instance to start. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add89aa666968f0e2246cb52c2c7ce8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a>* decaf::internal::util::concurrent::Threading::takeMonitor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alreadyLocked</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a monitor for use as a locking mechanism. </p>
<p>The monitor returned will be initialized and ready for use. Each monitor that is taken must be returned before the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library is shutdown.</p>
<dl class="section return"><dt>Returns</dt><dd>handle to a Monitor instance that has been initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="a80e75ac9be7790069aea67b1638e5ccc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::tryEnterMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monitor locking method. </p>
<p>If the calling thread cannot immediately acquire the lock on the monitor then this method returns false, otherwise the thread gains the lock on the monitor and the method returns true. A thread can enter a monitor multiple times, but must ensure that it exits the monitor the same number of times that it entered it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>The handle to the monitor that the current thread is attempting to lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the caller obtains the lock on the Monitor, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab513346c21ec8a96e554561acea458ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::unlockThreadsLib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the <a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a> library when locked. </p>

</div>
</div>
<a class="anchor" id="a748ec7a2b10ce5650b8d82187d3ecb38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::unpark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1lang_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the target thread is not currently parked then this method sets the un-park token for the thread and returns. </p>
<p>If the thread is parked than this method places the thread back in a state where it can be scheduled once more.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to unpark. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d9a0bff599252aa9a0a5a9d7d3fe8ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool decaf::internal::util::concurrent::Threading::waitOnMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdecaf_1_1internal_1_1util_1_1concurrent_1_1_monitor_handle.html">MonitorHandle</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>mills</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits on a monitor to be signaled by another thread. </p>
<p>The caller can wait for a given timeout or pass zero for both mills and nanos to indicate it wants to wait forever. If the caller specifies a timeout and that timeout expires before the monitor is signaled this method returns true. The calling thread must own the monitor in order to call this method, otherwise an IllegalMonitorStateException is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>Handle to the monitor that the calling thread is to wait on for a signal. </td></tr>
    <tr><td class="paramname">mills</td><td>The time in milliseconds to wait for the monitor to be signaled. </td></tr>
    <tr><td class="paramname">nanos</td><td>The time in nanoseconds to wait for the monitor to be signaled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timeout given expires before the caller was signaled.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the caller does not own the monitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3c2577e9af0eb7e9cc2118dec671b30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void decaf::internal::util::concurrent::Threading::yeild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/util/concurrent/<a class="el" href="_threading_8h_source.html">Threading.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1util_1_1concurrent.html">concurrent</a></li><li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1util_1_1concurrent_1_1_threading.html">Threading</a></li>
    <li class="footer">Generated on Sun Aug 16 2015 17:10:37 for activemq-cpp-3.9.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
