<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::concurrent::CopyOnWriteArraySet" --><!-- doxytag: inherits="decaf::util::AbstractSet" -->
<p>Since the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html" title="Since the CopyOnWriteArraySet and the CopyOnWriteArrayList share much of the same operational semanti...">CopyOnWriteArraySet</a> and the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> share much of the same operational semantics this class uses the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> for all its underlying operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_copy_on_write_array_set_8h_source.html">src/main/decaf/util/concurrent/CopyOnWriteArraySet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set_3_01_e_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set_3_01_e_01_4_inherit__map" id="decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set_3_01_e_01_4_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1_abstract_set.html" title="This class provides a skeletal implementation of the Set interface to minimize the effort required to..." alt="" coords="125,237,347,267"/><area shape="rect" id="node4" href="classdecaf_1_1util_1_1_set.html" title="A collection that contains no duplicate elements." alt="" coords="36,160,199,189"/><area shape="rect" id="node6" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy." alt="" coords="133,83,339,112"/><area shape="rect" id="node12" href="classdecaf_1_1util_1_1_abstract_collection.html" title="This class provides a skeletal implementation of the Collection interface, to minimize the effort req..." alt="" coords="223,160,489,189"/><area shape="rect" id="node8" href="classdecaf_1_1lang_1_1_iterable.html" title="Implementing this interface allows an object to be cast to an Iterable type for generic collections A..." alt="" coords="5,5,203,35"/><area shape="rect" id="node10" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="227,5,512,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a41190a84ed18ff7ea6b4bde7a0241898">CopyOnWriteArraySet</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#aa053b9f92e0fc71ad56f5a66c7ebfa30">CopyOnWriteArraySet</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a5ed55f1e353ec8d9cb19b7f5b83b6bc8">CopyOnWriteArraySet</a> (const E *array, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a215735072a9a11cc64c3f1cbed229210">~CopyOnWriteArraySet</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#abec887380bd2cd5d05c9ff9d50d6de23">copy</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> as a Copy of the given <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.  <a href="#abec887380bd2cd5d05c9ff9d50d6de23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#ae1972947879543860f82c87feecd389b">iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a62b5bf261f7ba2f098e0ea697905d5e6">iterator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a07a3ade259949bc5ea2c1cda57d045aa">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this collection.  <a href="#a07a3ade259949bc5ea2c1cda57d045aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a326d74eabc05a8d4e669412a4f67020e">isEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains no elements.  <a href="#a326d74eabc05a8d4e669412a4f67020e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#aa8ba2945a8493c665867c3febdb63e51">add</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection changed as a result of the call.  <a href="#aa8ba2945a8493c665867c3febdb63e51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a0beb959964fed733d33aef543b651c06">addAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all of the elements in the specified collection to this collection.The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are added to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this collection changed as a result of the call</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of an element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if an element cannot be added at this time due to insertion restrictions.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the specified collection, and adds each object returned by the iterator to this collection, in turn.Note that this implementation will throw an UnsupportedOperationException unless add is overridden (assuming the specified collection is non-empty).  <a href="#a0beb959964fed733d33aef543b651c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#af461747cf9a54733ad04677ecc53bc00">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the elements from this collection (optional operation).  <a href="#af461747cf9a54733ad04677ecc53bc00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a9908b641e34181430b5148cbe430772b">contains</a> (const E &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains the specified element.More formally, returns true if and only if this collection contains at least one element e such that (value == NULL ? e == NULL : value == e ).<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check for presence in the collection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is at least one of the elements in the collection</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check).</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the elements in the collection, checking each element in turn for equality with the specified element.  <a href="#a9908b641e34181430b5148cbe430772b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#ab91a7ae37f7d761ffec439f058acef33">containsAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains all of the elements in the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to compare to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check).</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false.  <a href="#ab91a7ae37f7d761ffec439f058acef33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a3de44658bf6056a67a09810729ac71b8">remove</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single instance of the specified element from the collection.More formally, removes an element e such that (value == NULL ? e == NULL : value == e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to remove from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection was changed, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method.Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object.  <a href="#a3de44658bf6056a67a09810729ac71b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#ab78c852afe910b5102acd7e96967ebac">removeAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all this collection's elements that are also contained in the specified collection (optional operation).After this call returns, this collection will contain no elements in common with the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be removed from this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's so contained, it's removed from this collection with the iterator's remove method.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements in common with the specified collection.This implementation determines which is the smaller of this set and the specified collection, by invoking the size method on each. If this set has fewer elements, then the implementation iterates over this set, checking each element returned by the iterator in turn to see if it is contained in the specified collection. If it is so contained, it is removed from this set with the iterator's remove method. If the specified collection has fewer elements, then the implementation iterates over the specified collection, removing from this set each element returned by the iterator, using this set's remove method.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method.  <a href="#ab78c852afe910b5102acd7e96967ebac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a93b82f90ad2e09cd2eecdf693cf1883a">retainAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains only the elements in this collection that are contained in the specified collection (optional operation).In other words, removes from this collection all of its elements that are not contained in the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be retained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's not so contained, it's removed from this collection with the iterator's remove method.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements not present in the specified collection.  <a href="#a93b82f90ad2e09cd2eecdf693cf1883a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#ac25ce2da691bb41f8bdebfef8767c5eb">toArray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers an STL vector containing copies of all elements contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.  <a href="#ac25ce2da691bb41f8bdebfef8767c5eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a64643423c8dc5b9ebeceeddedc3a27b2">equals</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers true if this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> and the one given are the same size and if each element contained in the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> given is equal to an element contained in this collection.  <a href="#a64643423c8dc5b9ebeceeddedc3a27b2"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename E&gt;<br/>
 class decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;</h3>

<p>Since the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html" title="Since the CopyOnWriteArraySet and the CopyOnWriteArrayList share much of the same operational semanti...">CopyOnWriteArraySet</a> and the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> share much of the same operational semantics this class uses the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> for all its underlying operations. </p>
<p>This collection is best used in applications where the <a class="el" href="classdecaf_1_1util_1_1_set.html" title="A collection that contains no duplicate elements.">Set</a> size is usually small and write operations are minimal as they result in a copy of the underlying array being created. Reads are generally fast and the iterators provided by this collection do not block as they operate on a snapshot of the data taken at the time of their creation.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a41190a84ed18ff7ea6b4bde7a0241898"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::CopyOnWriteArraySet" ref="a41190a84ed18ff7ea6b4bde7a0241898" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">CopyOnWriteArraySet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa053b9f92e0fc71ad56f5a66c7ebfa30"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::CopyOnWriteArraySet" ref="aa053b9f92e0fc71ad56f5a66c7ebfa30" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">CopyOnWriteArraySet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#abec887380bd2cd5d05c9ff9d50d6de23">decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ed55f1e353ec8d9cb19b7f5b83b6bc8"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::CopyOnWriteArraySet" ref="a5ed55f1e353ec8d9cb19b7f5b83b6bc8" args="(const E *array, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">CopyOnWriteArraySet</a> </td>
          <td>(</td>
          <td class="paramtype">const E *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a07a3ade259949bc5ea2c1cda57d045aa">decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a215735072a9a11cc64c3f1cbed229210"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::~CopyOnWriteArraySet" ref="a215735072a9a11cc64c3f1cbed229210" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::~<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">CopyOnWriteArraySet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa8ba2945a8493c665867c3febdb63e51"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::add" ref="aa8ba2945a8493c665867c3febdb63e51" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection changed as a result of the call. </p>
<p>(Returns false if this collection does not permit duplicates and already contains the specified element.)</p>
<p>Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> classes should clearly specify in their documentation any restrictions on what elements may be added.</p>
<p>If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.</p>
<p>For non-pointer values, i.e. class instances or string's the object will be copied into the collection, thus the object must support being copied, must not hide the copy constructor and assignment operator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to add to this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the element was added to this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the element cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a3b1fb8d6d75a6a8de1096e2af59c93b7">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0beb959964fed733d33aef543b651c06"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::addAll" ref="a0beb959964fed733d33aef543b651c06" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::addAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds all of the elements in the specified collection to this collection.The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are added to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this collection changed as a result of the call</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of an element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if an element cannot be added at this time due to insertion restrictions.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the specified collection, and adds each object returned by the iterator to this collection, in turn.Note that this implementation will throw an UnsupportedOperationException unless add is overridden (assuming the specified collection is non-empty). </p>
<p>This implementation iterates over the specified collection, and adds each object returned by the iterator to this collection, in turn.</p>
<p>Note that this implementation will throw an UnsupportedOperationException unless add is overridden (assuming the specified collection is non-empty). </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#acadd931b12f360bbd50b760d83ab865e">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af461747cf9a54733ad04677ecc53bc00"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::clear" ref="af461747cf9a54733ad04677ecc53bc00" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all of the elements from this collection (optional operation). </p>
<p>The collection will be empty after this method returns.</p>
<p>This implementation iterates over this collection, removing each element using the <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">Iterator.remove</a> operation. Most implementations will probably choose to override this method for efficiency.</p>
<p>Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the clear operation is not supported by this collection </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#af2675df16b822ac2ba7868b927e80f5b">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9908b641e34181430b5148cbe430772b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::contains" ref="a9908b641e34181430b5148cbe430772b" args="(const E &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains the specified element.More formally, returns true if and only if this collection contains at least one element e such that (value == NULL ? e == NULL : value == e ).<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check for presence in the collection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is at least one of the elements in the collection</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check).</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the elements in the collection, checking each element in turn for equality with the specified element. </p>
<p>This implementation iterates over the elements in the collection, checking each element in turn for equality with the specified element. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#aa07825c6958724499129a10d65e7e870">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab91a7ae37f7d761ffec439f058acef33"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::containsAll" ref="ab91a7ae37f7d761ffec439f058acef33" args="(const Collection&lt; E &gt; &amp;collection) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::containsAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains all of the elements in the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to compare to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check).</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false. </p>
<p>This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#ae9f003bc1db10e347afa595979fc4c05">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abec887380bd2cd5d05c9ff9d50d6de23"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::copy" ref="abec887380bd2cd5d05c9ff9d50d6de23" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renders this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> as a Copy of the given <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>. </p>
<p>The default implementation iterates over the contents of the given collection adding each to this collection after first calling this Collection's clear method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection to mirror.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the elements cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a71b1212b02bf74cb3b99b8cac85206f6">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#aa053b9f92e0fc71ad56f5a66c7ebfa30">decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;::CopyOnWriteArraySet()</a>.</p>

</div>
</div>
<a class="anchor" id="a64643423c8dc5b9ebeceeddedc3a27b2"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::equals" ref="a64643423c8dc5b9ebeceeddedc3a27b2" args="(const Collection&lt; E &gt; &amp;collection) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Answers true if this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> and the one given are the same size and if each element contained in the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> given is equal to an element contained in this collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>- The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to be compared to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is equal to the one given. </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a894957e0b25c2e644768d7a4bc7a9fe3">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a1bf9dd78d7826b61fb59901e29d59857">decaf::lang::Iterable&lt; E &gt;::iterator()</a>, <a class="el" href="classdecaf_1_1util_1_1_collection.html#aad34433902f20bd422f64b14f51998cf">decaf::util::Collection&lt; E &gt;::size()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a07a3ade259949bc5ea2c1cda57d045aa">decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a326d74eabc05a8d4e669412a4f67020e"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::isEmpty" ref="a326d74eabc05a8d4e669412a4f67020e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains no elements. </p>
<p>This implementation returns <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a07a3ade259949bc5ea2c1cda57d045aa" title="Returns the number of elements in this collection.">size()</a> == 0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the size method return 0. </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#adff8de8d2b0f370696265aab914df735">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae1972947879543860f82c87feecd389b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::iterator" ref="ae1972947879543860f82c87feecd389b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator over a set of elements of type T. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a1bf9dd78d7826b61fb59901e29d59857">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a62b5bf261f7ba2f098e0ea697905d5e6"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::iterator" ref="a62b5bf261f7ba2f098e0ea697905d5e6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a8df8d3e4976a76be399adea077c4edb2">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3de44658bf6056a67a09810729ac71b8"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::remove" ref="a3de44658bf6056a67a09810729ac71b8" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a single instance of the specified element from the collection.More formally, removes an element e such that (value == NULL ? e == NULL : value == e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to remove from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection was changed, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method.Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object. </p>
<p>This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method.</p>
<p>Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a6eca5f5f78ac51a1b614da00c7ad2504">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab78c852afe910b5102acd7e96967ebac"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::removeAll" ref="ab78c852afe910b5102acd7e96967ebac" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all this collection's elements that are also contained in the specified collection (optional operation).After this call returns, this collection will contain no elements in common with the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be removed from this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's so contained, it's removed from this collection with the iterator's remove method.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements in common with the specified collection.This implementation determines which is the smaller of this set and the specified collection, by invoking the size method on each. If this set has fewer elements, then the implementation iterates over this set, checking each element returned by the iterator in turn to see if it is contained in the specified collection. If it is so contained, it is removed from this set with the iterator's remove method. If the specified collection has fewer elements, then the implementation iterates over the specified collection, removing from this set each element returned by the iterator, using this set's remove method.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method. </p>
<p>This implementation determines which is the smaller of this set and the specified collection, by invoking the size method on each. If this set has fewer elements, then the implementation iterates over this set, checking each element returned by the iterator in turn to see if it is contained in the specified collection. If it is so contained, it is removed from this set with the iterator's remove method. If the specified collection has fewer elements, then the implementation iterates over the specified collection, removing from this set each element returned by the iterator, using this set's remove method.</p>
<p>Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_set.html#afe154183f20853e5c312436ff88ce63c">decaf::util::AbstractSet&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a93b82f90ad2e09cd2eecdf693cf1883a"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::retainAll" ref="a93b82f90ad2e09cd2eecdf693cf1883a" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::retainAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retains only the elements in this collection that are contained in the specified collection (optional operation).In other words, removes from this collection all of its elements that are not contained in the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be retained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's not so contained, it's removed from this collection with the iterator's remove method.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements not present in the specified collection. </p>
<p>This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's not so contained, it's removed from this collection with the iterator's remove method.</p>
<p>Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements not present in the specified collection. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#aa13a20cde33444038e6765c00d6174fa">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a07a3ade259949bc5ea2c1cda57d045aa"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::size" ref="a07a3ade259949bc5ea2c1cda57d045aa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of elements in this collection. </p>
<p>If this collection contains more than Integer::MAX_VALUE elements, returns Integer::MAX_VALUE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements in this collection </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#aad34433902f20bd422f64b14f51998cf">decaf::util::Collection&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a5ed55f1e353ec8d9cb19b7f5b83b6bc8">decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;::CopyOnWriteArraySet()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html#a64643423c8dc5b9ebeceeddedc3a27b2">decaf::util::concurrent::CopyOnWriteArraySet&lt; E &gt;::equals()</a>.</p>

</div>
</div>
<a class="anchor" id="ac25ce2da691bb41f8bdebfef8767c5eb"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArraySet::toArray" ref="ac25ce2da691bb41f8bdebfef8767c5eb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;E&gt; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">decaf::util::concurrent::CopyOnWriteArraySet</a>&lt; E &gt;::toArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Answers an STL vector containing copies of all elements contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>. </p>
<p>All the elements in the array will not be referenced by the collection. The elements in the returned array will be sorted to the same order as those returned by the iterator of this collection itself if the collection guarantees the order.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an vector of copies of all the elements from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a167776fb00a8924828424616e3b6f3b8">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/<a class="el" href="_copy_on_write_array_set_8h_source.html">CopyOnWriteArraySet.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">CopyOnWriteArraySet</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
