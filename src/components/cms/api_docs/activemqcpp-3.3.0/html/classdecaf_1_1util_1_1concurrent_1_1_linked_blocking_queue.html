<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::concurrent::LinkedBlockingQueue" --><!-- doxytag: inherits="decaf::util::concurrent::BlockingQueue" -->
<p>A <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html" title="A decaf::util::Queue that additionally supports operations that wait for the queue to become non-empt...">BlockingQueue</a> derivative that allows for a bound to be placed on the number of elements that can be enqueued at any one time.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_linked_blocking_queue_8h_source.html">src/main/decaf/util/concurrent/LinkedBlockingQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1_linked_blocking_queue_3_01_e_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1_linked_blocking_queue_3_01_e_01_4_inherit__map" id="decaf_1_1util_1_1concurrent_1_1_linked_blocking_queue_3_01_e_01_4_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html" title="A decaf::util::Queue that additionally supports operations that wait for the queue to become non&#45;empt..." alt="" coords="75,315,397,344"/><area shape="rect" id="node4" href="classdecaf_1_1util_1_1_abstract_queue.html" title="This class provides skeletal implementations of some Queue operations." alt="" coords="115,237,357,267"/><area shape="rect" id="node6" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion..." alt="" coords="20,160,204,189"/><area shape="rect" id="node8" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy." alt="" coords="133,83,339,112"/><area shape="rect" id="node14" href="classdecaf_1_1util_1_1_abstract_collection.html" title="This class provides a skeletal implementation of the Collection interface, to minimize the effort req..." alt="" coords="228,160,495,189"/><area shape="rect" id="node10" href="classdecaf_1_1lang_1_1_iterable.html" title="Implementing this interface allows an object to be cast to an Iterable type for generic collections A..." alt="" coords="5,5,203,35"/><area shape="rect" id="node12" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="227,5,512,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ConstLinkedIterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>LinkedIterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>QueueNode</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>TotalLock</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a9828967c8162b135d154e4f682cd2117">LinkedBlockingQueue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance with a Capacity of Integer::MAX_VALUE.  <a href="#a9828967c8162b135d154e4f682cd2117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#af2d289fec5de0dcde1457d95f982d9ae">LinkedBlockingQueue</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance with the given initial capacity value.  <a href="#af2d289fec5de0dcde1457d95f982d9ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a94cd2c705a4807b1f85dce9648a106c8">LinkedBlockingQueue</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance with a Capacity of Integer::MAX_VALUE and adds all the values contained in the specified collection to this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.  <a href="#a94cd2c705a4807b1f85dce9648a106c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a3238a082bbf502b41063e41aa80c2443">~LinkedBlockingQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>&lt; E &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a43d181ce0eae63261b67cfd4e8c56ae6">operator=</a> (const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>&lt; E &gt; &amp;queue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>&lt; E &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#af1dc69714227eb3fbb4605d158c916ea">operator=</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a9cf79717dd4ae017ac43b3ef15a53fa7">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this collection.  <a href="#a9cf79717dd4ae017ac43b3ef15a53fa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0774d018b4a047a2a1313288b2f652a8">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the elements from this collection (optional operation).The collection will be empty after this method returns.This implementation iterates over this collection, removing each element using the <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">Iterator.remove</a> operation. Most implementations will probably choose to override this method for efficiency.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the clear operation is not supported by this collection</td></tr>
  </table>
  </dd>
</dl>
This implementation repeatedly invokes poll until it returns false.  <a href="#a0774d018b4a047a2a1313288b2f652a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#adc88b63df8328266fe89256ed1916d7a">remainingCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or <code>Integer::MAX_VALUE</code> if there is no intrinsic limit.  <a href="#adc88b63df8328266fe89256ed1916d7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0a2bfa035134ecf04b747923fb9184c7">put</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element into this queue, waiting if necessary for space to become available.  <a href="#a0a2bfa035134ecf04b747923fb9184c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#acc422303761c38f07b340cdc341d7149">offer</a> (const E &amp;value, long long timeout, const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.  <a href="#acc422303761c38f07b340cdc341d7149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a4df0996f939c963cc2630a6c2b9b2d7b">offer</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element into the queue provided that the condition allows such an operation.  <a href="#a4df0996f939c963cc2630a6c2b9b2d7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a093b20a55f62e3e8cf4f81b1b9a4e5b1">take</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.  <a href="#a093b20a55f62e3e8cf4f81b1b9a4e5b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#aa16b86e58825b1cd7ac1092e35f439ac">poll</a> (E &amp;result, long long timeout, const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.  <a href="#aa16b86e58825b1cd7ac1092e35f439ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#add7b6b2a858723678588561b7d594357">poll</a> (E &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets and removes the element in the head of the queue.  <a href="#add7b6b2a858723678588561b7d594357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a6553c7d97144fb9f5205e5c666aa05e1">peek</a> (E &amp;result) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets but not removes the element in the head of the queue.  <a href="#a6553c7d97144fb9f5205e5c666aa05e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a53e108239a958fd521471a2ecd2592d4">remove</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single instance of the specified element from the collection.More formally, removes an element e such that (value == NULL ? e == NULL : value == e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to remove from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection was changed, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method.Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object.  <a href="#a53e108239a958fd521471a2ecd2592d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0ba5173be192b3af20b42c826b152d42">toArray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers an STL vector containing copies of all elements contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.  <a href="#a0ba5173be192b3af20b42c826b152d42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#accc88eef146544abd79dff948a74be3a">toString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#af77f62ab4a4a83c391c5d87aef904e6c">drainTo</a> (<a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all available elements from this queue and adds them to the given collection.  <a href="#af77f62ab4a4a83c391c5d87aef904e6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a24ddcddd07320e59f5726567f857cacc">drainTo</a> (<a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;sink, int maxElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes at most the given number of available elements from this queue and adds them to the given collection.  <a href="#a24ddcddd07320e59f5726567f857cacc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#aff9f0373f9fa68e60922756378f92280">iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0351e0d76db8e8ee945a416ea8a9811d">iterator</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename E&gt;<br/>
 class decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;</h3>

<p>A <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html" title="A decaf::util::Queue that additionally supports operations that wait for the queue to become non-empt...">BlockingQueue</a> derivative that allows for a bound to be placed on the number of elements that can be enqueued at any one time. </p>
<p>Elements are inserted and removed in FIFO order. The internal structure of the queue is based on a linked nodes which provides for better performance over their array based versions but the performance is less predictable.</p>
<p>The capacity bound of this class default to Integer::MAX_VALUE.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9828967c8162b135d154e4f682cd2117"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::LinkedBlockingQueue" ref="a9828967c8162b135d154e4f682cd2117" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new instance with a Capacity of Integer::MAX_VALUE. </p>

</div>
</div>
<a class="anchor" id="af2d289fec5de0dcde1457d95f982d9ae"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::LinkedBlockingQueue" ref="af2d289fec5de0dcde1457d95f982d9ae" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new instance with the given initial capacity value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The initial capacity value to assign to this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the specified capacity is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94cd2c705a4807b1f85dce9648a106c8"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::LinkedBlockingQueue" ref="a94cd2c705a4807b1f85dce9648a106c8" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new instance with a Capacity of Integer::MAX_VALUE and adds all the values contained in the specified collection to this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be copied to this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the number of elements in the collection exceeds this Queue's capacity. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="decaf_2lang_2exceptions_2_exception_defines_8h.html#aef411e279ba1dc76b0017d1d21fb17c0">DECAF_CATCH_RETHROW</a>, <a class="el" href="decaf_2lang_2exceptions_2_exception_defines_8h.html#afc53e79a95ec71cf378af8b429c66ebf">DECAF_CATCHALL_THROW</a>, and <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a1bf9dd78d7826b61fb59901e29d59857">decaf::lang::Iterable&lt; E &gt;::iterator()</a>.</p>

</div>
</div>
<a class="anchor" id="a3238a082bbf502b41063e41aa80c2443"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::~LinkedBlockingQueue" ref="a3238a082bbf502b41063e41aa80c2443" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::~<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0774d018b4a047a2a1313288b2f652a8"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::clear" ref="a0774d018b4a047a2a1313288b2f652a8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all of the elements from this collection (optional operation).The collection will be empty after this method returns.This implementation iterates over this collection, removing each element using the <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">Iterator.remove</a> operation. Most implementations will probably choose to override this method for efficiency.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the clear operation is not supported by this collection</td></tr>
  </table>
  </dd>
</dl>
This implementation repeatedly invokes poll until it returns false. </p>
<p>This implementation repeatedly invokes poll until it returns false. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_queue.html#aad23c7d39e8189aacada830a171f59be">decaf::util::AbstractQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a28abdc0c8d6b9201be7a5ef04dc17c54">decaf::util::concurrent::atomic::AtomicInteger::getAndSet()</a>, <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a58b06349287bdd9cbf2f84aa7dcff7ba">decaf::util::AbstractCollection&lt; E &gt;::lock()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aff1296d3e571dbaf386c52e7022c268d">decaf::util::concurrent::atomic::AtomicInteger::set()</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a43d181ce0eae63261b67cfd4e8c56ae6">decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="af77f62ab4a4a83c391c5d87aef904e6c"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::drainTo" ref="af77f62ab4a4a83c391c5d87aef904e6c" args="(Collection&lt; E &gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::drainTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all available elements from this queue and adds them to the given collection. </p>
<p>This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection <code>c</code> may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in <code>IllegalArgumentException</code>. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the collection to transfer elements into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements transferred </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if addition of elements is not supported by the specified collection </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the specified collection is this queue, or some property of an element of this queue prevents it from being added to the specified collection </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#ae296a4cdb0aa17b1255d5bfbd1915549">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1lang_1_1_integer.html#a8f7626627f8935280ab1d0a0c38d69cb">decaf::lang::Integer::MAX_VALUE</a>.</p>

</div>
</div>
<a class="anchor" id="a24ddcddd07320e59f5726567f857cacc"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::drainTo" ref="a24ddcddd07320e59f5726567f857cacc" args="(Collection&lt; E &gt; &amp;sink, int maxElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::drainTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes at most the given number of available elements from this queue and adds them to the given collection. </p>
<p>A failure encountered while attempting to add elements to collection <code>c</code> may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in <code>IllegalArgumentException</code>. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the collection to transfer elements into </td></tr>
    <tr><td class="paramname">maxElements</td><td>the maximum number of elements to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements transferred </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if addition of elements is not supported by the specified collection </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the specified collection is this queue, or some property of an element of this queue prevents it from being added to the specified collection </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#a02de5b804a7128865d178459c7e8a3ca">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1_collection.html#a3b1fb8d6d75a6a8de1096e2af59c93b7">decaf::util::Collection&lt; E &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a4de947534e9c457b9c17db3fbbccaaf0">decaf::util::concurrent::atomic::AtomicInteger::getAndAdd()</a>, and <a class="el" href="classdecaf_1_1lang_1_1_math.html#a4af44b77c0bbbe6ab4dd8012f4886416">decaf::lang::Math::min()</a>.</p>

</div>
</div>
<a class="anchor" id="a0351e0d76db8e8ee945a416ea8a9811d"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::iterator" ref="a0351e0d76db8e8ee945a416ea8a9811d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a8df8d3e4976a76be399adea077c4edb2">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aff9f0373f9fa68e60922756378f92280"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::iterator" ref="aff9f0373f9fa68e60922756378f92280" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator over a set of elements of type T. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a1bf9dd78d7826b61fb59901e29d59857">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4df0996f939c963cc2630a6c2b9b2d7b"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::offer" ref="a4df0996f939c963cc2630a6c2b9b2d7b" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::offer </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element into the queue provided that the condition allows such an operation. </p>
<p>The method is generally preferable to the collection.add(E), since the latter might throw an exception if the operation fails.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the specified element to insert into the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the operation succeeds and false if it fails.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> implementation does not allow Null values to be inserted into the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the specified element prevents it from being added to this queue </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_queue.html#af66759e10a969e7aa99f217efefe33af">decaf::util::Queue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aaf5c37d20cc98a71b9880f3e76e792dc">decaf::util::concurrent::atomic::AtomicInteger::getAndIncrement()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>.</p>

</div>
</div>
<a class="anchor" id="acc422303761c38f07b340cdc341d7149"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::offer" ref="acc422303761c38f07b340cdc341d7149" args="(const E &amp;value, long long timeout, const TimeUnit &amp;unit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::offer </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the element to add </td></tr>
    <tr><td class="paramname">timeout</td><td>how long to wait before giving up, in units of <code>unit</code> </td></tr>
    <tr><td class="paramname">unit</td><td>a <code><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html" title="A TimeUnit represents time durations at a given unit of granularity and provides utility methods to c...">TimeUnit</a></code> determining how to interpret the <code>timeout</code> parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if successful, or <code>false</code> if the specified waiting time elapses before space is available</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if interrupted while waiting </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the specified element is null </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the specified element prevents it from being added to this queue </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#a13c30e5dc2e330e7e0ecba7bac0d4d1c">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aaf5c37d20cc98a71b9880f3e76e792dc">decaf::util::concurrent::atomic::AtomicInteger::getAndIncrement()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html#a89571672976824c5aba054d00dbc3984">decaf::util::concurrent::TimeUnit::toMillis()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<a class="anchor" id="af1dc69714227eb3fbb4605d158c916ea"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::operator=" ref="af1dc69714227eb3fbb4605d158c916ea" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>&lt;E&gt;&amp; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classdecaf_1_1util_1_1_abstract_queue.html#a4bb591c5a54ecf52a665ae0583f56c0b">decaf::util::AbstractQueue&lt; E &gt;::addAll()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0774d018b4a047a2a1313288b2f652a8">decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a43d181ce0eae63261b67cfd4e8c56ae6"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::operator=" ref="a43d181ce0eae63261b67cfd4e8c56ae6" args="(const LinkedBlockingQueue&lt; E &gt; &amp;queue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>&lt;E&gt;&amp; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classdecaf_1_1util_1_1_abstract_queue.html#a4bb591c5a54ecf52a665ae0583f56c0b">decaf::util::AbstractQueue&lt; E &gt;::addAll()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0774d018b4a047a2a1313288b2f652a8">decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a6553c7d97144fb9f5205e5c666aa05e1"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::peek" ref="a6553c7d97144fb9f5205e5c666aa05e1" args="(E &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets but not removes the element in the head of the queue. </p>
<p>The result if successful is assigned to the result parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Reference to an instance of the contained type to assigned the removed value to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the element at the head of the queue was removed and assigned to the result parameter. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_queue.html#a35c29d0f7a27e0bce583492dd90e5084">decaf::util::Queue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1lang_1_1_pointer.html#a5833de119c2b224563e2730cfb9c06e7">decaf::lang::Pointer&lt; T, REFCOUNTER &gt;::get()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>.</p>

</div>
</div>
<a class="anchor" id="aa16b86e58825b1cd7ac1092e35f439ac"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::poll" ref="aa16b86e58825b1cd7ac1092e35f439ac" args="(E &amp;result, long long timeout, const TimeUnit &amp;unit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::poll </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the referenced value that will be assigned the value retrieved from the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>. Undefined if this methods returned false. </td></tr>
    <tr><td class="paramname">timeout</td><td>how long to wait before giving up, in units of <code>unit</code> </td></tr>
    <tr><td class="paramname">unit</td><td>a <code><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html" title="A TimeUnit represents time durations at a given unit of granularity and provides utility methods to c...">TimeUnit</a></code> determining how to interpret the <code>timeout</code> parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if successful or <code>false</code> if the specified waiting time elapses before an element is available. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if interrupted while waiting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#ada32b9d8fc257f4dde82c427aa445e81">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aa2cd1a5f1727c8811c254462b5440cde">decaf::util::concurrent::atomic::AtomicInteger::getAndDecrement()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html#a89571672976824c5aba054d00dbc3984">decaf::util::concurrent::TimeUnit::toMillis()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<a class="anchor" id="add7b6b2a858723678588561b7d594357"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::poll" ref="add7b6b2a858723678588561b7d594357" args="(E &amp;result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::poll </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets and removes the element in the head of the queue. </p>
<p>If the operation succeeds the value of the element at the head of the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> is assigned to the result parameter and the method returns true. If the operation fails the method returns false and the value of the result parameter is undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Reference to an instance of the contained type to assigned the removed value to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the element at the head of the queue was removed and assigned to the result parameter. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_queue.html#a3f3aa86736798877441dfdbfb398dc5c">decaf::util::Queue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aa2cd1a5f1727c8811c254462b5440cde">decaf::util::concurrent::atomic::AtomicInteger::getAndDecrement()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a2bfa035134ecf04b747923fb9184c7"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::put" ref="a0a2bfa035134ecf04b747923fb9184c7" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element into this queue, waiting if necessary for space to become available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the element to add </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if interrupted while waiting </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the specified element is null </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the specified element prevents it from being added to this queue </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#a109657d5c0181f631872e8533d5dcc09">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aaf5c37d20cc98a71b9880f3e76e792dc">decaf::util::concurrent::atomic::AtomicInteger::getAndIncrement()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<a class="anchor" id="adc88b63df8328266fe89256ed1916d7a"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::remainingCapacity" ref="adc88b63df8328266fe89256ed1916d7a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::remainingCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or <code>Integer::MAX_VALUE</code> if there is no intrinsic limit. </p>
<p>Note that you <em>cannot</em> always tell if an attempt to insert an element will succeed by inspecting <code>remainingCapacity</code> because it may be the case that another thread is about to insert or remove an element.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remaining capacity </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#af2f7fc6e2e973e9b7e7558c0add39d42">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a53e108239a958fd521471a2ecd2592d4"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::remove" ref="a53e108239a958fd521471a2ecd2592d4" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a single instance of the specified element from the collection.More formally, removes an element e such that (value == NULL ? e == NULL : value == e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to remove from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection was changed, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values.</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method.Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object. </p>
<p>This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method.</p>
<p>Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a6eca5f5f78ac51a1b614da00c7ad2504">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a58b06349287bdd9cbf2f84aa7dcff7ba">decaf::util::AbstractCollection&lt; E &gt;::lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a9cf79717dd4ae017ac43b3ef15a53fa7"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::size" ref="a9cf79717dd4ae017ac43b3ef15a53fa7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of elements in this collection. </p>
<p>If this collection contains more than Integer::MAX_VALUE elements, returns Integer::MAX_VALUE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements in this collection </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#aad34433902f20bd422f64b14f51998cf">decaf::util::Collection&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a0ba5173be192b3af20b42c826b152d42">decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;::toArray()</a>.</p>

</div>
</div>
<a class="anchor" id="a093b20a55f62e3e8cf4f81b1b9a4e5b1"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::take" ref="a093b20a55f62e3e8cf4f81b1b9a4e5b1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the head of this queue </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if interrupted while waiting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#ae01d0599ddb1a0da802bbfef26c1b3dc">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#aa2cd1a5f1727c8811c254462b5440cde">decaf::util::concurrent::atomic::AtomicInteger::getAndDecrement()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ba5173be192b3af20b42c826b152d42"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::toArray" ref="a0ba5173be192b3af20b42c826b152d42" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;E&gt; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::toArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Answers an STL vector containing copies of all elements contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>. </p>
<p>All the elements in the array will not be referenced by the collection. The elements in the returned array will be sorted to the same order as those returned by the iterator of this collection itself if the collection guarantees the order.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an vector of copies of all the elements from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a167776fb00a8924828424616e3b6f3b8">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>, <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a58b06349287bdd9cbf2f84aa7dcff7ba">decaf::util::AbstractCollection&lt; E &gt;::lock()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html#a9cf79717dd4ae017ac43b3ef15a53fa7">decaf::util::concurrent::LinkedBlockingQueue&lt; E &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="accc88eef146544abd79dff948a74be3a"></a><!-- doxytag: member="decaf::util::concurrent::LinkedBlockingQueue::toString" ref="accc88eef146544abd79dff948a74be3a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">decaf::util::concurrent::LinkedBlockingQueue</a>&lt; E &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1atomic_1_1_atomic_integer.html#a45d6f85993d9fb188611039d1697f210">decaf::util::concurrent::atomic::AtomicInteger::get()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/<a class="el" href="_linked_blocking_queue_8h_source.html">LinkedBlockingQueue.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_linked_blocking_queue.html">LinkedBlockingQueue</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
