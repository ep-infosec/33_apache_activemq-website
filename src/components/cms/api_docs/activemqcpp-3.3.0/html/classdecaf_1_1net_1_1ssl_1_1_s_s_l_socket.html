<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::net::ssl::SSLSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::net::ssl::SSLSocket Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::net::ssl::SSLSocket" --><!-- doxytag: inherits="decaf::net::Socket" -->
<p><code>#include &lt;<a class="el" href="_s_s_l_socket_8h_source.html">src/main/decaf/net/ssl/SSLSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::net::ssl::SSLSocket:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket__inherit__graph.png" border="0" usemap="#decaf_1_1net_1_1ssl_1_1_s_s_l_socket_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1net_1_1ssl_1_1_s_s_l_socket_inherit__map" id="decaf_1_1net_1_1ssl_1_1_s_s_l_socket_inherit__map">
<area shape="rect" id="node7" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html" title="Wraps a a Normal Socket object and extends or overrides functions in that class to make use of the Op..." alt="" coords="5,237,363,267"/><area shape="rect" id="node2" href="classdecaf_1_1net_1_1_socket.html" title="decaf::net::Socket" alt="" coords="109,83,259,112"/><area shape="rect" id="node4" href="classdecaf_1_1io_1_1_closeable.html" title="Interface for a class that implements the close method." alt="" coords="107,5,261,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a24ea0776fd994f65ae0282cd4299c164">SSLSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a9bfa08b44450813d98198fcd745bfbba">SSLSocket</a> (const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *address, int port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given address and port.  <a href="#a9bfa08b44450813d98198fcd745bfbba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a759da2b09039ea17c71591747555a865">SSLSocket</a> (const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *address, int port, const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *localAddress, int localPort)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given address and port.  <a href="#a759da2b09039ea17c71591747555a865"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a9062453dc2821329584a93a721fd4ad5">SSLSocket</a> (const std::string &amp;host, int port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given host and port.  <a href="#a9062453dc2821329584a93a721fd4ad5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a35de990304038b721ad1714588dd5418">SSLSocket</a> (const std::string &amp;host, int port, const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *localAddress, int localPort)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given host and port.  <a href="#a35de990304038b721ad1714588dd5418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a23d08a2d778f6246716153dfaf5dbecf">~SSLSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a248b57136c72db290800aa5efee2d0e2">getSupportedCipherSuites</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector containing the names of all the cipher suites that are supported by this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a>.  <a href="#a248b57136c72db290800aa5efee2d0e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ad9865f96e3b0086ea37b64bed828d6e1">getSupportedProtocols</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector containing the names of all the protocols that could be enabled for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance.  <a href="#ad9865f96e3b0086ea37b64bed828d6e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#af3ec5e4ef170d560793501d7ac3e716c">getEnabledCipherSuites</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the names of all the currently enabled Cipher Suites for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.  <a href="#af3ec5e4ef170d560793501d7ac3e716c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ad2948ae36921481849c9d17390baac80">setEnabledCipherSuites</a> (const std::vector&lt; std::string &gt; &amp;suites)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Cipher Suites that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection.  <a href="#ad2948ae36921481849c9d17390baac80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a38dbc5a3b67f832ea59cbb9692458ef7">getEnabledProtocols</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the names of all the currently enabled Protocols for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.  <a href="#a38dbc5a3b67f832ea59cbb9692458ef7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ade5db0c2dd2b0ce3e055bc8b4e4aa356">setEnabledProtocols</a> (const std::vector&lt; std::string &gt; &amp;protocols)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Protocols that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection.  <a href="#ade5db0c2dd2b0ce3e055bc8b4e4aa356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ade826d3ada93b2ec6b879fb64335a029">getSSLParameters</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> object for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance.  <a href="#ade826d3ada93b2ec6b879fb64335a029"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a2509539fd0bd11e8a5cd62f239294355">setSSLParameters</a> (const <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> using the supplied <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> instance.  <a href="#a2509539fd0bd11e8a5cd62f239294355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a17509ab175189abb81e5d32bd7e08b5f">startHandshake</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a handshake for this SSL Connection, this can be necessary for several reasons such as using new encryption keys, or starting a new session.  <a href="#a17509ab175189abb81e5d32bd7e08b5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#aa887d76c42a4d22f8138ad286d131ac6">setUseClientMode</a> (bool value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the mode that the socket uses when a handshake is initiated, client or server.  <a href="#aa887d76c42a4d22f8138ad286d131ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#ad193f3ac4f1e95a6dae8e138c29d62d2">getUseClientMode</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client or Server mode, true indicates that the mode is set to Client.  <a href="#ad193f3ac4f1e95a6dae8e138c29d62d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a650e1fc1f3f31fbae0a33d9f2a0ff746">setNeedClientAuth</a> (bool value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to require that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket.  <a href="#a650e1fc1f3f31fbae0a33d9f2a0ff746"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a828defaef10ccd5f5b9bb4bb8512ff1f">getNeedClientAuth</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this socket is configured to require client authentication, true means that is has and that clients that failed to authenticate will be rejected.  <a href="#a828defaef10ccd5f5b9bb4bb8512ff1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a3ccb2104f941f6caeacf1e88ca7b47b5">setWantClientAuth</a> (bool value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to request that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket.  <a href="#a3ccb2104f941f6caeacf1e88ca7b47b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html#a98078865be96ccdc3b24965a8224881d">getWantClientAuth</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this socket is configured to request client authentication, true means that is has and that clients that failed to authenticate will be rejected but that cleints that do not send a certificate are not considered to have failed authentication.  <a href="#a98078865be96ccdc3b24965a8224881d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a24ea0776fd994f65ae0282cd4299c164"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::SSLSocket" ref="a24ea0776fd994f65ae0282cd4299c164" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::net::ssl::SSLSocket::SSLSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9bfa08b44450813d98198fcd745bfbba"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::SSLSocket" ref="a9bfa08b44450813d98198fcd745bfbba" args="(const InetAddress *address, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::net::ssl::SSLSocket::SSLSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given address and port. </p>
<p>If the host parameter is empty then the loop back address is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port number to connect to [0...65535]</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_unknown_host_exception.html">UnknownHostException</a></td><td>if the host cannot be resolved. </td></tr>
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while connecting the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1net_1_1_inet_address.html" title="Represents an IP address.">InetAddress</a> instance in NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the port if not in range [0...65535] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a759da2b09039ea17c71591747555a865"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::SSLSocket" ref="a759da2b09039ea17c71591747555a865" args="(const InetAddress *address, int port, const InetAddress *localAddress, int localPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::net::ssl::SSLSocket::SSLSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *&#160;</td>
          <td class="paramname"><em>localAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given address and port. </p>
<p>The <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> will also bind to the local address and port specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port number to connect to [0...65535] </td></tr>
    <tr><td class="paramname">localAddress</td><td>The IP address on the local machine to bind to. </td></tr>
    <tr><td class="paramname">localPort</td><td>The port on the local machine to bind to.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_unknown_host_exception.html">UnknownHostException</a></td><td>if the host cannot be resolved. </td></tr>
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while connecting the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1net_1_1_inet_address.html" title="Represents an IP address.">InetAddress</a> instance in NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the port if not in range [0...65535] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9062453dc2821329584a93a721fd4ad5"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::SSLSocket" ref="a9062453dc2821329584a93a721fd4ad5" args="(const std::string &amp;host, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::net::ssl::SSLSocket::SSLSocket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given host and port. </p>
<p>If the host parameter is empty then the loop back address is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host name or IP address to connect to, empty string means loopback. </td></tr>
    <tr><td class="paramname">port</td><td>The port number to connect to [0...65535]</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_unknown_host_exception.html">UnknownHostException</a></td><td>if the host cannot be resolved. </td></tr>
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while connecting the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the port if not in range [0...65535] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35de990304038b721ad1714588dd5418"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::SSLSocket" ref="a35de990304038b721ad1714588dd5418" args="(const std::string &amp;host, int port, const InetAddress *localAddress, int localPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::net::ssl::SSLSocket::SSLSocket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1_inet_address.html">InetAddress</a> *&#160;</td>
          <td class="paramname"><em>localAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance and connects it to the given host and port. </p>
<p>If the host parameter is empty then the loop back address is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host name or IP address to connect to, empty string means loopback. </td></tr>
    <tr><td class="paramname">port</td><td>The port number to connect to [0...65535] </td></tr>
    <tr><td class="paramname">localAddress</td><td>The IP address on the local machine to bind to. </td></tr>
    <tr><td class="paramname">localPort</td><td>The port on the local machine to bind to.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1net_1_1_unknown_host_exception.html">UnknownHostException</a></td><td>if the host cannot be resolved. </td></tr>
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while connecting the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the port if not in range [0...65535] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23d08a2d778f6246716153dfaf5dbecf"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::~SSLSocket" ref="a23d08a2d778f6246716153dfaf5dbecf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::net::ssl::SSLSocket::~SSLSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af3ec5e4ef170d560793501d7ac3e716c"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getEnabledCipherSuites" ref="af3ec5e4ef170d560793501d7ac3e716c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::net::ssl::SSLSocket::getEnabledCipherSuites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector containing the names of all the currently enabled Cipher Suites for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of the names of all enabled Cipher Suites. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a0d44a8b74d9906d6b9714aa4f9449194">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a38dbc5a3b67f832ea59cbb9692458ef7"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getEnabledProtocols" ref="a38dbc5a3b67f832ea59cbb9692458ef7" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::net::ssl::SSLSocket::getEnabledProtocols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector containing the names of all the currently enabled Protocols for this SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of the names of all enabled Protocols. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#aee7c07351c1eaf2c467a73c091a231b0">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a828defaef10ccd5f5b9bb4bb8512ff1f"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getNeedClientAuth" ref="a828defaef10ccd5f5b9bb4bb8512ff1f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::net::ssl::SSLSocket::getNeedClientAuth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this socket is configured to require client authentication, true means that is has and that clients that failed to authenticate will be rejected. </p>
<p>This option is only useful when the socket is operating in server mode.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if client authentication is required. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a9a5b9f5ab301e0afecd88ca678b6842c">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ade826d3ada93b2ec6b879fb64335a029"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getSSLParameters" ref="ade826d3ada93b2ec6b879fb64335a029" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> decaf::net::ssl::SSLSocket::getSSLParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> object for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance. </p>
<p>The cipherSuites and protocols vectors in the returned <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> reference will never be empty.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> object with the settings in use for the <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a248b57136c72db290800aa5efee2d0e2"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getSupportedCipherSuites" ref="a248b57136c72db290800aa5efee2d0e2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::net::ssl::SSLSocket::getSupportedCipherSuites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a vector containing the names of all the cipher suites that are supported by this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a>. </p>
<p>Normally not all of these cipher suites will be enabled on the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector containing the names of all the supported cipher suites. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#ad0412a3832fecbbddd42fd84551dbf6f">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ad9865f96e3b0086ea37b64bed828d6e1"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getSupportedProtocols" ref="ad9865f96e3b0086ea37b64bed828d6e1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; decaf::net::ssl::SSLSocket::getSupportedProtocols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a vector containing the names of all the protocols that could be enabled for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector containing the names of all the supported protocols. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a10023dbd1c514142f393dd02dfdd0b36">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ad193f3ac4f1e95a6dae8e138c29d62d2"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getUseClientMode" ref="ad193f3ac4f1e95a6dae8e138c29d62d2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::net::ssl::SSLSocket::getUseClientMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client or Server mode, true indicates that the mode is set to Client. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> is in Client mode, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#abcfa33b8361ee1770a8e3967466e7594">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a98078865be96ccdc3b24965a8224881d"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::getWantClientAuth" ref="a98078865be96ccdc3b24965a8224881d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::net::ssl::SSLSocket::getWantClientAuth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this socket is configured to request client authentication, true means that is has and that clients that failed to authenticate will be rejected but that cleints that do not send a certificate are not considered to have failed authentication. </p>
<p>This option is only useful when the socket is operating in server mode.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if client authentication is required. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a95db3ea93d26cfb17f9022a44b4e03c1">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ad2948ae36921481849c9d17390baac80"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::setEnabledCipherSuites" ref="ad2948ae36921481849c9d17390baac80" args="(const std::vector&lt; std::string &gt; &amp;suites)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::setEnabledCipherSuites </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>suites</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Cipher Suites that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection. </p>
<p>Each of the named Cipher Suites must appear in the list of supported cipher suites for this connection or an exception will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">suites</td><td>An Vector of names for all the Cipher Suites that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the vector is empty or one of the names is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a6a1607e558358c8816814b22f518e4bb">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ade5db0c2dd2b0ce3e055bc8b4e4aa356"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::setEnabledProtocols" ref="ade5db0c2dd2b0ce3e055bc8b4e4aa356" args="(const std::vector&lt; std::string &gt; &amp;protocols)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::setEnabledProtocols </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>protocols</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the Protocols that are to be enabled on the SSL <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> connection. </p>
<p>Each of the named Protocols must appear in the list of supported protocols suites for this connection or an exception will be thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">protocols</td><td>An Vector of names for all the Protocols that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the vector is empty or one of the names is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a2835627682c02d1c108a814a4328b294">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a650e1fc1f3f31fbae0a33d9f2a0ff746"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::setNeedClientAuth" ref="a650e1fc1f3f31fbae0a33d9f2a0ff746" args="(bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::setNeedClientAuth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to require that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket. </p>
<p>This option only applies to sockets in the Server mode.</p>
<p>If the option is enabled an the client does not provide a certificate then the handshake is considered failed and the connection is refused. Calling this method resets any previous value for this option as well as clears any value set in the setWantClientAuth method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value indicating if a client is required to authenticate itself or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a6a24f429996ac595e86ced7ef48c0cf4">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a2509539fd0bd11e8a5cd62f239294355"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::setSSLParameters" ref="a2509539fd0bd11e8a5cd62f239294355" args="(const SSLParameters &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::setSSLParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> for this <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a> using the supplied <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> instance. </p>
<p>If the cipherSutes vector in the <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> instance is not empty them the setEnabledCipherSuites method is called with that vector, if the protocols vector in the <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> instance is not empty then the setEnabledProtocols method is called with that vector. If the needClientAuth value or the wantClientAuth value is true then the setNeedClientAuth and setWantClientAuth methods are called respectively with a value of true, otherwise the setWantClientAuth method is called with a value of false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The <a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_parameters.html">SSLParameters</a> instance that is used to update this SSLSocket's settings.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if an error occurs while calling setEnabledCipherSuites or setEnabledProtocols. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa887d76c42a4d22f8138ad286d131ac6"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::setUseClientMode" ref="aa887d76c42a4d22f8138ad286d131ac6" args="(bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::setUseClientMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the mode that the socket uses when a handshake is initiated, client or server. </p>
<p>This method must be called prior to any handshake attempts on this <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a>, once a handshake has be initiated this socket remains the the set mode; client or server, for the life of this object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The mode setting, true for client or false for server.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if the handshake process has begun and mode is lcoked. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a86902a685c339d45e5f53fd2fa9edbe6">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a3ccb2104f941f6caeacf1e88ca7b47b5"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::setWantClientAuth" ref="a3ccb2104f941f6caeacf1e88ca7b47b5" args="(bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::setWantClientAuth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <a class="el" href="classdecaf_1_1net_1_1_socket.html">Socket</a> to request that a client authenticate itself by sending a valid Certificate that is trusted by this Server mode socket. </p>
<p>This option only applies to sockets in the Server mode.</p>
<p>If the option is enabled an the client does not provide a certificate then the handshake is considered to have succeeded, if it does send a certificate and that certificate is invalid the the handshake will fail. Calling this method resets any previous value for this option as well as clears any value set in the setNeedClientAuth method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value indicating if a client is requested to authenticate itself or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#a30217f3e25ec76259b16ec86a76bffb2">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a17509ab175189abb81e5d32bd7e08b5f"></a><!-- doxytag: member="decaf::net::ssl::SSLSocket::startHandshake" ref="a17509ab175189abb81e5d32bd7e08b5f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::net::ssl::SSLSocket::startHandshake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiates a handshake for this SSL Connection, this can be necessary for several reasons such as using new encryption keys, or starting a new session. </p>
<p>When called for the first time after the socket connects this method blocks until the handshake is completed. The provider is not require to support multiple handshakes and can throw an IOException to indicate an error.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs while performing the Handshake </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1net_1_1ssl_1_1openssl_1_1_open_s_s_l_socket.html#ac56ebf60f6802a97a19c3b0682067bb6">decaf::internal::net::ssl::openssl::OpenSSLSocket</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/net/ssl/<a class="el" href="_s_s_l_socket_8h_source.html">SSLSocket.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1net.html">net</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1net_1_1ssl.html">ssl</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1net_1_1ssl_1_1_s_s_l_socket.html">SSLSocket</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
