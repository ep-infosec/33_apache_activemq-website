<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::nio::CharBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1nio_1_1_char_buffer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::nio::CharBuffer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::nio::CharBuffer" --><!-- doxytag: inherits="decaf::nio::Buffer,decaf::lang::CharSequence,decaf::lang::Appendable,Comparable&lt; CharBuffer &gt;" -->
<p>This class defines four categories of operations upon character buffers:  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_char_buffer_8h_source.html">src/main/decaf/nio/CharBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::nio::CharBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1nio_1_1_char_buffer__inherit__graph.png" border="0" usemap="#decaf_1_1nio_1_1_char_buffer_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1nio_1_1_char_buffer_inherit__map" id="decaf_1_1nio_1_1_char_buffer_inherit__map">
<area shape="rect" id="node11" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html" title="decaf::internal::nio::CharArrayBuffer" alt="" coords="567,85,833,115"/><area shape="rect" id="node2" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type." alt="" coords="80,5,221,35"/><area shape="rect" id="node4" href="classdecaf_1_1lang_1_1_char_sequence.html" title="A CharSequence is a readable sequence of char values." alt="" coords="48,59,253,88"/><area shape="rect" id="node6" href="classdecaf_1_1lang_1_1_appendable.html" title="An object to which char sequences and values can be appended." alt="" coords="59,112,243,141"/><area shape="rect" id="node8" href="classdecaf_1_1lang_1_1_comparable.html" title="decaf::lang::Comparable\&lt; CharBuffer \&gt;" alt="" coords="5,165,296,195"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a5417d463b730a98746e5fa2da86c4717">~CharBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ac9d893569151fc3df6be047c56773a5a">toString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a111e96c79e42a1819a6351cdb81b5eee">append</a> (char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the specified character to this buffer.  <a href="#a111e96c79e42a1819a6351cdb81b5eee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a64a84931af4b394bc630a55f111e6e28">append</a> (const <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the specified character sequence to this buffer.  <a href="#a64a84931af4b394bc630a55f111e6e28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a7fe67a6a2ea5e27ef74067d4699805e8">append</a> (const <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *value, int start, int end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a subsequence of the specified character sequence to this buffer If value is Null the the string "null" is appended to the buffer.  <a href="#a7fe67a6a2ea5e27ef74067d4699805e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#aeeedbd0a8bf248eb5435faf62da61e13">array</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character array that backs this buffer (optional operation).  <a href="#aeeedbd0a8bf248eb5435faf62da61e13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a86cffeecea297e1ea495cd99e4900c67">arrayOffset</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing array of the first element of the buffer (optional operation).  <a href="#a86cffeecea297e1ea495cd99e4900c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a4fe36b72b26a5f5e5e1078fa764b408f">asReadOnlyBuffer</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, read-only char buffer that shares this buffer's content.  <a href="#a4fe36b72b26a5f5e5e1078fa764b408f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a25eec827719157c32a4310e2694c6fc9">charAt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the character at the given index relative to the current position.  <a href="#a25eec827719157c32a4310e2694c6fc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ad9986f7f6866aabf327f7b5454fd3a5e">compact</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts this buffer.  <a href="#ad9986f7f6866aabf327f7b5454fd3a5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a75c1941edd0a2c97a48c27c71f2c368b">duplicate</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new char buffer that shares this buffer's content.  <a href="#a75c1941edd0a2c97a48c27c71f2c368b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a2b97bd1d26c39d08f1f58c12d72c5b51">get</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative get method.  <a href="#a2b97bd1d26c39d08f1f58c12d72c5b51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a473c75666831b132703413ee1ab96fb1">get</a> (int index) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.  <a href="#a473c75666831b132703413ee1ab96fb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a232c547933fb2bffdcdeeeeeda72a75d">get</a> (std::vector&lt; char &gt; buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk get method.  <a href="#a232c547933fb2bffdcdeeeeeda72a75d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab5897935ac46197fe85afb7a9643adde">get</a> (char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk get method.  <a href="#ab5897935ac46197fe85afb7a9643adde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a72e3273f23313d1ceedaeee2ff1435e3">hasArray</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is backed by an accessible char array.  <a href="#a72e3273f23313d1ceedaeee2ff1435e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ab4c525f4eca223186eee72767c30e02f">length</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of this character buffer.  <a href="#ab4c525f4eca223186eee72767c30e02f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a755c004daca91a64eef4120d786adc03">put</a> (<a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers the chars remaining in the given source buffer into this buffer.  <a href="#a755c004daca91a64eef4120d786adc03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a789aa4ed5e347bf213d8ddc560a5a1d4">put</a> (const char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers chars into this buffer from the given source array.  <a href="#a789aa4ed5e347bf213d8ddc560a5a1d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a14ea79cd111419462580db32249ee6f8">put</a> (std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transfers the entire content of the given source char array into this buffer.  <a href="#a14ea79cd111419462580db32249ee6f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ad7f8e07c4c460376cbfec0f143c94caa">put</a> (char value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given char into this buffer at the current position, and then increments the position.  <a href="#ad7f8e07c4c460376cbfec0f143c94caa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a39a42ad53cebf0c96a3e1b911193ed59">put</a> (int index, char value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given char into this buffer at the given index.  <a href="#a39a42ad53cebf0c96a3e1b911193ed59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a8c2a830221dc44a26c15eb9ec4c835fc">put</a> (std::string &amp;src, int start, int end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk put method (optional operation).  <a href="#a8c2a830221dc44a26c15eb9ec4c835fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a825cd6d51ea13a6380aa837e00709e95">put</a> (const std::string &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative bulk put method (optional operation).  <a href="#a825cd6d51ea13a6380aa837e00709e95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ae78624aa928094734a1df4df0255003e">read</a> (<a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read characters into the specified character buffer.  <a href="#ae78624aa928094734a1df4df0255003e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a1d31acb1522ee27f91e415874b9489cf">subSequence</a> (int start, int end) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position.  <a href="#a1d31acb1522ee27f91e415874b9489cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a5d2d8c90d964c4968f8f350f5551f037">slice</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> whose content is a shared subsequence of this buffer's content.  <a href="#a5d2d8c90d964c4968f8f350f5551f037"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a59a398415926d78da8c8bed0da9ec587">compareTo</a> (const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a59a398415926d78da8c8bed0da9ec587"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a52d8a0a7fbbf147c75046dc55589a183">equals</a> (const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a52d8a0a7fbbf147c75046dc55589a183"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a3425d642d79f2a677748a966e6cb690b">operator==</a> (const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a3425d642d79f2a677748a966e6cb690b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#abc095d9943bcfe41bac7a3fe45cdc9da">operator&lt;</a> (const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#abc095d9943bcfe41bac7a3fe45cdc9da"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#ae84e49c09e88a68a889041bcd5d4d17f">allocate</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new character buffer.  <a href="#ae84e49c09e88a68a889041bcd5d4d17f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#aea41b929ded16d16196f17fc06b74cb4">wrap</a> (char *array, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.  <a href="#aea41b929ded16d16196f17fc06b74cb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a30f53e388e6b5dfb089feb1946f38f7b">wrap</a> (std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL char Vector in a <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.  <a href="#a30f53e388e6b5dfb089feb1946f38f7b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html#a599d21e279737af12336858d9c81d7bf">CharBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted.  <a href="#a599d21e279737af12336858d9c81d7bf"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class defines four categories of operations upon character buffers: </p>
<p>o Absolute and relative get and put methods that read and write single characters; o Relative bulk get methods that transfer contiguous sequences of characters from this buffer into an array; and o Relative bulk put methods that transfer contiguous sequences of characters from a character array, a string, or some other character buffer into this buffer. o Methods for compacting, duplicating, and slicing a character buffer.</p>
<p>Character buffers can be created either by allocation, which allocates space for the buffer's content, by wrapping an existing character array or string into a buffer, or by creating a view of an existing byte buffer</p>
<p>This class implements the CharSequence interface so that character buffers may be used wherever character sequences are accepted, for example in the regular-expression package decaf.util.regex.</p>
<p>Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked. This allows method invocations to be chained. The sequence of statements</p>
<p>cb.put("text/"); cb.put(subtype); cb.put("; charset="); cb.put(enc);</p>
<p>can, for example, be replaced by the single statement</p>
<p>cb.put("text/").put(subtype).put("; charset=").put(enc); </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a599d21e279737af12336858d9c81d7bf"></a><!-- doxytag: member="decaf::nio::CharBuffer::CharBuffer" ref="a599d21e279737af12336858d9c81d7bf" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::nio::CharBuffer::CharBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of the array, this is the limit we read and write to.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if capacity is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5417d463b730a98746e5fa2da86c4717"></a><!-- doxytag: member="decaf::nio::CharBuffer::~CharBuffer" ref="a5417d463b730a98746e5fa2da86c4717" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::nio::CharBuffer::~CharBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae84e49c09e88a68a889041bcd5d4d17f"></a><!-- doxytag: member="decaf::nio::CharBuffer::allocate" ref="ae84e49c09e88a68a889041bcd5d4d17f" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::CharBuffer::allocate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new character buffer. </p>
<p>The new buffer's position will be zero, its limit will be its capacity, and its mark will be undefined. It will have a backing array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of the Char buffer in chars ( 1 byte ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> that was allocated, caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if capacity is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fe67a6a2ea5e27ef74067d4699805e8"></a><!-- doxytag: member="decaf::nio::CharBuffer::append" ref="a7fe67a6a2ea5e27ef74067d4699805e8" args="(const lang::CharSequence *value, int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends a subsequence of the specified character sequence to this buffer If value is Null the the string "null" is appended to the buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The CharSequence to append. </td></tr>
    <tr><td class="paramname">start</td><td>The index to start appending from. </td></tr>
    <tr><td class="paramname">end</td><td>The index to append to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this modified <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is no more space </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if start &gt; end, or &gt; length of sequence. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_appendable.html#a1e1e59babfdfb43df4b68a46f6ed15da">decaf::lang::Appendable</a>.</p>

</div>
</div>
<a class="anchor" id="a111e96c79e42a1819a6351cdb81b5eee"></a><!-- doxytag: member="decaf::nio::CharBuffer::append" ref="a111e96c79e42a1819a6351cdb81b5eee" args="(char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::append </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the specified character to this buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this modified <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is no more space </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_appendable.html#a56085fee6db57f39bc8b11bac6fadd5d">decaf::lang::Appendable</a>.</p>

</div>
</div>
<a class="anchor" id="a64a84931af4b394bc630a55f111e6e28"></a><!-- doxytag: member="decaf::nio::CharBuffer::append" ref="a64a84931af4b394bc630a55f111e6e28" args="(const lang::CharSequence *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the specified character sequence to this buffer. </p>
<p>If value is Null the the string "null" is appended to the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The CharSequence to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this modified <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is no more space </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_appendable.html#a48fe55e54114d4540e1fa849bc6129b8">decaf::lang::Appendable</a>.</p>

</div>
</div>
<a class="anchor" id="aeeedbd0a8bf248eb5435faf62da61e13"></a><!-- doxytag: member="decaf::nio::CharBuffer::array" ref="aeeedbd0a8bf248eb5435faf62da61e13" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* decaf::nio::CharBuffer::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the character array that backs this buffer (optional operation). </p>
<p>Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.</p>
<p>Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the array that backs this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a2a962ba127c31943dd075327142a8402">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a86cffeecea297e1ea495cd99e4900c67"></a><!-- doxytag: member="decaf::nio::CharBuffer::arrayOffset" ref="a86cffeecea297e1ea495cd99e4900c67" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::CharBuffer::arrayOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the offset within this buffer's backing array of the first element of the buffer (optional operation). </p>
<p>Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The offset into the backing array where index zero starts.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> is read only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the underlying store has no array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ae6dabe5e2cc564bfe8a38de3f057ab3b">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a4fe36b72b26a5f5e5e1078fa764b408f"></a><!-- doxytag: member="decaf::nio::CharBuffer::asReadOnlyBuffer" ref="a4fe36b72b26a5f5e5e1078fa764b408f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::CharBuffer::asReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new, read-only char buffer that shares this buffer's content. </p>
<p>The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.</p>
<p>If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.</p>
<p>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new, read-only char buffer which the caller then owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a9ac96e6fac08527174b0702cab373a39">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a25eec827719157c32a4310e2694c6fc9"></a><!-- doxytag: member="decaf::nio::CharBuffer::charAt" ref="a25eec827719157c32a4310e2694c6fc9" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char decaf::nio::CharBuffer::charAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the character at the given index relative to the current position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- The index of the character to be read relative to position</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The character at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index + the current position exceeds the size of the buffer or the index is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html#a3b29878633c28d757a46184588959ee1">decaf::lang::CharSequence</a>.</p>

</div>
</div>
<a class="anchor" id="ad9986f7f6866aabf327f7b5454fd3a5e"></a><!-- doxytag: member="decaf::nio::CharBuffer::compact" ref="ad9986f7f6866aabf327f7b5454fd3a5e" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compacts this buffer. </p>
<p>The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.</p>
<p>The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>- If this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a69d68ff242c2619d90782d287206cfb3">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a59a398415926d78da8c8bed0da9ec587"></a><!-- doxytag: member="decaf::nio::CharBuffer::compareTo" ref="a59a398415926d78da8c8bed0da9ec587" args="(const CharBuffer &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::CharBuffer::compareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a75c1941edd0a2c97a48c27c71f2c368b"></a><!-- doxytag: member="decaf::nio::CharBuffer::duplicate" ref="a75c1941edd0a2c97a48c27c71f2c368b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::CharBuffer::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new char buffer that shares this buffer's content. </p>
<p>The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#acf2117fe9c621d2569aa6bf5880bdf8d">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a52d8a0a7fbbf147c75046dc55589a183"></a><!-- doxytag: member="decaf::nio::CharBuffer::equals" ref="a52d8a0a7fbbf147c75046dc55589a183" args="(const CharBuffer &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::CharBuffer::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a2b97bd1d26c39d08f1f58c12d72c5b51"></a><!-- doxytag: member="decaf::nio::CharBuffer::get" ref="a2b97bd1d26c39d08f1f58c12d72c5b51" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::nio::CharBuffer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative get method. </p>
<p>Reads the character at this buffer's current position, and then increments the position.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char at the current position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there no more data to return </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a22a5f51cf8da460d264e91afaad64813">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a473c75666831b132703413ee1ab96fb1"></a><!-- doxytag: member="decaf::nio::CharBuffer::get" ref="a473c75666831b132703413ee1ab96fb1" args="(int index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::nio::CharBuffer::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Absolute get method. </p>
<p>Reads the char at the given index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the char is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit or is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a5da481d2f474ac00496f458abf719fea">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a232c547933fb2bffdcdeeeeeda72a75d"></a><!-- doxytag: member="decaf::nio::CharBuffer::get" ref="a232c547933fb2bffdcdeeeeeda72a75d" args="(std::vector&lt; char &gt; buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::get </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative bulk get method. </p>
<p>This method transfers chars from this buffer into the given destination vector. An invocation of this method of the form src.get(a) behaves in exactly the same way as the invocation. The vector must be sized to the amount of data that is to be read, that is to say, the caller should call buffer.resize( N ) before calling this get method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are fewer than length chars remaining in this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5897935ac46197fe85afb7a9643adde"></a><!-- doxytag: member="decaf::nio::CharBuffer::get" ref="ab5897935ac46197fe85afb7a9643adde" args="(char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative bulk get method. </p>
<p>This method transfers chars from this buffer into the given destination array. If there are fewer chars remaining in the buffer than are required to satisfy the request, that is, if length &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no bytes are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a> is thrown.</p>
<p>Otherwise, this method copies length chars from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by length.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The pointer to an allocated buffer to fill. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the buffer to start filling. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to put in the passed buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are fewer than length chars remaining in this buffer </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the passed buffer is null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of size, offset, or length are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72e3273f23313d1ceedaeee2ff1435e3"></a><!-- doxytag: member="decaf::nio::CharBuffer::hasArray" ref="a72e3273f23313d1ceedaeee2ff1435e3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::CharBuffer::hasArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether or not this buffer is backed by an accessible char array. </p>
<p>If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is backed by an array and is not read-only </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a9e39462b5ed584c2556b686fd3c5e830">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab4c525f4eca223186eee72767c30e02f"></a><!-- doxytag: member="decaf::nio::CharBuffer::length" ref="ab4c525f4eca223186eee72767c30e02f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::nio::CharBuffer::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of this character buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of this buffer from the position to the limit. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html#a1d2b7f158d42ab0e19d76ac4ae610a8d">decaf::lang::CharSequence</a>.</p>

</div>
</div>
<a class="anchor" id="abc095d9943bcfe41bac7a3fe45cdc9da"></a><!-- doxytag: member="decaf::nio::CharBuffer::operator&lt;" ref="abc095d9943bcfe41bac7a3fe45cdc9da" args="(const CharBuffer &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::CharBuffer::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a3425d642d79f2a677748a966e6cb690b"></a><!-- doxytag: member="decaf::nio::CharBuffer::operator==" ref="a3425d642d79f2a677748a966e6cb690b" args="(const CharBuffer &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::nio::CharBuffer::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a755c004daca91a64eef4120d786adc03"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="a755c004daca91a64eef4120d786adc03" args="(CharBuffer &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method transfers the chars remaining in the given source buffer into this buffer. </p>
<p>If there are more chars remaining in the source buffer than in this buffer, that is, if src.remaining() &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no chars are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a> is thrown.</p>
<p>Otherwise, this method copies n = src.remaining() chars from the given buffer into this buffer, starting at each buffer's current position. The positions of both buffers are then incremented by n.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- the buffer to take chars from an place in this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is insufficient space in this buffer for the remaining chars in the source buffer. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the source buffer is this buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a789aa4ed5e347bf213d8ddc560a5a1d4"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="a789aa4ed5e347bf213d8ddc560a5a1d4" args="(const char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method transfers chars into this buffer from the given source array. </p>
<p>If there are more chars to be copied from the array than remain in this buffer, that is, if length &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no chars are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a> is thrown.</p>
<p>Otherwise, this method copies length bytes from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by length.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array from which chars are to be read. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the array of the first char to be read. </td></tr>
    <tr><td class="paramname">length</td><td>The number of chars to be read from the given array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is insufficient space in this buffer </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the passed buffer is null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of size, offset, or length are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7f8e07c4c460376cbfec0f143c94caa"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="ad7f8e07c4c460376cbfec0f143c94caa" args="(char value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given char into this buffer at the current position, and then increments the position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The char value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ac7000bacc913fbd14e1c957f80ec9b14">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a39a42ad53cebf0c96a3e1b911193ed59"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="a39a42ad53cebf0c96a3e1b911193ed59" args="(int index, char value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given char into this buffer at the given index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The char to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#ad2d2a97ee0cd5061f7eb428f8238821c">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a8c2a830221dc44a26c15eb9ec4c835fc"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="a8c2a830221dc44a26c15eb9ec4c835fc" args="(std::string &amp;src, int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative bulk put method (optional operation). </p>
<p>This method transfers characters from the given string into this buffer. If there are more characters to be copied from the string than remain in this buffer, that is, if end - start &gt; <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>, then no characters are transferred and a <a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a> is thrown. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer</dd></dl>
<p>Otherwise, this method copies n = end - start characters from the given string into this buffer, starting at the given start index and at the current position of this buffer. The position of this buffer is then incremented by n.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to copy from. </td></tr>
    <tr><td class="paramname">start</td><td>The position in src to start from. </td></tr>
    <tr><td class="paramname">end</td><td>The position in src to stop at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a825cd6d51ea13a6380aa837e00709e95"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="a825cd6d51ea13a6380aa837e00709e95" args="(const std::string &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative bulk put method (optional operation). </p>
<p>This method transfers the entire content of the given source string into this buffer. An invocation of this method of the form dst.put(s) behaves in exactly the same way as the invocation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14ea79cd111419462580db32249ee6f8"></a><!-- doxytag: member="decaf::nio::CharBuffer::put" ref="a14ea79cd111419462580db32249ee6f8" args="(std::vector&lt; char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>&amp; decaf::nio::CharBuffer::put </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method transfers the entire content of the given source char array into this buffer. </p>
<p>This is the same as calling put( &amp;buffer[0], 0, buffer.size().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer whose contents are copied to this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there is insufficient space in this buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae78624aa928094734a1df4df0255003e"></a><!-- doxytag: member="decaf::nio::CharBuffer::read" ref="ae78624aa928094734a1df4df0255003e" args="(CharBuffer *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::nio::CharBuffer::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to read characters into the specified character buffer. </p>
<p>The buffer is used as a repository of characters as-is: the only changes made are the results of a put operation. No flipping or rewinding of the buffer is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The buffer to read characters into</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of characters added to the buffer, or string::npos if this source of characters is at its end</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if target is Null. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if target is this <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is in read-only mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d2d8c90d964c4968f8f350f5551f037"></a><!-- doxytag: member="decaf::nio::CharBuffer::slice" ref="a5d2d8c90d964c4968f8f350f5551f037" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::CharBuffer::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> whose content is a shared subsequence of this buffer's content. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> which the caller owns. </dd></dl>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#a50e69c403797e5d6e0c3491f0e34a8a4">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1d31acb1522ee27f91e415874b9489cf"></a><!-- doxytag: member="decaf::nio::CharBuffer::subSequence" ref="a1d31acb1522ee27f91e415874b9489cf" args="(int start, int end) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html">lang::CharSequence</a>* decaf::nio::CharBuffer::subSequence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new character buffer that represents the specified subsequence of this buffer, relative to the current position. </p>
<p>The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + start, and its limit will be <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> + end. The new <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> will be read-only if, and only if, this buffer is read-only.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index, relative to the current position, of the first character in the subsequence; must be non-negative and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>. </td></tr>
    <tr><td class="paramname">end</td><td>The index, relative to the current position, of the character following the last character in the subsequence; must be no smaller than start and no larger than <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a21cd75b27abc500af892a4078083c10e" title="Returns the number of elements between the current position and the limit.">remaining()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new character buffer, caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions on start and end fail. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html#acd88464dffe53cddcc736bcd785e8056">decaf::lang::CharSequence</a>.</p>

<p>Implemented in <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_char_array_buffer.html#aeb7ba1e4d009af1a76ba212f8fdc2dd3">decaf::internal::nio::CharArrayBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac9d893569151fc3df6be047c56773a5a"></a><!-- doxytag: member="decaf::nio::CharBuffer::toString" ref="ac9d893569151fc3df6be047c56773a5a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string decaf::nio::CharBuffer::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a std::string describing this object </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_char_sequence.html#a7c368537fb955f0c89aa7f329e32367b">decaf::lang::CharSequence</a>.</p>

</div>
</div>
<a class="anchor" id="aea41b929ded16d16196f17fc06b74cb4"></a><!-- doxytag: member="decaf::nio::CharBuffer::wrap" ref="aea41b929ded16d16196f17fc06b74cb4" args="(char *array, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::CharBuffer::wrap </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>. </p>
<p>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array passed in. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> that is backed by buffer, caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the array pointer is Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if capacity is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30f53e388e6b5dfb089feb1946f38f7b"></a><!-- doxytag: member="decaf::nio::CharBuffer::wrap" ref="a30f53e388e6b5dfb089feb1946f38f7b" args="(std::vector&lt; char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>* decaf::nio::CharBuffer::wrap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL char Vector in a <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a>. </p>
<p>The new buffer will be backed by the given char array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html" title="This class defines four categories of operations upon character buffers:">CharBuffer</a> that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/nio/<a class="el" href="_char_buffer_8h_source.html">CharBuffer.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1nio.html">nio</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">CharBuffer</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
