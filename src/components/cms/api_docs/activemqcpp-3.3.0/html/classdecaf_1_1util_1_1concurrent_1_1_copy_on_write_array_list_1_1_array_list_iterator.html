<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator" --><!-- doxytag: inherits="decaf::util::ListIterator" -->
<p><code>#include &lt;<a class="el" href="_copy_on_write_array_list_8h_source.html">src/main/decaf/util/concurrent/CopyOnWriteArrayList.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_3_01_e_01_4_1_1_array_list_iterator_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_3_01_e_01_4_1_1_array_list_iterator_inherit__map" id="decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_3_01_e_01_4_1_1_array_list_iterator_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1_list_iterator.html" title="An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator&#39;s current position in the list." alt="" coords="144,83,363,112"/><area shape="rect" id="node4" href="classdecaf_1_1util_1_1_iterator.html" title="Defines an object that can be used to iterate over the elements of a collection." alt="" coords="157,5,349,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a8ab743968eaf8448ac03d85012198301">ArrayListIterator</a> (const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; E &gt; &amp;array, int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#ae205ca470c654ba56beb427b3ce36cd1">~ArrayListIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a5560744fe6ef589b054c67de83372aa2">next</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next element in the iteration.  <a href="#a5560744fe6ef589b054c67de83372aa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a30e7f3a59f82da814c9c1ab5e928be24">hasNext</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iteration has more elements.  <a href="#a30e7f3a59f82da814c9c1ab5e928be24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#aa7529564c934e80079a309a6e9c250f8">remove</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the underlying collection the last element returned by the iterator (optional operation).  <a href="#aa7529564c934e80079a309a6e9c250f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#ab8f7e1148085edb2516a83327cca6d06">add</a> (const E &amp;e DECAF_UNUSED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#abc5219df101adc4ccec598b6f27db16f">set</a> (const E &amp;e DECAF_UNUSED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a8a29a0d9e77aedd88de05a13a4097a34">hasPrevious</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this list iterator has more elements when traversing the list in the reverse direction.  <a href="#a8a29a0d9e77aedd88de05a13a4097a34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a5730cc4ad66aa30b8b6a4e8926ed66c0">previous</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous element in the list.  <a href="#a5730cc4ad66aa30b8b6a4e8926ed66c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a2d3515de3c7571a2518979255795141c">nextIndex</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element that would be returned by a subsequent call to next.  <a href="#a2d3515de3c7571a2518979255795141c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a3005821734feaf26c68d7295fb1f466b">previousIndex</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element that would be returned by a subsequent call to previous.  <a href="#a3005821734feaf26c68d7295fb1f466b"></a><br/></td></tr>
</table>
<h3>template&lt;typename E&gt;<br/>
 class decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;::ArrayListIterator</h3>

<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8ab743968eaf8448ac03d85012198301"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::ArrayListIterator" ref="a8ab743968eaf8448ac03d85012198301" args="(const ArrayPointer&lt; E &gt; &amp;array, int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::ArrayListIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html">ArrayPointer</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="classdecaf_1_1lang_1_1_array_pointer.html#aef250fd7bc5c384854a5229587b940b3">decaf::lang::ArrayPointer&lt; T, REFCOUNTER &gt;::length()</a>.</p>

</div>
</div>
<a class="anchor" id="ae205ca470c654ba56beb427b3ce36cd1"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::~ArrayListIterator" ref="ae205ca470c654ba56beb427b3ce36cd1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::~ArrayListIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab8f7e1148085edb2516a83327cca6d06"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::add" ref="ab8f7e1148085edb2516a83327cca6d06" args="(const E &amp;e DECAF_UNUSED)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::add </td>
          <td>(</td>
          <td class="paramtype">const E &amp;e&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a30e7f3a59f82da814c9c1ab5e928be24"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::hasNext" ref="a30e7f3a59f82da814c9c1ab5e928be24" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::hasNext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the iteration has more elements. </p>
<p>Returns false if the next call to next would result in an <a class="el" href="classdecaf_1_1util_1_1_no_such_element_exception.html">NoSuchElementException</a> to be thrown.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there are more elements available for iteration. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a630a2f64ee8285e2905d5e1ab0d6ddc5">decaf::util::Iterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8a29a0d9e77aedd88de05a13a4097a34"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::hasPrevious" ref="a8a29a0d9e77aedd88de05a13a4097a34" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::hasPrevious </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this list iterator has more elements when traversing the list in the reverse direction. </p>
<p>(In other words, returns true if previous would return an element rather than throwing an exception.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the list iterator has more elements when traversing the list in the reverse direction. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a49da594069834d22fede126acc999ecb">decaf::util::ListIterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5560744fe6ef589b054c67de83372aa2"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::next" ref="a5560744fe6ef589b054c67de83372aa2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next element in the iteration. </p>
<p>Calling this method repeatedly until the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html#a30e7f3a59f82da814c9c1ab5e928be24" title="Returns true if the iteration has more elements.">hasNext()</a> method returns false will return each element in the underlying collection exactly once.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next element in the iteration of elements.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1util_1_1_no_such_element_exception.html">NoSuchElementException</a></td><td>if the iteration has no more elements. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_iterator.html#ae03ba0935e64dbdfd3b384ef89f9fd83">decaf::util::Iterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2d3515de3c7571a2518979255795141c"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::nextIndex" ref="a2d3515de3c7571a2518979255795141c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::nextIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the element that would be returned by a subsequent call to next. </p>
<p>(Returns list size if the list iterator is at the end of the list.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the element that would be returned by a subsequent call to next, or list size if list iterator is at end of list. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a3c14adb19b578476df0b950f1bcdb12c">decaf::util::ListIterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5730cc4ad66aa30b8b6a4e8926ed66c0"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::previous" ref="a5730cc4ad66aa30b8b6a4e8926ed66c0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::previous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the previous element in the list. </p>
<p>This method may be called repeatedly to iterate through the list backwards, or intermixed with calls to next to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the previous element in the list.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1util_1_1_no_such_element_exception.html">NoSuchElementException</a></td><td>if the iteration has no previous element. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#a66abb34917e79060ec9a203a6e210bcb">decaf::util::ListIterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3005821734feaf26c68d7295fb1f466b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::previousIndex" ref="a3005821734feaf26c68d7295fb1f466b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::previousIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the element that would be returned by a subsequent call to previous. </p>
<p>(Returns -1 if the list iterator is at the beginning of the list.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the element that would be returned by a subsequent call to previous, or -1 if list iterator is at beginning of list. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html#af9f13e48289325042a3d3d64830dd17d">decaf::util::ListIterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa7529564c934e80079a309a6e9c250f8"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::remove" ref="aa7529564c934e80079a309a6e9c250f8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes from the underlying collection the last element returned by the iterator (optional operation). </p>
<p>This method can be called only once per call to next. The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the remove operation is not supported by this <a class="el" href="classdecaf_1_1util_1_1_iterator.html" title="Defines an object that can be used to iterate over the elements of a collection.">Iterator</a>. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the next method has not yet been called, or the remove method has already been called after the last call to the next method. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c">decaf::util::Iterator&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abc5219df101adc4ccec598b6f27db16f"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::ArrayListIterator::set" ref="abc5219df101adc4ccec598b6f27db16f" args="(const E &amp;e DECAF_UNUSED)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::ArrayListIterator::set </td>
          <td>(</td>
          <td class="paramtype">const E &amp;e&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/<a class="el" href="_copy_on_write_array_list_8h_source.html">CopyOnWriteArrayList.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
