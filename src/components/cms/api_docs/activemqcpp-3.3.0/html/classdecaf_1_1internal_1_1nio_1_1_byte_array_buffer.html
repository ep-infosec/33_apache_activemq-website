<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::internal::nio::ByteArrayBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::internal::nio::ByteArrayBuffer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::internal::nio::ByteArrayBuffer" --><!-- doxytag: inherits="decaf::nio::ByteBuffer" -->
<p>This class defines six categories of operations upon byte buffers:  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_array_buffer_8h_source.html">src/main/decaf/internal/nio/ByteArrayBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::internal::nio::ByteArrayBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer__inherit__graph.png" border="0" usemap="#decaf_1_1internal_1_1nio_1_1_byte_array_buffer_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1internal_1_1nio_1_1_byte_array_buffer_inherit__map" id="decaf_1_1internal_1_1nio_1_1_byte_array_buffer_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:" alt="" coords="109,83,283,112"/><area shape="rect" id="node4" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type." alt="" coords="5,5,147,35"/><area shape="rect" id="node6" href="classdecaf_1_1lang_1_1_comparable.html" title="decaf::lang::Comparable\&lt; ByteBuffer \&gt;" alt="" coords="171,5,464,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a384ad4c72456df3bba840a8459ef0456">ByteArrayBuffer</a> (int capacity, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted.  <a href="#a384ad4c72456df3bba840a8459ef0456"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a422a4aa4476ed607b0b046e3d460465d">ByteArrayBuffer</a> (unsigned char *array, int size, int offset, int length, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> object that wraps the given array.  <a href="#a422a4aa4476ed607b0b046e3d460465d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a6aea55eb921581434c8b0f1525d1e32a">ByteArrayBuffer</a> (const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt; &amp;array, int offset, int length, bool readOnly=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a byte buffer that wraps the passed ByteArrayAdapter and start at the given offset.  <a href="#a6aea55eb921581434c8b0f1525d1e32a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a51306322e524792d808791ae538dbbc2">ByteArrayBuffer</a> (const <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> that mirrors this one, meaning it shares a reference to this buffers ByteArrayAdapter and when changes are made to that data it is reflected in both.  <a href="#a51306322e524792d808791ae538dbbc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a7355bb98b932012410139da4deccca6f">~ByteArrayBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a81ed73baffb070f694bcc9cd5496412a">isReadOnly</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is read-only</dd></dl>
  <a href="#a81ed73baffb070f694bcc9cd5496412a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab872857f87d1e77d9e54c0a83e6cd8da">array</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte array that backs this buffer.Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>The array that backs this buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is backed by an array but is read-only </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if this buffer is not backed by an accessible array</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ab872857f87d1e77d9e54c0a83e6cd8da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a1d300022180c94d7adc08f61ff177d58">arrayOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing array of the first element of the buffer.If this buffer is backed by an array then buffer position p corresponds to array index p + <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac9c05f1b5e3852933a7fed5df3ed87c6" title="Returns the offset within this buffer&#39;s backing array of the first element of the buffer...">arrayOffset()</a>.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>The offset within this buffer's array of the first element of the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is backed by an array but is read-only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if this buffer is not backed by an accessible array.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a1d300022180c94d7adc08f61ff177d58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab88d3d871be65718a26bc10480fa1c00">hasArray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether or not this buffer is backed by an accessible byte array.If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is backed by an array and is not read-only.</dd></dl>
  <a href="#ab88d3d871be65718a26bc10480fa1c00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ae532f63b02904f8e6c1b9d3c59127615">asCharBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a char buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new Char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
  <a href="#ae532f63b02904f8e6c1b9d3c59127615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ae19e76b6cb171545a85a9785b14f3bde">asDoubleBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a double buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new double <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
  <a href="#ae19e76b6cb171545a85a9785b14f3bde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#adcabd9f4d7ea07108381f0fc640eb5d7">asFloatBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a float buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new float <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
  <a href="#adcabd9f4d7ea07108381f0fc640eb5d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5ac9532130690e47118f6fcfd0ef7907">asIntBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a int buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
  <a href="#a5ac9532130690e47118f6fcfd0ef7907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ae21a5d812ab2955bb489fbe308f2bec3">asLongBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a long buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new long <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
  <a href="#ae21a5d812ab2955bb489fbe308f2bec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aed21a9c70f2255bd98c5da01a0c6885d">asShortBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of this byte buffer as a short buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new short <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
  <a href="#aed21a9c70f2255bd98c5da01a0c6885d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a019e49e85d4c04f31eed42119cfa4c36">asReadOnlyBuffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, read-only byte buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.<dl class="return"><dt><b>Returns:</b></dt><dd>The new, read-only byte buffer which the caller then owns.</dd></dl>
  <a href="#a019e49e85d4c04f31eed42119cfa4c36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#afbaee538d7a19c626e53d8bbbd457fe2">compact</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts this buffer.The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#afbaee538d7a19c626e53d8bbbd457fe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#af9d7f25df35236782fe9eaa67a85efdf">duplicate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new byte buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>a new Byte <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns.</dd></dl>
  <a href="#af9d7f25df35236782fe9eaa67a85efdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ad3d7ce119416783ca914675db93991be">get</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative get method.Reads the byte at this buffer's current position, and then increments the position.<dl class="return"><dt><b>Returns:</b></dt><dd>The byte at the buffer's current position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if the buffer's current position is not smaller than its limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ad3d7ce119416783ca914675db93991be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a2cbfcd1386e1e219b679fe4ec2414eba">get</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute get method.Reads the byte at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a2cbfcd1386e1e219b679fe4ec2414eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a716e6514c00647d3ba34a54d286e7f19">getChar</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next byte at this buffer's current position, and then increments the position by one.<dl class="return"><dt><b>Returns:</b></dt><dd>the next char in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a716e6514c00647d3ba34a54d286e7f19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a3eeed0099b82fe82ca66cf69614d2ba9">getChar</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char at the given index in the buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a3eeed0099b82fe82ca66cf69614d2ba9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a1f52edcd8a4bc9dd2db604c149e4451c">getDouble</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next double in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a1f52edcd8a4bc9dd2db604c149e4451c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#af167abba3f2a52b4b2d6d2ca2692a7fc">getDouble</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the double at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#af167abba3f2a52b4b2d6d2ca2692a7fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ac22c51dc10d8e040ee3aca24469cb9e7">getFloat</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next float in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ac22c51dc10d8e040ee3aca24469cb9e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#adbfc001c2239e604f43c0bd37a8ff9bb">getFloat</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the float at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#adbfc001c2239e604f43c0bd37a8ff9bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a177d0e5939d7ff274efe110669c93a83">getLong</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next eight bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next long long in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a177d0e5939d7ff274efe110669c93a83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ac6fa5397b4c01cab3ecf066a2d498b2b">getLong</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads eight bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the long long at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ac6fa5397b4c01cab3ecf066a2d498b2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab7c93abc43c250a610943e987d6d4cec">getInt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next four bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next int in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ab7c93abc43c250a610943e987d6d4cec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a07f6271ed0438e0fed8f74d31839ee10">getInt</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads four bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the int at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a07f6271ed0438e0fed8f74d31839ee10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aad66bb88a93fe63a04026860ac1fa641">getShort</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next two bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next short in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aad66bb88a93fe63a04026860ac1fa641"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a7495ef1ffef98ecce4188770179daf6c">getShort</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads two bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the short at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a7495ef1ffef98ecce4188770179daf6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a6eea85981ad91107ceece849466a6e10">put</a> (unsigned char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte into this buffer at the current position, and then increments the position.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the byte value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a6eea85981ad91107ceece849466a6e10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aa34cd944bff34ae3968d15471d7b6072">put</a> (int index, unsigned char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given byte into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>- the byte to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aa34cd944bff34ae3968d15471d7b6072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a940d4fe71592ea67e83d1d754f34e46f">putChar</a> (char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte containing the given value, into this buffer at the current position, and then increments the position by one.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a940d4fe71592ea67e83d1d754f34e46f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a58d45611f423e101722a99a4a7599faa">putChar</a> (int index, char value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a58d45611f423e101722a99a4a7599faa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5648f055607827df32cfdb8074e957f2">putDouble</a> (double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a5648f055607827df32cfdb8074e957f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#adf4135569f27184cb922dfff238321c8">putDouble</a> (int index, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#adf4135569f27184cb922dfff238321c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a937d1ae4adcf0d609cd1c591fb4a30ec">putFloat</a> (float value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a937d1ae4adcf0d609cd1c591fb4a30ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5108c794c9a9fd260ce4600c50630950">putFloat</a> (int index, float value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a5108c794c9a9fd260ce4600c50630950"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a01dd135accd07d0f60fa71d1b7de2212">putLong</a> (long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a01dd135accd07d0f60fa71d1b7de2212"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a2c432f0586df4f41241234ec79cc94a8">putLong</a> (int index, long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes eight bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a2c432f0586df4f41241234ec79cc94a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a29d457e7218784933a824c7b1e6f04bd">putInt</a> (int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a29d457e7218784933a824c7b1e6f04bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ab310c1792f41c39f47cb5eabc8fee616">putInt</a> (int index, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes four bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
  <a href="#ab310c1792f41c39f47cb5eabc8fee616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#acd90cd9ec81335165a2e7fdcc19d400f">putShort</a> (short value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#acd90cd9ec81335165a2e7fdcc19d400f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a8dfa4f8108273882549629e905ebae04">putShort</a> (int index, short value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes two bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a8dfa4f8108273882549629e905ebae04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#aeeca3e501a41ff17730aaf3e675ba6e5">slice</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new byte buffer whose content is a shared subsequence of this buffer's content.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> which the caller owns.</dd></dl>
  <a href="#aeeca3e501a41ff17730aaf3e675ba6e5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a1e33eb10a1d60814341969765085972b">setReadOnly</a> (bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> as Read-Only or not Read-Only.  <a href="#a1e33eb10a1d60814341969765085972b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class defines six categories of operations upon byte buffers: </p>
<p>1. Absolute and relative get and put methods that read and write single bytes; 2. Relative bulk get methods that transfer contiguous sequences of bytes from this buffer into an array; 3. Relative bulk put methods that transfer contiguous sequences of bytes from a byte array or some other byte buffer into this buffer; 4. Absolute and relative get and put methods that read and write values of other primitive types, translating them to and from sequences of bytes in a particular byte order; 5. Methods for creating view buffers, which allow a byte buffer to be viewed as a buffer containing values of some other primitive type; and 6. Methods for compacting, duplicating, and slicing a byte buffer.</p>
<p>Byte buffers can be created either by allocation, which allocates space for the buffer's content, or by wrapping an existing byte array into a buffer.</p>
<p>Access to binary data:</p>
<p>This class defines methods for reading and writing values of all other primitive types, except boolean. Primitive values are translated to (or from) sequences of bytes according to the buffer's current byte order.</p>
<p>For access to heterogeneous binary data, that is, sequences of values of different types, this class defines a family of absolute and relative get and put methods for each type. For 32-bit floating-point values, for example, this class defines:</p>
<p>float <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#ac22c51dc10d8e040ee3aca24469cb9e7" title="Reads the next four bytes at this buffer&#39;s current position, and then increments the position by ...">getFloat()</a> float getFloat(int index) void <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a937d1ae4adcf0d609cd1c591fb4a30ec" title="Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.The value to be written.a reference to this buffer.if there are fewer than bytes remaining in this buffer than the size of the data to be written. if this buffer is read-only.">putFloat(float f)</a> void <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html#a5108c794c9a9fd260ce4600c50630950" title="Writes four bytes containing the given value, into this buffer at the given index.The position in the Buffer to write the data The value to write.a reference to this buffer.if index greater than the buffer&#39;s limit minus the size of the type being written, or index is negative. if this buffer is read-only.">putFloat(int index, float f)</a></p>
<p>Corresponding methods are defined for the types char, short, int, long, and double. The index parameters of the absolute get and put methods are in terms of bytes rather than of the type being read or written.</p>
<p>For access to homogeneous binary data, that is, sequences of values of the same type, this class defines methods that can create views of a given byte buffer. A view buffer is simply another buffer whose content is backed by the byte buffer. Changes to the byte buffer's content will be visible in the view buffer, and vice versa; the two buffers' position, limit, and mark values are independent. The asFloatBuffer method, for example, creates an instance of the FloatBuffer class that is backed by the byte buffer upon which the method is invoked. Corresponding view-creation methods are defined for the types char, short, int, long, and double.</p>
<p>View buffers have two important advantages over the families of type-specific get and put methods described above:</p>
<p>A view buffer is indexed not in terms of bytes but rather in terms of the type-specific size of its values;</p>
<p>A view buffer provides relative bulk get and put methods that can transfer contiguous sequences of values between a buffer and an array or some other buffer of the same type; and</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a384ad4c72456df3bba840a8459ef0456"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer" ref="a384ad4c72456df3bba840a8459ef0456" args="(int capacity, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> object that has its backing array allocated internally and is then owned and deleted when this object is deleted. </p>
<p>The array is initially created with all elements initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of the array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Should this buffer be read-only, default as false</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArguementException</td><td>if the capacity value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a422a4aa4476ed607b0b046e3d460465d"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer" ref="a422a4aa4476ed607b0b046e3d460465d" args="(unsigned char *array, int size, int offset, int length, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> object that wraps the given array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to wrap. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array passed. </td></tr>
    <tr><td class="paramname">offset</td><td>The position that is this buffers start position. </td></tr>
    <tr><td class="paramname">length</td><td>The size of the sub-array, this is the limit we read and write to. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Should this buffer be read-only, default as false.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the preconditions of size, offset and length are violated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6aea55eb921581434c8b0f1525d1e32a"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer" ref="a6aea55eb921581434c8b0f1525d1e32a" args="(const decaf::lang::Pointer&lt; ByteArrayAdapter &gt; &amp;array, int offset, int length, bool readOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1lang_1_1_pointer.html">decaf::lang::Pointer</a>&lt; <a class="el" href="classdecaf_1_1internal_1_1util_1_1_byte_array_adapter.html">ByteArrayAdapter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a byte buffer that wraps the passed ByteArrayAdapter and start at the given offset. </p>
<p>The capacity and limit of the new <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> will be that of the remaining capacity of the passed buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The ByteArrayAdapter to wrap </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into array where the buffer starts </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array we are wrapping or limit. </td></tr>
    <tr><td class="paramname">readOnly</td><td>Boolean indicating if this a readOnly buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if array is NULL </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if offset is greater than array capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51306322e524792d808791ae538dbbc2"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer" ref="a51306322e524792d808791ae538dbbc2" args="(const ByteArrayBuffer &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::internal::nio::ByteArrayBuffer::ByteArrayBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> that mirrors this one, meaning it shares a reference to this buffers ByteArrayAdapter and when changes are made to that data it is reflected in both. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> this one is to mirror. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7355bb98b932012410139da4deccca6f"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::~ByteArrayBuffer" ref="a7355bb98b932012410139da4deccca6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::nio::ByteArrayBuffer::~ByteArrayBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab872857f87d1e77d9e54c0a83e6cd8da"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::array" ref="ab872857f87d1e77d9e54c0a83e6cd8da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char* decaf::internal::nio::ByteArrayBuffer::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the byte array that backs this buffer.Modifications to this buffer's content will cause the returned array's content to be modified, and vice versa.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>The array that backs this buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is backed by an array but is read-only </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if this buffer is not backed by an accessible array</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a58f829960228ba89ce3c9960fee38588">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1d300022180c94d7adc08f61ff177d58"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::arrayOffset" ref="a1d300022180c94d7adc08f61ff177d58" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::nio::ByteArrayBuffer::arrayOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the offset within this buffer's backing array of the first element of the buffer.If this buffer is backed by an array then buffer position p corresponds to array index p + <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac9c05f1b5e3852933a7fed5df3ed87c6" title="Returns the offset within this buffer&#39;s backing array of the first element of the buffer...">arrayOffset()</a>.Invoke the hasArray method before invoking this method in order to ensure that this buffer has an accessible backing array.<dl class="return"><dt><b>Returns:</b></dt><dd>The offset within this buffer's array of the first element of the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is backed by an array but is read-only. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if this buffer is not backed by an accessible array.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac9c05f1b5e3852933a7fed5df3ed87c6">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae532f63b02904f8e6c1b9d3c59127615"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asCharBuffer" ref="ae532f63b02904f8e6c1b9d3c59127615" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asCharBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a view of this byte buffer as a char buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new Char <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a4fc24e890bf3ceb7ec3cf3f69153d89d">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae19e76b6cb171545a85a9785b14f3bde"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asDoubleBuffer" ref="ae19e76b6cb171545a85a9785b14f3bde" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asDoubleBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a view of this byte buffer as a double buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new double <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#adba2171c8f780731d0f5a23fe5033e1a">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="adcabd9f4d7ea07108381f0fc640eb5d7"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asFloatBuffer" ref="adcabd9f4d7ea07108381f0fc640eb5d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asFloatBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a view of this byte buffer as a float buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new float <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a3c020e22e86cc112b5293f845cf198a1">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a5ac9532130690e47118f6fcfd0ef7907"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asIntBuffer" ref="a5ac9532130690e47118f6fcfd0ef7907" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asIntBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a view of this byte buffer as a int buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new int <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#aefd4b8e6f690e848310e32bdb969e655">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ae21a5d812ab2955bb489fbe308f2bec3"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asLongBuffer" ref="ae21a5d812ab2955bb489fbe308f2bec3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asLongBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a view of this byte buffer as a long buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new long <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#aa566e6db4d82627895f4d0f022771c83">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a019e49e85d4c04f31eed42119cfa4c36"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asReadOnlyBuffer" ref="a019e49e85d4c04f31eed42119cfa4c36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asReadOnlyBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new, read-only byte buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.If this buffer is itself read-only then this method behaves in exactly the same way as the duplicate method.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.<dl class="return"><dt><b>Returns:</b></dt><dd>The new, read-only byte buffer which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#afe697df87e754e2437e3cb9f538a7b7d">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aed21a9c70f2255bd98c5da01a0c6885d"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::asShortBuffer" ref="aed21a9c70f2255bd98c5da01a0c6885d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::ByteArrayBuffer::asShortBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a view of this byte buffer as a short buffer.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the new short <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a>, which the caller then owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ae5e28993426f4fda17a3c45e302de629">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="afbaee538d7a19c626e53d8bbbd457fe2"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::compact" ref="afbaee538d7a19c626e53d8bbbd457fe2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compacts this buffer.The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#ac3f3a9b58ba3c2986e0c7b3752b52c15">position()</a> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 is copied to index n = <a class="el" href="classdecaf_1_1nio_1_1_buffer.html#a7517c02b4d27d040c44f970c307bf5b3">limit()</a> - 1 - p. The buffer's position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded.The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a175bcc2bed9f5db43df078c4a2f5ab07">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="af9d7f25df35236782fe9eaa67a85efdf"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::duplicate" ref="af9d7f25df35236782fe9eaa67a85efdf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>* decaf::internal::nio::ByteArrayBuffer::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new byte buffer that shares this buffer's content.The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>a new Byte <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> which the caller owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a89f24a679360f0fd97e4b0be4fba6032">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d7ce119416783ca914675db93991be"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::get" ref="ad3d7ce119416783ca914675db93991be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char decaf::internal::nio::ByteArrayBuffer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relative get method.Reads the byte at this buffer's current position, and then increments the position.<dl class="return"><dt><b>Returns:</b></dt><dd>The byte at the buffer's current position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if the buffer's current position is not smaller than its limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1021a589ff8a5a7b64396fddaf2ee417">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a2cbfcd1386e1e219b679fe4ec2414eba"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::get" ref="a2cbfcd1386e1e219b679fe4ec2414eba" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char decaf::internal::nio::ByteArrayBuffer::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Absolute get method.Reads the byte at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte that is located at the given index.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a54eb6b93d99aee42723a1a7ee23370ef">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a716e6514c00647d3ba34a54d286e7f19"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getChar" ref="a716e6514c00647d3ba34a54d286e7f19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::nio::ByteArrayBuffer::getChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the next byte at this buffer's current position, and then increments the position by one.<dl class="return"><dt><b>Returns:</b></dt><dd>the next char in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a4c8b75dc302195f745e163c25b51d55d">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a3eeed0099b82fe82ca66cf69614d2ba9"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getChar" ref="a3eeed0099b82fe82ca66cf69614d2ba9" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char decaf::internal::nio::ByteArrayBuffer::getChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads one byte at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the byte is to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char at the given index in the buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ad6b7b8ee792ee3b84d454ee9457ce416">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1f52edcd8a4bc9dd2db604c149e4451c"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getDouble" ref="a1f52edcd8a4bc9dd2db604c149e4451c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::internal::nio::ByteArrayBuffer::getDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the next eight bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next double in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#aff2beacb86e0d6ba133903b98b7d7577">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="af167abba3f2a52b4b2d6d2ca2692a7fc"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getDouble" ref="af167abba3f2a52b4b2d6d2ca2692a7fc" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double decaf::internal::nio::ByteArrayBuffer::getDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads eight bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the double at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index is not smaller than the buffer's limit, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a294cf335f19de2e22c4b055cfe90f036">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac22c51dc10d8e040ee3aca24469cb9e7"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getFloat" ref="ac22c51dc10d8e040ee3aca24469cb9e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::internal::nio::ByteArrayBuffer::getFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the next four bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next float in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a6551924712e717a1a91363ee1b2bacb1">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="adbfc001c2239e604f43c0bd37a8ff9bb"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getFloat" ref="adbfc001c2239e604f43c0bd37a8ff9bb" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float decaf::internal::nio::ByteArrayBuffer::getFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads four bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the float at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#acf364fa00fd42d432a5380916aa2695c">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab7c93abc43c250a610943e987d6d4cec"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getInt" ref="ab7c93abc43c250a610943e987d6d4cec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::nio::ByteArrayBuffer::getInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the next four bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next int in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a6c93fd1af57b77476e033366341b387f">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a07f6271ed0438e0fed8f74d31839ee10"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getInt" ref="a07f6271ed0438e0fed8f74d31839ee10" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::internal::nio::ByteArrayBuffer::getInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads four bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the int at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ab83180c5e7213e6d5ea884a0a639b596">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a177d0e5939d7ff274efe110669c93a83"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getLong" ref="a177d0e5939d7ff274efe110669c93a83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::internal::nio::ByteArrayBuffer::getLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the next eight bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next long long in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ad24de40747a3e7b37a1de873cba78633">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ac6fa5397b4c01cab3ecf066a2d498b2b"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getLong" ref="ac6fa5397b4c01cab3ecf066a2d498b2b" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::internal::nio::ByteArrayBuffer::getLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads eight bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the long long at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a876ee8665b7273ebbd9f3afdca9e2318">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a7495ef1ffef98ecce4188770179daf6c"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getShort" ref="a7495ef1ffef98ecce4188770179daf6c" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::internal::nio::ByteArrayBuffer::getShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads two bytes at the given index and returns it.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> where the bytes are to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the short at the given index in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if there are not enough bytes remaining to fill the requested Data Type, or index is negative.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#afe70d35ca28a8c61f97fd69e833c85ca">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aad66bb88a93fe63a04026860ac1fa641"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::getShort" ref="aad66bb88a93fe63a04026860ac1fa641" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual short decaf::internal::nio::ByteArrayBuffer::getShort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the next two bytes at this buffer's current position, and then increments the position by that amount.<dl class="return"><dt><b>Returns:</b></dt><dd>the next short in the buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_underflow_exception.html">BufferUnderflowException</a></td><td>if there are no more bytes remaining in this buffer, meaning we have reached the set limit.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ae4118e4a4d10a9809258361ed72604d2">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab88d3d871be65718a26bc10480fa1c00"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::hasArray" ref="ab88d3d871be65718a26bc10480fa1c00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::nio::ByteArrayBuffer::hasArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether or not this buffer is backed by an accessible byte array.If this method returns true then the array and arrayOffset methods may safely be invoked. Subclasses should override this method if they do not have a backing array as this class always returns true.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is backed by an array and is not read-only.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a9b0922b991f6c413dc51ed65be44143c">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a81ed73baffb070f694bcc9cd5496412a"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::isReadOnly" ref="a81ed73baffb070f694bcc9cd5496412a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::internal::nio::ByteArrayBuffer::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether or not this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>true if, and only if, this buffer is read-only</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a71a16a78a10394b0c4ad2e50164449f4">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a6eea85981ad91107ceece849466a6e10"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::put" ref="a6eea85981ad91107ceece849466a6e10" args="(unsigned char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::put </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given byte into this buffer at the current position, and then increments the position.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the byte value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if this buffer's current position is not smaller than its limit. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a39d985729bc52b8544017750524de848">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="aa34cd944bff34ae3968d15471d7b6072"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::put" ref="aa34cd944bff34ae3968d15471d7b6072" args="(int index, unsigned char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the given byte into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>- the byte to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ad37fa6fdd28d285ef95a49638a7a9533">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a58d45611f423e101722a99a4a7599faa"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putChar" ref="a58d45611f423e101722a99a4a7599faa" args="(int index, char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putChar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes one byte containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a7cfd5a378186f655054b04c5fccc609a">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a940d4fe71592ea67e83d1d754f34e46f"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putChar" ref="a940d4fe71592ea67e83d1d754f34e46f" args="(char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putChar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes one byte containing the given value, into this buffer at the current position, and then increments the position by one.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#acb01d88222596127e6b04481753cbd93">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="adf4135569f27184cb922dfff238321c8"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putDouble" ref="adf4135569f27184cb922dfff238321c8" args="(int index, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a2e5fba824a16167a08a475f23dc209c0">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a5648f055607827df32cfdb8074e957f2"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putDouble" ref="a5648f055607827df32cfdb8074e957f2" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putDouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1af3af332422adb4b5815b4e9b7aa530">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a5108c794c9a9fd260ce4600c50630950"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putFloat" ref="a5108c794c9a9fd260ce4600c50630950" args="(int index, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a1479865e4cc56ebd53a8631e01a09cc4">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a937d1ae4adcf0d609cd1c591fb4a30ec"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putFloat" ref="a937d1ae4adcf0d609cd1c591fb4a30ec" args="(float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#ac1590f34862aabd866511092e97d6c67">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ab310c1792f41c39f47cb5eabc8fee616"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putInt" ref="ab310c1792f41c39f47cb5eabc8fee616" args="(int index, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a49586a0d91f0acaeee94686d62b353e7">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a29d457e7218784933a824c7b1e6f04bd"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putInt" ref="a29d457e7218784933a824c7b1e6f04bd" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes four bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a0cdd7b6fe26dd2be2439ece7021e32e0">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a01dd135accd07d0f60fa71d1b7de2212"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putLong" ref="a01dd135accd07d0f60fa71d1b7de2212" args="(long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putLong </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a2f54211693791fa27712c2ae1f4118b8">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a2c432f0586df4f41241234ec79cc94a8"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putLong" ref="a2c432f0586df4f41241234ec79cc94a8" args="(int index, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes eight bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a707363f3332e99c50588c115024e74bc">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="acd90cd9ec81335165a2e7fdcc19d400f"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putShort" ref="acd90cd9ec81335165a2e7fdcc19d400f" args="(short value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the current position, and then increments the position by eight.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_buffer_overflow_exception.html">BufferOverflowException</a></td><td>if there are fewer than bytes remaining in this buffer than the size of the data to be written. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a75f718c0f2d78861124f20f7096179ca">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a8dfa4f8108273882549629e905ebae04"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::putShort" ref="a8dfa4f8108273882549629e905ebae04" args="(int index, short value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>&amp; decaf::internal::nio::ByteArrayBuffer::putShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes two bytes containing the given value, into this buffer at the given index.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position in the <a class="el" href="classdecaf_1_1nio_1_1_buffer.html" title="A container for data of a specific primitive type.">Buffer</a> to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to this buffer</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if index greater than the buffer's limit minus the size of the type being written, or index is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1nio_1_1_read_only_buffer_exception.html">ReadOnlyBufferException</a></td><td>if this buffer is read-only.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#affb006663301227c34cca892701eee5b">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="a1e33eb10a1d60814341969765085972b"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::setReadOnly" ref="a1e33eb10a1d60814341969765085972b" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::internal::nio::ByteArrayBuffer::setReadOnly </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets this <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteArrayBuffer</a> as Read-Only or not Read-Only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Boolean value, true if this buffer is to be read-only, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeeca3e501a41ff17730aaf3e675ba6e5"></a><!-- doxytag: member="decaf::internal::nio::ByteArrayBuffer::slice" ref="aeeca3e501a41ff17730aaf3e675ba6e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>* decaf::internal::nio::ByteArrayBuffer::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new byte buffer whose content is a shared subsequence of this buffer's content.The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be read-only if, and only if, this buffer is read-only.<dl class="return"><dt><b>Returns:</b></dt><dd>the newly create <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html" title="This class defines six categories of operations upon byte buffers:">ByteBuffer</a> which the caller owns.</dd></dl>
 </p>

<p>Implements <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html#a4cb7a384370045ad2376681d40db4c04">decaf::nio::ByteBuffer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/nio/<a class="el" href="_byte_array_buffer_8h_source.html">ByteArrayBuffer.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1nio.html">nio</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_byte_array_buffer.html">ByteArrayBuffer</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
