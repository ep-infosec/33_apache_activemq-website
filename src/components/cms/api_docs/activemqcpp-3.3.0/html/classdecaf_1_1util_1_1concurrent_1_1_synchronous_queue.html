<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::concurrent::SynchronousQueue&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::concurrent::SynchronousQueue&lt; E &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::concurrent::SynchronousQueue" --><!-- doxytag: inherits="decaf::util::concurrent::BlockingQueue" -->
<p>A <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html">blocking queue</a> in which each insert operation must wait for a corresponding remove operation by another thread, and vice versa.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_synchronous_queue_8h_source.html">src/main/decaf/util/concurrent/SynchronousQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::SynchronousQueue&lt; E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1_synchronous_queue_3_01_e_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1_synchronous_queue_3_01_e_01_4_inherit__map" id="decaf_1_1util_1_1concurrent_1_1_synchronous_queue_3_01_e_01_4_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html" title="A decaf::util::Queue that additionally supports operations that wait for the queue to become non&#45;empt..." alt="" coords="75,315,397,344"/><area shape="rect" id="node4" href="classdecaf_1_1util_1_1_abstract_queue.html" title="This class provides skeletal implementations of some Queue operations." alt="" coords="115,237,357,267"/><area shape="rect" id="node6" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion..." alt="" coords="20,160,204,189"/><area shape="rect" id="node8" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy." alt="" coords="133,83,339,112"/><area shape="rect" id="node14" href="classdecaf_1_1util_1_1_abstract_collection.html" title="This class provides a skeletal implementation of the Collection interface, to minimize the effort req..." alt="" coords="228,160,495,189"/><area shape="rect" id="node10" href="classdecaf_1_1lang_1_1_iterable.html" title="Implementing this interface allows an object to be cast to an Iterable type for generic collections A..." alt="" coords="5,5,203,35"/><area shape="rect" id="node12" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="227,5,512,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>EmptyIterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#acdf7a245c12ac998f3e9c1b526cf142d">SynchronousQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a2ff6cac4e54a6a1b3f6cc125f6c1c35a">~SynchronousQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#ada6346e053c6f59a9b32780c64ee5cbf">put</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified element to this queue, waiting if necessary for another thread to receive it.  <a href="#ada6346e053c6f59a9b32780c64ee5cbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a9df7b8c7344207dd5949638e833d21f5">offer</a> (const E &amp;e, long long timeout, const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.  <a href="#a9df7b8c7344207dd5949638e833d21f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a12f5c06d9522fefe9bc170ced84261ee">offer</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element into this queue, if another thread is waiting to receive it.  <a href="#a12f5c06d9522fefe9bc170ced84261ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#afac7f4916621cc7bb6507aef613ccf42">take</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.  <a href="#afac7f4916621cc7bb6507aef613ccf42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#aff18d0dcff547995fcbe76804f4070bf">poll</a> (E &amp;result, long long timeout, const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.  <a href="#aff18d0dcff547995fcbe76804f4070bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#af4e99353e1ae3dc9e12cba846027deef">poll</a> (E &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the head of this queue, if another thread is currently making an element available.  <a href="#af4e99353e1ae3dc9e12cba846027deef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a126c876c8f8a3a18b5f49fbbe6a6ae8b">equals</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers true if this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> and the one given are the same size and if each element contained in the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> given is equal to an element contained in this collection.  <a href="#a126c876c8f8a3a18b5f49fbbe6a6ae8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#ae675b81636a7b477aade73b935cca0e3">iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a43f1f0e9dc0ecddee0f0cd3eddd554ed">iterator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a33c9ed046c54b1bc09a42d712955c725">isEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains no elements.  <a href="#a33c9ed046c54b1bc09a42d712955c725"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a356cfc7022ead025059c9518c7f4fd4a">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this collection.  <a href="#a356cfc7022ead025059c9518c7f4fd4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#ad422f0868c7484c9530e3133f749f81c">remainingCapacity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or <code>Integer::MAX_VALUE</code> if there is no intrinsic limit.  <a href="#ad422f0868c7484c9530e3133f749f81c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a05fa5351bd3c3fb4fc565ced04031609">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the elements from this collection (optional operation).The collection will be empty after this method returns.This implementation iterates over this collection, removing each element using the <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">Iterator.remove</a> operation. Most implementations will probably choose to override this method for efficiency.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the clear operation is not supported by this collection</td></tr>
  </table>
  </dd>
</dl>
This implementation repeatedly invokes poll until it returns false.  <a href="#a05fa5351bd3c3fb4fc565ced04031609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a18d442096ae68b0e291ebcf5f8708ce9">contains</a> (const E &amp;value DECAF_UNUSED) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#ab81d48c782c7a6cf0bfbd9fb1252d40e">containsAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains all of the elements in the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to compare to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check).</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false.  <a href="#ab81d48c782c7a6cf0bfbd9fb1252d40e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a3833c8f5076cc4c4cf6d7b95d3d41b1e">remove</a> (const E &amp;value DECAF_UNUSED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a3b8e775954def04b73975b5d98d12f72">removeAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection DECAF_UNUSED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a586a3211b2e096c8b12ff3b0a0fb9b38">retainAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection DECAF_UNUSED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a60a18973b985089aca8b5fb8449fe540">peek</a> (E &amp;result DECAF_UNUSED) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#af6727c753178464bbe82856a1b564222">toArray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers an STL vector containing copies of all elements contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.  <a href="#af6727c753178464bbe82856a1b564222"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a5b0647a30d31fc130cc0daa2c2679cf9">drainTo</a> (<a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all available elements from this queue and adds them to the given collection.  <a href="#a5b0647a30d31fc130cc0daa2c2679cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a16122744149fa45ec628e6a2a24111b4">drainTo</a> (<a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;c, int maxElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes at most the given number of available elements from this queue and adds them to the given collection.  <a href="#a16122744149fa45ec628e6a2a24111b4"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename E&gt;<br/>
 class decaf::util::concurrent::SynchronousQueue&lt; E &gt;</h3>

<p>A <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html">blocking queue</a> in which each insert operation must wait for a corresponding remove operation by another thread, and vice versa. </p>
<p>A synchronous queue does not have any internal capacity, not even a capacity of one. You cannot <code>peek</code> at a synchronous queue because an element is only present when you try to remove it; you cannot insert an element (using any method) unless another thread is trying to remove it; you cannot iterate as there is nothing to iterate. The <em>head</em> of the queue is the element that the first queued inserting thread is trying to add to the queue; if there is no such queued thread then no element is available for removal and <code><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#aff18d0dcff547995fcbe76804f4070bf" title="Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time...">poll()</a></code> will return <code>null</code>. For purposes of other <code><a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a></code> methods (for example <code>contains</code>), a <code><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html" title="A blocking queue in which each insert operation must wait for a corresponding remove operation by ano...">SynchronousQueue</a></code> acts as an empty collection. This queue does not permit <code>null</code> elements.</p>
<p>Synchronous queues are similar to rendezvous channels used in CSP and Ada. They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or task.</p>
<p>This class supports an optional fairness policy for ordering waiting producer and consumer threads. By default, this ordering is not guaranteed. However, a queue constructed with fairness set to <code>true</code> grants threads access in FIFO order.</p>
<p>This class and its iterator implement all of the <em>optional</em> methods of the <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a> and <a class="el" href="classdecaf_1_1util_1_1_iterator.html">Iterator</a> interfaces.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acdf7a245c12ac998f3e9c1b526cf142d"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::SynchronousQueue" ref="acdf7a245c12ac998f3e9c1b526cf142d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">SynchronousQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ff6cac4e54a6a1b3f6cc125f6c1c35a"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::~SynchronousQueue" ref="a2ff6cac4e54a6a1b3f6cc125f6c1c35a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::~<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">SynchronousQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a05fa5351bd3c3fb4fc565ced04031609"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::clear" ref="a05fa5351bd3c3fb4fc565ced04031609" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all of the elements from this collection (optional operation).The collection will be empty after this method returns.This implementation iterates over this collection, removing each element using the <a class="el" href="classdecaf_1_1util_1_1_iterator.html#a3ef3d1121d22fa80df4f9361834f409c" title="Removes from the underlying collection the last element returned by the iterator (optional operation)...">Iterator.remove</a> operation. Most implementations will probably choose to override this method for efficiency.Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the clear operation is not supported by this collection</td></tr>
  </table>
  </dd>
</dl>
This implementation repeatedly invokes poll until it returns false. </p>
<p>This implementation repeatedly invokes poll until it returns false. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_queue.html#aad23c7d39e8189aacada830a171f59be">decaf::util::AbstractQueue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a18d442096ae68b0e291ebcf5f8708ce9"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::contains" ref="a18d442096ae68b0e291ebcf5f8708ce9" args="(const E &amp;value DECAF_UNUSED) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;value&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab81d48c782c7a6cf0bfbd9fb1252d40e"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::containsAll" ref="ab81d48c782c7a6cf0bfbd9fb1252d40e" args="(const Collection&lt; E &gt; &amp;collection) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::containsAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains all of the elements in the specified collection.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to compare to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check).</td></tr>
  </table>
  </dd>
</dl>
This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false. </p>
<p>This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#ae9f003bc1db10e347afa595979fc4c05">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1_collection.html#aefdd40e6bc9875cf50e2b7d5c10b94f7">decaf::util::Collection&lt; E &gt;::isEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b0647a30d31fc130cc0daa2c2679cf9"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::drainTo" ref="a5b0647a30d31fc130cc0daa2c2679cf9" args="(Collection&lt; E &gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::drainTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all available elements from this queue and adds them to the given collection. </p>
<p>This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection <code>c</code> may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in <code>IllegalArgumentException</code>. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the collection to transfer elements into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements transferred </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if addition of elements is not supported by the specified collection </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the specified collection is this queue, or some property of an element of this queue prevents it from being added to the specified collection </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#ae296a4cdb0aa17b1255d5bfbd1915549">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1_collection.html#a3b1fb8d6d75a6a8de1096e2af59c93b7">decaf::util::Collection&lt; E &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1_abstract_queue.html#a69e1b64fa43b083702f23ac3261ddadf">decaf::util::AbstractQueue&lt; E &gt;::element()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#aff18d0dcff547995fcbe76804f4070bf">decaf::util::concurrent::SynchronousQueue&lt; E &gt;::poll()</a>.</p>

</div>
</div>
<a class="anchor" id="a16122744149fa45ec628e6a2a24111b4"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::drainTo" ref="a16122744149fa45ec628e6a2a24111b4" args="(Collection&lt; E &gt; &amp;c, int maxElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::drainTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes at most the given number of available elements from this queue and adds them to the given collection. </p>
<p>A failure encountered while attempting to add elements to collection <code>c</code> may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in <code>IllegalArgumentException</code>. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the collection to transfer elements into </td></tr>
    <tr><td class="paramname">maxElements</td><td>the maximum number of elements to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements transferred </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if addition of elements is not supported by the specified collection </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the specified collection is this queue, or some property of an element of this queue prevents it from being added to the specified collection </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#a02de5b804a7128865d178459c7e8a3ca">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1_collection.html#a3b1fb8d6d75a6a8de1096e2af59c93b7">decaf::util::Collection&lt; E &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1_abstract_queue.html#a69e1b64fa43b083702f23ac3261ddadf">decaf::util::AbstractQueue&lt; E &gt;::element()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#aff18d0dcff547995fcbe76804f4070bf">decaf::util::concurrent::SynchronousQueue&lt; E &gt;::poll()</a>.</p>

</div>
</div>
<a class="anchor" id="a126c876c8f8a3a18b5f49fbbe6a6ae8b"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::equals" ref="a126c876c8f8a3a18b5f49fbbe6a6ae8b" args="(const Collection&lt; E &gt; &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Answers true if this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> and the one given are the same size and if each element contained in the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> given is equal to an element contained in this collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>- The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to be compared to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is equal to the one given. </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a894957e0b25c2e644768d7a4bc7a9fe3">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a33c9ed046c54b1bc09a42d712955c725"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::isEmpty" ref="a33c9ed046c54b1bc09a42d712955c725" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains no elements. </p>
<p>This implementation returns <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a356cfc7022ead025059c9518c7f4fd4a" title="Returns the number of elements in this collection.">size()</a> == 0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the size method return 0. </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#adff8de8d2b0f370696265aab914df735">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a43f1f0e9dc0ecddee0f0cd3eddd554ed"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::iterator" ref="a43f1f0e9dc0ecddee0f0cd3eddd554ed" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a8df8d3e4976a76be399adea077c4edb2">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae675b81636a7b477aade73b935cca0e3"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::iterator" ref="ae675b81636a7b477aade73b935cca0e3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator over a set of elements of type T. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a1bf9dd78d7826b61fb59901e29d59857">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9df7b8c7344207dd5949638e833d21f5"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::offer" ref="a9df7b8c7344207dd5949638e833d21f5" args="(const E &amp;e, long long timeout, const TimeUnit &amp;unit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::offer </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if successful, or <code>false</code> if the specified waiting time elapses before a consumer appears.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#a13c30e5dc2e330e7e0ecba7bac0d4d1c">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a12f5c06d9522fefe9bc170ced84261ee"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::offer" ref="a12f5c06d9522fefe9bc170ced84261ee" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::offer </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element into this queue, if another thread is waiting to receive it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the element to add to the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the element was added to this queue, else <code>false</code></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> implementation does not allow Null values to be inserted into the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the specified element prevents it from being added to this queue </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_queue.html#af66759e10a969e7aa99f217efefe33af">decaf::util::Queue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a60a18973b985089aca8b5fb8449fe540"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::peek" ref="a60a18973b985089aca8b5fb8449fe540" args="(E &amp;result DECAF_UNUSED) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">E &amp;result&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff18d0dcff547995fcbe76804f4070bf"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::poll" ref="aff18d0dcff547995fcbe76804f4070bf" args="(E &amp;result, long long timeout, const TimeUnit &amp;unit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::poll </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_time_unit.html">TimeUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>a reference to the value where the head of the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> should be copied to. </td></tr>
    <tr><td class="paramname">timeout</td><td>the time that the method should block if there is no element available to return. </td></tr>
    <tr><td class="paramname">unit</td><td>the Time Units that the timeout value represents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the head of the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> was copied to the result param or false if no value could be returned. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#ada32b9d8fc257f4dde82c427aa445e81">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html#a5b0647a30d31fc130cc0daa2c2679cf9">decaf::util::concurrent::SynchronousQueue&lt; E &gt;::drainTo()</a>.</p>

</div>
</div>
<a class="anchor" id="af4e99353e1ae3dc9e12cba846027deef"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::poll" ref="af4e99353e1ae3dc9e12cba846027deef" args="(E &amp;result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::poll </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves and removes the head of this queue, if another thread is currently making an element available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>a reference to the value where the head of the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> should be copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the head of the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> was copied to the result param or false if no value could be returned. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_queue.html#a3f3aa86736798877441dfdbfb398dc5c">decaf::util::Queue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ada6346e053c6f59a9b32780c64ee5cbf"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::put" ref="ada6346e053c6f59a9b32780c64ee5cbf" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the specified element to this queue, waiting if necessary for another thread to receive it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the element to add to the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>Inserts the specified element into this queue, waiting if necessary for space to become available. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>Inserts the specified element into this queue, waiting if necessary for space to become available. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>Inserts the specified element into this queue, waiting if necessary for space to become available. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#a109657d5c0181f631872e8533d5dcc09">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad422f0868c7484c9530e3133f749f81c"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::remainingCapacity" ref="ad422f0868c7484c9530e3133f749f81c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::remainingCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or <code>Integer::MAX_VALUE</code> if there is no intrinsic limit. </p>
<p>Note that you <em>cannot</em> always tell if an attempt to insert an element will succeed by inspecting <code>remainingCapacity</code> because it may be the case that another thread is about to insert or remove an element.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remaining capacity </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#af2f7fc6e2e973e9b7e7558c0add39d42">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3833c8f5076cc4c4cf6d7b95d3d41b1e"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::remove" ref="a3833c8f5076cc4c4cf6d7b95d3d41b1e" args="(const E &amp;value DECAF_UNUSED)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const E &amp;value&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b8e775954def04b73975b5d98d12f72"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::removeAll" ref="a3b8e775954def04b73975b5d98d12f72" args="(const Collection&lt; E &gt; &amp;collection DECAF_UNUSED)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a586a3211b2e096c8b12ff3b0a0fb9b38"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::retainAll" ref="a586a3211b2e096c8b12ff3b0a0fb9b38" args="(const Collection&lt; E &gt; &amp;collection DECAF_UNUSED)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::retainAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection&#160;</td>
          <td class="paramname"><em>DECAF_UNUSED</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a356cfc7022ead025059c9518c7f4fd4a"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::size" ref="a356cfc7022ead025059c9518c7f4fd4a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of elements in this collection. </p>
<p>If this collection contains more than Integer::MAX_VALUE elements, returns Integer::MAX_VALUE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements in this collection </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#aad34433902f20bd422f64b14f51998cf">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afac7f4916621cc7bb6507aef613ccf42"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::take" ref="afac7f4916621cc7bb6507aef613ccf42" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the head of this queue </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_blocking_queue.html#ae01d0599ddb1a0da802bbfef26c1b3dc">decaf::util::concurrent::BlockingQueue&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af6727c753178464bbe82856a1b564222"></a><!-- doxytag: member="decaf::util::concurrent::SynchronousQueue::toArray" ref="af6727c753178464bbe82856a1b564222" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;E&gt; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">decaf::util::concurrent::SynchronousQueue</a>&lt; E &gt;::toArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Answers an STL vector containing copies of all elements contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>. </p>
<p>All the elements in the array will not be referenced by the collection. The elements in the returned array will be sorted to the same order as those returned by the iterator of this collection itself if the collection guarantees the order.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an vector of copies of all the elements from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classdecaf_1_1util_1_1_abstract_collection.html#a167776fb00a8924828424616e3b6f3b8">decaf::util::AbstractCollection&lt; E &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/<a class="el" href="_synchronous_queue_8h_source.html">SynchronousQueue.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronous_queue.html">SynchronousQueue</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
