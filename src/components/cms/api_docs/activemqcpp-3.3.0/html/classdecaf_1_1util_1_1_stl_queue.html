<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::StlQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1_stl_queue.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::StlQueue&lt; T &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::StlQueue" --><!-- doxytag: inherits="decaf::util::concurrent::Synchronizable" -->
<p>The <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> class accepts messages with an psuh(m) command where m is the message to be queued.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_stl_queue_8h_source.html">src/main/decaf/util/StlQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::StlQueue&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1_stl_queue__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1_stl_queue_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1_stl_queue_3_01_t_01_4_inherit__map" id="decaf_1_1util_1_1_stl_queue_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="5,5,291,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>QueueIterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a74bfeb0e8b7871199e5f794002c0a171">StlQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a3bbd9e304ce5dac9c2d39b3aeb039d37">~StlQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1_iterator.html">Iterator</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#aac149b04dd11ada9317b0310eaf57c34">iterator</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an <a class="el" href="classdecaf_1_1util_1_1_iterator.html" title="Defines an object that can be used to iterate over the elements of a collection.">Iterator</a> over this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.  <a href="#aac149b04dd11ada9317b0310eaf57c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#ad9a7e2653bd623022f7681a4cfb7ee20">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties this queue.  <a href="#ad9a7e2653bd623022f7681a4cfb7ee20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#ad49fa34b1f09b55f37c72696d4d4c095">front</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reference to the element at the head of the queue.  <a href="#ad49fa34b1f09b55f37c72696d4d4c095"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a725f51322c27ee064adef26bd91ba2d3">front</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reference to the element at the head of the queue.  <a href="#a725f51322c27ee064adef26bd91ba2d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a5e872245c5a1b27ddc6989f243dc33c4">back</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reference to the element at the tail of the queue.  <a href="#a5e872245c5a1b27ddc6989f243dc33c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a90f7a2437214b9b274f6a12cd1caf628">back</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reference to the element at the tail of the queue.  <a href="#a90f7a2437214b9b274f6a12cd1caf628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#adc54594ccb06273aa3a06d7bde18c968">push</a> (const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a new Object at the Tail of the queue.  <a href="#adc54594ccb06273aa3a06d7bde18c968"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a1e3a3b4a23d643c6e2a6df0042397844">enqueueFront</a> (const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a new Object at the front of the queue.  <a href="#a1e3a3b4a23d643c6e2a6df0042397844"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#abf87dbcc5808ce4ae412f18accab86b1">pop</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the element that is at the Head of the queue.  <a href="#abf87dbcc5808ce4ae412f18accab86b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#aecffeeae59e4b11c3d5469011d3841f9">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Number of elements currently in the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.  <a href="#aecffeeae59e4b11c3d5469011d3841f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#ac5144e818d8a0e643f120e823e45d10d">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> is currently empty.  <a href="#ac5144e818d8a0e643f120e823e45d10d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a96ef6656d2314e0bdf06ba3c29779458">toArray</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a60230704b5ebb24d0888134ffe879f6e">reverse</a> (<a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">StlQueue</a>&lt; T &gt; &amp;target) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the contents of this queue and stores them in the target queue.  <a href="#a60230704b5ebb24d0888134ffe879f6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a2cdea1cdd8c7944295c0f06079e8089c">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the object.  <a href="#a2cdea1cdd8c7944295c0f06079e8089c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#aacfbedfd89b1736474e7128cc40c6ece">tryLock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to Lock the object, if the lock is already held by another thread than this method returns false.  <a href="#aacfbedfd89b1736474e7128cc40c6ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a59cdf5e83458e4a888bb5c0c3c57b24c">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the object.  <a href="#a59cdf5e83458e4a888bb5c0c3c57b24c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a59c25e1831c3dbaff3a7399a02ef9462">wait</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a59c25e1831c3dbaff3a7399a02ef9462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#ab184526c3a34a708129368910ce48893">wait</a> (long long millisecs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#ab184526c3a34a708129368910ce48893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a0a609e9d8567902e25b88f88f5df6ef2">wait</a> (long long millisecs, int nanos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a0a609e9d8567902e25b88f88f5df6ef2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#ade6c5d0ac8023550797bbe26297824fa">notify</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals a waiter on this object that it can now wake up and continue.  <a href="#ade6c5d0ac8023550797bbe26297824fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#aa11de7a3bbc8ab952ba46372825f1e64">notifyAll</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the waiters on this object that it can now wake up and continue.  <a href="#aa11de7a3bbc8ab952ba46372825f1e64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a8572ce13b284aabd8d1400b1147f296e">getSafeValue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a reference to the safe value this object will return when there is nothing to fetch from the queue.  <a href="#a8572ce13b284aabd8d1400b1147f296e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
 class decaf::util::StlQueue&lt; T &gt;</h3>

<p>The <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> class accepts messages with an psuh(m) command where m is the message to be queued. </p>
<p>It destructively returns the message with <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#abf87dbcc5808ce4ae412f18accab86b1" title="Removes and returns the element that is at the Head of the queue.">pop()</a>. <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#abf87dbcc5808ce4ae412f18accab86b1" title="Removes and returns the element that is at the Head of the queue.">pop()</a> returns messages in the order they were enqueued.</p>
<p><a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> is implemented with an instance of the STL queue object. The interface is essentially the same as that of the STL queue except that the pop method actually reaturns a reference to the element popped. This frees the app from having to call the <code>front</code> method before calling pop.</p>
<p>Queue&lt;string&gt; sq; // make a queue to hold string messages sq.push(s); // enqueues a message m string s = sq.pop(); // dequeues a message</p>
<p>= DESIGN CONSIDERATIONS</p>
<p>The <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> class inherits from the Synchronizable interface and provides methods for locking and unlocking this queue as well as waiting on this queue. In a multi-threaded app this can allow for multiple threads to be reading from and writing to the same <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>.</p>
<p>Clients should consider that in a multiple threaded app it is possible that items could be placed on the queue faster than you are taking them off, so protection should be placed in your polling loop to ensure that you don't get stuck there. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a74bfeb0e8b7871199e5f794002c0a171"></a><!-- doxytag: member="decaf::util::StlQueue::StlQueue" ref="a74bfeb0e8b7871199e5f794002c0a171" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::<a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">StlQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3bbd9e304ce5dac9c2d39b3aeb039d37"></a><!-- doxytag: member="decaf::util::StlQueue::~StlQueue" ref="a3bbd9e304ce5dac9c2d39b3aeb039d37" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::~<a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">StlQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5e872245c5a1b27ddc6989f243dc33c4"></a><!-- doxytag: member="decaf::util::StlQueue::back" ref="a5e872245c5a1b27ddc6989f243dc33c4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a Reference to the element at the tail of the queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to a queue type object or (safe) </dd></dl>

<p>References <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a8572ce13b284aabd8d1400b1147f296e">decaf::util::StlQueue&lt; T &gt;::getSafeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a90f7a2437214b9b274f6a12cd1caf628"></a><!-- doxytag: member="decaf::util::StlQueue::back" ref="a90f7a2437214b9b274f6a12cd1caf628" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a Reference to the element at the tail of the queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to a queue type object or (safe) </dd></dl>

<p>References <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a8572ce13b284aabd8d1400b1147f296e">decaf::util::StlQueue&lt; T &gt;::getSafeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9a7e2653bd623022f7681a4cfb7ee20"></a><!-- doxytag: member="decaf::util::StlQueue::clear" ref="ad9a7e2653bd623022f7681a4cfb7ee20" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empties this queue. </p>

</div>
</div>
<a class="anchor" id="ac5144e818d8a0e643f120e823e45d10d"></a><!-- doxytag: member="decaf::util::StlQueue::empty" ref="ac5144e818d8a0e643f120e823e45d10d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> is currently empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean indicating queue emptiness </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3a3b4a23d643c6e2a6df0042397844"></a><!-- doxytag: member="decaf::util::StlQueue::enqueueFront" ref="a1e3a3b4a23d643c6e2a6df0042397844" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::enqueueFront </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Places a new Object at the front of the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> Object Type reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a725f51322c27ee064adef26bd91ba2d3"></a><!-- doxytag: member="decaf::util::StlQueue::front" ref="a725f51322c27ee064adef26bd91ba2d3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a Reference to the element at the head of the queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to a queue type object or (safe) </dd></dl>

<p>References <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a8572ce13b284aabd8d1400b1147f296e">decaf::util::StlQueue&lt; T &gt;::getSafeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ad49fa34b1f09b55f37c72696d4d4c095"></a><!-- doxytag: member="decaf::util::StlQueue::front" ref="ad49fa34b1f09b55f37c72696d4d4c095" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a Reference to the element at the head of the queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to a queue type object or (safe) </dd></dl>

<p>References <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a8572ce13b284aabd8d1400b1147f296e">decaf::util::StlQueue&lt; T &gt;::getSafeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a8572ce13b284aabd8d1400b1147f296e"></a><!-- doxytag: member="decaf::util::StlQueue::getSafeValue" ref="a8572ce13b284aabd8d1400b1147f296e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::getSafeValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a reference to the safe value this object will return when there is nothing to fetch from the queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this Queues safe object </dd></dl>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a5e872245c5a1b27ddc6989f243dc33c4">decaf::util::StlQueue&lt; T &gt;::back()</a>, <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#ad49fa34b1f09b55f37c72696d4d4c095">decaf::util::StlQueue&lt; T &gt;::front()</a>, and <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#abf87dbcc5808ce4ae412f18accab86b1">decaf::util::StlQueue&lt; T &gt;::pop()</a>.</p>

</div>
</div>
<a class="anchor" id="aac149b04dd11ada9317b0310eaf57c34"></a><!-- doxytag: member="decaf::util::StlQueue::iterator" ref="aac149b04dd11ada9317b0310eaf57c34" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1_iterator.html">Iterator</a>&lt;T&gt;* <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an <a class="el" href="classdecaf_1_1util_1_1_iterator.html" title="Defines an object that can be used to iterate over the elements of a collection.">Iterator</a> over this <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new iterator pointer that is owned by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cdea1cdd8c7944295c0f06079e8089c"></a><!-- doxytag: member="decaf::util::StlQueue::lock" ref="a2cdea1cdd8c7944295c0f06079e8089c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the object. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while locking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aeff8d806ec08a8ebef540fc059947c48">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#a4e78aab407b995ebae8b6726c8e64a10">decaf::util::concurrent::Mutex::lock()</a>.</p>

</div>
</div>
<a class="anchor" id="ade6c5d0ac8023550797bbe26297824fa"></a><!-- doxytag: member="decaf::util::StlQueue::notify" ref="ade6c5d0ac8023550797bbe26297824fa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals a waiter on this object that it can now wake up and continue. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while notifying one of the waiting threads. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#ad62b154e5f2709b5471b00da52d0ad0b">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#abcf102f6b622c0e22dc8e30f3bf0d965">decaf::util::concurrent::Mutex::notify()</a>.</p>

</div>
</div>
<a class="anchor" id="aa11de7a3bbc8ab952ba46372825f1e64"></a><!-- doxytag: member="decaf::util::StlQueue::notifyAll" ref="aa11de7a3bbc8ab952ba46372825f1e64" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::notifyAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals the waiters on this object that it can now wake up and continue. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while notifying the waiting threads. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aa3af140ed7eded4f7ff59833c0bc619a">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#a5a0d0f047f4783bb3cc6ab9364452ac7">decaf::util::concurrent::Mutex::notifyAll()</a>.</p>

</div>
</div>
<a class="anchor" id="abf87dbcc5808ce4ae412f18accab86b1"></a><!-- doxytag: member="decaf::util::StlQueue::pop" ref="abf87dbcc5808ce4ae412f18accab86b1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes and returns the element that is at the Head of the queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to a queue type object or (safe) </dd></dl>

<p>References <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html#a8572ce13b284aabd8d1400b1147f296e">decaf::util::StlQueue&lt; T &gt;::getSafeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="adc54594ccb06273aa3a06d7bde18c968"></a><!-- doxytag: member="decaf::util::StlQueue::push" ref="adc54594ccb06273aa3a06d7bde18c968" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Places a new Object at the Tail of the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> Object Type reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60230704b5ebb24d0888134ffe879f6e"></a><!-- doxytag: member="decaf::util::StlQueue::reverse" ref="a60230704b5ebb24d0888134ffe879f6e" args="(StlQueue&lt; T &gt; &amp;target) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">StlQueue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the order of the contents of this queue and stores them in the target queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>- The target queue that will receive the contents of this queue in reverse order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecffeeae59e4b11c3d5469011d3841f9"></a><!-- doxytag: member="decaf::util::StlQueue::size" ref="aecffeeae59e4b11c3d5469011d3841f9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Number of elements currently in the <a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classdecaf_1_1util_1_1_queue.html" title="A kind of collection provides advanced operations than other basic collections, such as insertion...">Queue</a> Size </dd></dl>

</div>
</div>
<a class="anchor" id="a96ef6656d2314e0bdf06ba3c29779458"></a><!-- doxytag: member="decaf::util::StlQueue::toArray" ref="a96ef6656d2314e0bdf06ba3c29779458" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;T&gt; <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::toArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the all values in this queue as a std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aacfbedfd89b1736474e7128cc40c6ece"></a><!-- doxytag: member="decaf::util::StlQueue::tryLock" ref="aacfbedfd89b1736474e7128cc40c6ece" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::tryLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to Lock the object, if the lock is already held by another thread than this method returns false. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the lock was acquired, false if it is already held by another thread.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while locking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a6aa79e4c2590ec4387d7bb2b7d265c47">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#a8559b3d5780c8cd94e20e4139a1a5478">decaf::util::concurrent::Mutex::tryLock()</a>.</p>

</div>
</div>
<a class="anchor" id="a59cdf5e83458e4a888bb5c0c3c57b24c"></a><!-- doxytag: member="decaf::util::StlQueue::unlock" ref="a59cdf5e83458e4a888bb5c0c3c57b24c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the object. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while unlocking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aabb6c431936a7d4c9810a5f1a99bde21">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#a8f48a6e492a7cbfd1db7355725f29f14">decaf::util::concurrent::Mutex::unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a59c25e1831c3dbaff3a7399a02ef9462"></a><!-- doxytag: member="decaf::util::StlQueue::wait" ref="a59c25e1831c3dbaff3a7399a02ef9462" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a2f7a5619b8800c295626983b9c7808a6">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<a class="anchor" id="ab184526c3a34a708129368910ce48893"></a><!-- doxytag: member="decaf::util::StlQueue::wait" ref="ab184526c3a34a708129368910ce48893" args="(long long millisecs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>millisecs</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling. This wait will timeout after the specified time interval.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>the time in milliseconds to wait, or WAIT_INIFINITE</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a84939d5f17b846ba0aeb5824ec6fff41">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a609e9d8567902e25b88f88f5df6ef2"></a><!-- doxytag: member="decaf::util::StlQueue::wait" ref="a0a609e9d8567902e25b88f88f5df6ef2" args="(long long millisecs, int nanos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">decaf::util::StlQueue</a>&lt; T &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>millisecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling. This wait will timeout after the specified time interval. This method is similar to the one argument wait function except that it add a finer grained control over the amount of time that it waits by adding in the additional nanosecond argument.</p>
<p>NOTE: The ability to wait accurately at a nanosecond scale depends on the platform and OS that the Decaf API is running on, some systems do not provide an accurate enough clock to provide this level of granularity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>the time in milliseconds to wait, or WAIT_INIFINITE </td></tr>
    <tr><td class="paramname">nanos</td><td>additional time in nanoseconds with a range of 0-999999</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if an error occurs or the nanos argument is not in the range of [0-999999] </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the Synchronizable Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a954b500f0e3cba3a366da91e210893ea">decaf::util::concurrent::Synchronizable</a>.</p>

<p>References <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_mutex.html#aaaefb431e14629e3ccee7fa6136e9176">decaf::util::concurrent::Mutex::wait()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/<a class="el" href="_stl_queue_8h_source.html">StlQueue.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1_stl_queue.html">StlQueue</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
