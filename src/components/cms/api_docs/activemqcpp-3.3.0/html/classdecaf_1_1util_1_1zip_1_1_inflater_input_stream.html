<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::zip::InflaterInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>decaf::util::zip::InflaterInputStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::zip::InflaterInputStream" --><!-- doxytag: inherits="decaf::io::FilterInputStream" -->
<p>A FilterInputStream that decompresses data read from the wrapped InputStream instance.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_inflater_input_stream_8h_source.html">src/main/decaf/util/zip/InflaterInputStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::zip::InflaterInputStream:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1zip_1_1_inflater_input_stream_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1zip_1_1_inflater_input_stream_inherit__map" id="decaf_1_1util_1_1zip_1_1_inflater_input_stream_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1io_1_1_filter_input_stream.html" title="A FilterInputStream contains some other input stream, which it uses as its basic source of data..." alt="" coords="99,160,309,189"/><area shape="rect" id="node4" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea..." alt="" coords="116,83,292,112"/><area shape="rect" id="node6" href="classdecaf_1_1io_1_1_closeable.html" title="Interface for a class that implements the close method." alt="" coords="5,5,160,35"/><area shape="rect" id="node8" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="184,5,469,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a31958efa93d801d16e9a2c301f14738a">InflaterInputStream</a> (<a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *<a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a7f3bf93d01a14b8a0ae20f77e91c9a1a">inputStream</a>, bool <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a347c29a6e05c78777466ffe323872f89">own</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of this class with a default inflater and buffer size.  <a href="#a31958efa93d801d16e9a2c301f14738a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a5089251e707bab8d3da81e5222d5d3ae">InflaterInputStream</a> (<a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *<a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a7f3bf93d01a14b8a0ae20f77e91c9a1a">inputStream</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a> *<a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a758fc2488c353da538e42b74d84f7753">inflater</a>, bool <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a347c29a6e05c78777466ffe323872f89">own</a>=false, bool <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a4956212216e6bf5e7b2af83f3b5b636d">ownInflater</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a> with a user supplied <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> and a default buffer size.  <a href="#a5089251e707bab8d3da81e5222d5d3ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a42085e8052d038b8feb97f8a15bee243">InflaterInputStream</a> (<a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *<a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a7f3bf93d01a14b8a0ae20f77e91c9a1a">inputStream</a>, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a> *<a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a758fc2488c353da538e42b74d84f7753">inflater</a>, int bufferSize, bool <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a347c29a6e05c78777466ffe323872f89">own</a>=false, bool <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a4956212216e6bf5e7b2af83f3b5b636d">ownInflater</a>=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new DeflateOutputStream with a user supplied <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> and specified buffer size.  <a href="#a42085e8052d038b8feb97f8a15bee243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#ad987ed43645b067badcf4fda45e1fd3c">~InflaterInputStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a98ebc398888a57c05bd1c52f415d7a33">available</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the number of bytes available.The default implementation of this methods returns 0. Classes that override this method may return the total number of bytes that are currently available for reading and others may simply return a value of one indicating that there is some data avaiable. The caller should view the result of this method as an absolute.The default implementation of this method returns zero.<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes available on this input stream.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a98ebc398888a57c05bd1c52f415d7a33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a5ccc3334d7fec6890b2507f2783ca069">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> freeing any resources that might have been acquired during the lifetime of this stream.The default implementation of this method does nothing.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs while closing the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a>.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a5ccc3334d7fec6890b2507f2783ca069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#add21d387d1b17bcfd9cbd642e2f56095">skip</a> (long long num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips over and discards n bytes of data from this input stream.The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. This may result from any of a number of conditions; reaching end of file before n bytes have been skipped is only one possibility. The actual number of bytes skipped is returned.The skip method of <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> creates a byte array and then repeatedly reads into it until num bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The number of bytes to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>total bytes skipped</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the concrete stream class does not support skipping bytes.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#add21d387d1b17bcfd9cbd642e2f56095"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#aa3d00a554c5fff4805be07c8d50cf3d6">mark</a> (int readLimit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the current position in the stream A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes.If a stream instance reports that marks are supported then the stream will ensure that the same bytes can be read again after the reset method is called so long the readLimit is not reached.Calling mark on a closed stream instance should have no effect.The default implementation of this method does nothing.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">readLimit</td><td>The max bytes read before marked position is invalid.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#aa3d00a554c5fff4805be07c8d50cf3d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a79c9bffe9dbf065e96d774820d1a348e">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Repositions this stream to the position at the time the mark method was last called on this input stream.If the method markSupported returns true, then: * If the method mark has not been called since the stream was created, or the number of bytes read from the stream since mark was last called is larger than the argument to mark at that last call, then an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> might be thrown. * If such an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to mark (or since the start of the file, if mark has not been called) will be resupplied to subsequent callers of the read method, followed by any bytes that otherwise would have been the next input data as of the time of the call to reset.If the method markSupported returns false, then: * The call to reset may throw an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>. * If an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the read method depend on the particular type of the input stream.The default implementation of this method throws an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs.</td></tr>
  </table>
  </dd>
</dl>
  <a href="#a79c9bffe9dbf065e96d774820d1a348e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a5eca95e1b22556ac68ed7fb2f7f3f811">markSupported</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this input stream supports the mark and reset methods.Whether or not mark and reset are supported is an invariant property of a particular input stream instance.The default implementation of this method returns false.<dl class="return"><dt><b>Returns:</b></dt><dd>true if this stream instance supports marks</dd></dl>
  <a href="#a5eca95e1b22556ac68ed7fb2f7f3f811"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#ad47babe1e604a41a1bcfeeccbaf2221e">fill</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the input buffer with the next chunk of data.  <a href="#ad47babe1e604a41a1bcfeeccbaf2221e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a61fed11c09600bca777cecf51efafc2b">doReadByte</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a4527c3bb4d5532aa7c9b413131bb1cf9">doReadArrayBounded</a> (unsigned char *buffer, int size, int offset, int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#af024abaf13a948b41f889f1a71240bd9">length</a>)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a758fc2488c353da538e42b74d84f7753">inflater</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> instance to use.  <a href="#a758fc2488c353da538e42b74d84f7753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a377a550ed675073f9464ae1bf384e7ce">buff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer to hold chunks of data read from the stream before inflation.  <a href="#a377a550ed675073f9464ae1bf384e7ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#af024abaf13a948b41f889f1a71240bd9">length</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of data currently stored in the input buffer.  <a href="#af024abaf13a948b41f889f1a71240bd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a4956212216e6bf5e7b2af83f3b5b636d">ownInflater</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#ad2e203716e242df023f2201137278063">atEOF</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a887a5f232678dd8311151d0cb4aa73b3">DEFAULT_BUFFER_SIZE</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A FilterInputStream that decompresses data read from the wrapped InputStream instance. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a31958efa93d801d16e9a2c301f14738a"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::InflaterInputStream" ref="a31958efa93d801d16e9a2c301f14738a" args="(decaf::io::InputStream *inputStream, bool own=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::InflaterInputStream::InflaterInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an instance of this class with a default inflater and buffer size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputStream</td><td>The InputStream instance to wrap. </td></tr>
    <tr><td class="paramname">own</td><td>Should this Filter take ownership of the InputStream pointer (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5089251e707bab8d3da81e5222d5d3ae"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::InflaterInputStream" ref="a5089251e707bab8d3da81e5222d5d3ae" args="(decaf::io::InputStream *inputStream, Inflater *inflater, bool own=false, bool ownInflater=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::InflaterInputStream::InflaterInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a> *&#160;</td>
          <td class="paramname"><em>inflater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownInflater</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a> with a user supplied <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> and a default buffer size. </p>
<p>When the user supplied a <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> instance the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a> does not take ownership of the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> pointer unless the ownInflater parameter is set to true, otherwise the caller is still responsible for deleting the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputStream</td><td>The InputStream instance to wrap. </td></tr>
    <tr><td class="paramname">inflater</td><td>The user supplied <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> to use for decompression. ( </td></tr>
    <tr><td class="paramname">own</td><td>Should this filter take ownership of the InputStream pointer (default is false). </td></tr>
    <tr><td class="paramname">ownInflater</td><td>Should the filter take ownership of the passed <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> object (default is false).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> given is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42085e8052d038b8feb97f8a15bee243"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::InflaterInputStream" ref="a42085e8052d038b8feb97f8a15bee243" args="(decaf::io::InputStream *inputStream, Inflater *inflater, int bufferSize, bool own=false, bool ownInflater=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::InflaterInputStream::InflaterInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1io_1_1_input_stream.html">decaf::io::InputStream</a> *&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a> *&#160;</td>
          <td class="paramname"><em>inflater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownInflater</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new DeflateOutputStream with a user supplied <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> and specified buffer size. </p>
<p>When the user supplied a <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> instance the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a> does not take ownership of the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> pointer unless the ownInflater parameter is set to true, otherwise the caller is still responsible for deleting the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputStream</td><td>The InputStream instance to wrap. </td></tr>
    <tr><td class="paramname">inflater</td><td>The user supplied <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> to use for decompression. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the input buffer. </td></tr>
    <tr><td class="paramname">own</td><td>Should this filter take ownership of the InputStream pointer (default is false). </td></tr>
    <tr><td class="paramname">ownInflater</td><td>Should the filter take ownership of the passed <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> object (default is false).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> given is NULL. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the bufferSize value is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad987ed43645b067badcf4fda45e1fd3c"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::~InflaterInputStream" ref="ad987ed43645b067badcf4fda45e1fd3c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::util::zip::InflaterInputStream::~InflaterInputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a98ebc398888a57c05bd1c52f415d7a33"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::available" ref="a98ebc398888a57c05bd1c52f415d7a33" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::util::zip::InflaterInputStream::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the number of bytes available.The default implementation of this methods returns 0. Classes that override this method may return the total number of bytes that are currently available for reading and others may simply return a value of one indicating that there is some data avaiable. The caller should view the result of this method as an absolute.The default implementation of this method returns zero.<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes available on this input stream.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs.</td></tr>
  </table>
  </dd>
</dl>
 </p>
<p>Until EOF this method always returns 1, thereafter it always returns 0. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a0f755e6f29a0bf09f6c36f9cbd901a05">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a5ccc3334d7fec6890b2507f2783ca069"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::close" ref="a5ccc3334d7fec6890b2507f2783ca069" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::util::zip::InflaterInputStream::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> freeing any resources that might have been acquired during the lifetime of this stream.The default implementation of this method does nothing.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs while closing the <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a>.</td></tr>
  </table>
  </dd>
</dl>
 </p>
<p>Closes any resources associated with this <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a>. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a86fff21a2592c4b0e8654075b535a553">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a4527c3bb4d5532aa7c9b413131bb1cf9"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::doReadArrayBounded" ref="a4527c3bb4d5532aa7c9b413131bb1cf9" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::util::zip::InflaterInputStream::doReadArrayBounded </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a6d58708d0bd13acb46fa4884a0afabf3">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a61fed11c09600bca777cecf51efafc2b"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::doReadByte" ref="a61fed11c09600bca777cecf51efafc2b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int decaf::util::zip::InflaterInputStream::doReadByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#ab0514878c052c3b4b08954e6736a4173">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="ad47babe1e604a41a1bcfeeccbaf2221e"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::fill" ref="ad47babe1e604a41a1bcfeeccbaf2221e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::util::zip::InflaterInputStream::fill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the input buffer with the next chunk of data. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if an I/O error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3d00a554c5fff4805be07c8d50cf3d6"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::mark" ref="aa3d00a554c5fff4805be07c8d50cf3d6" args="(int readLimit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::util::zip::InflaterInputStream::mark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>readLimit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the current position in the stream A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes.If a stream instance reports that marks are supported then the stream will ensure that the same bytes can be read again after the reset method is called so long the readLimit is not reached.Calling mark on a closed stream instance should have no effect.The default implementation of this method does nothing.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">readLimit</td><td>The max bytes read before marked position is invalid.</td></tr>
  </table>
  </dd>
</dl>
 </p>
<p>Does nothing. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a669f86fa8c0da1f446b6f7ebb36110e0">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a5eca95e1b22556ac68ed7fb2f7f3f811"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::markSupported" ref="a5eca95e1b22556ac68ed7fb2f7f3f811" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool decaf::util::zip::InflaterInputStream::markSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if this input stream supports the mark and reset methods.Whether or not mark and reset are supported is an invariant property of a particular input stream instance.The default implementation of this method returns false.<dl class="return"><dt><b>Returns:</b></dt><dd>true if this stream instance supports marks</dd></dl>
 </p>
<p>Always returns false. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a41d5a8addb10ec53949813e57d27fb1b">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a79c9bffe9dbf065e96d774820d1a348e"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::reset" ref="a79c9bffe9dbf065e96d774820d1a348e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void decaf::util::zip::InflaterInputStream::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repositions this stream to the position at the time the mark method was last called on this input stream.If the method markSupported returns true, then: * If the method mark has not been called since the stream was created, or the number of bytes read from the stream since mark was last called is larger than the argument to mark at that last call, then an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> might be thrown. * If such an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to mark (or since the start of the file, if mark has not been called) will be resupplied to subsequent callers of the read method, followed by any bytes that otherwise would have been the next input data as of the time of the call to reset.If the method markSupported returns false, then: * The call to reset may throw an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>. * If an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a> is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the read method depend on the particular type of the input stream.The default implementation of this method throws an <a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a>.<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs.</td></tr>
  </table>
  </dd>
</dl>
 </p>
<p>Always throws an IOException when called. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a26b2960b011babbb14e532b580bc5bfb">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="add21d387d1b17bcfd9cbd642e2f56095"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::skip" ref="add21d387d1b17bcfd9cbd642e2f56095" args="(long long num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long decaf::util::zip::InflaterInputStream::skip </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skips over and discards n bytes of data from this input stream.The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. This may result from any of a number of conditions; reaching end of file before n bytes have been skipped is only one possibility. The actual number of bytes skipped is returned.The skip method of <a class="el" href="classdecaf_1_1io_1_1_input_stream.html" title="A base class that must be implemented by all classes wishing to provide a class that reads in a strea...">InputStream</a> creates a byte array and then repeatedly reads into it until num bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method.<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The number of bytes to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>total bytes skipped</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1io_1_1_i_o_exception.html">IOException</a></td><td>if an I/O error occurs. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the concrete stream class does not support skipping bytes.</td></tr>
  </table>
  </dd>
</dl>
 </p>
<p>Skips the specified amount of uncompressed input data. </p>

<p>Reimplemented from <a class="el" href="classdecaf_1_1io_1_1_filter_input_stream.html#a19d847009df788eb53c1d9dea7cbe0df">decaf::io::FilterInputStream</a>.</p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ad2e203716e242df023f2201137278063"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::atEOF" ref="ad2e203716e242df023f2201137278063" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#ad2e203716e242df023f2201137278063">decaf::util::zip::InflaterInputStream::atEOF</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a377a550ed675073f9464ae1bf384e7ce"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::buff" ref="a377a550ed675073f9464ae1bf384e7ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a377a550ed675073f9464ae1bf384e7ce">decaf::util::zip::InflaterInputStream::buff</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The buffer to hold chunks of data read from the stream before inflation. </p>

</div>
</div>
<a class="anchor" id="a887a5f232678dd8311151d0cb4aa73b3"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::DEFAULT_BUFFER_SIZE" ref="a887a5f232678dd8311151d0cb4aa73b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a887a5f232678dd8311151d0cb4aa73b3">decaf::util::zip::InflaterInputStream::DEFAULT_BUFFER_SIZE</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a758fc2488c353da538e42b74d84f7753"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::inflater" ref="a758fc2488c353da538e42b74d84f7753" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a>* <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a758fc2488c353da538e42b74d84f7753">decaf::util::zip::InflaterInputStream::inflater</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> instance to use. </p>

</div>
</div>
<a class="anchor" id="af024abaf13a948b41f889f1a71240bd9"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::length" ref="af024abaf13a948b41f889f1a71240bd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#af024abaf13a948b41f889f1a71240bd9">decaf::util::zip::InflaterInputStream::length</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The amount of data currently stored in the input buffer. </p>

</div>
</div>
<a class="anchor" id="a4956212216e6bf5e7b2af83f3b5b636d"></a><!-- doxytag: member="decaf::util::zip::InflaterInputStream::ownInflater" ref="a4956212216e6bf5e7b2af83f3b5b636d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html#a4956212216e6bf5e7b2af83f3b5b636d">decaf::util::zip::InflaterInputStream::ownInflater</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/zip/<a class="el" href="_inflater_input_stream_8h_source.html">InflaterInputStream.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1zip.html">zip</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html">InflaterInputStream</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
