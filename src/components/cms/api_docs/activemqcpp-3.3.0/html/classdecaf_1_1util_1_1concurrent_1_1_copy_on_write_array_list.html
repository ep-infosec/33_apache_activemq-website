<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::concurrent::CopyOnWriteArrayList" --><!-- doxytag: inherits="decaf::util::List" -->
<p><code>#include &lt;<a class="el" href="_copy_on_write_array_list_8h_source.html">src/main/decaf/util/concurrent/CopyOnWriteArrayList.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list__inherit__graph.png" border="0" usemap="#decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_3_01_e_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_3_01_e_01_4_inherit__map" id="decaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_3_01_e_01_4_inherit__map">
<area shape="rect" id="node2" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence)." alt="" coords="153,160,319,189"/><area shape="rect" id="node4" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy." alt="" coords="133,83,339,112"/><area shape="rect" id="node6" href="classdecaf_1_1lang_1_1_iterable.html" title="Implementing this interface allows an object to be cast to an Iterable type for generic collections A..." alt="" coords="5,5,203,35"/><area shape="rect" id="node8" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)..." alt="" coords="227,5,512,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list_1_1_array_list_iterator.html">ArrayListIterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a996887273387f18849afdc8699ff5e29">CopyOnWriteArrayList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a4a68e2e0f8d07a539860d664b384c32a">CopyOnWriteArrayList</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ac8914c5efccfb3fa2596fa13720c97fc">CopyOnWriteArrayList</a> (const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afb8c490c2a3efcb7dae18f961139c802">CopyOnWriteArrayList</a> (const E *array, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#af2af8873e7860502b91c9a6f135144d3">~CopyOnWriteArrayList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt; E &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a174136c43ddf0df59a7712d3e2a0198a">operator=</a> (const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt; E &gt; &amp;list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt; E &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#af09264d0728faffc593f63f438f4b511">operator=</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ad7f23a66e492777f92e0b8f7be6ab0b5">copy</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> as a Copy of the given <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.  <a href="#ad7f23a66e492777f92e0b8f7be6ab0b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1348b8a92975ef48222727245f6f4474">add</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection changed as a result of the call.  <a href="#a1348b8a92975ef48222727245f6f4474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#abb7d73a4cd2d1eb5736d1b263ce10a0f">addAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all of the elements in the specified collection to this collection.  <a href="#abb7d73a4cd2d1eb5736d1b263ce10a0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7e7ad15476b1088cc4fb9d675686ebb1">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the elements from this collection (optional operation).  <a href="#a7e7ad15476b1088cc4fb9d675686ebb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9d1a9ed9c5c7ee9130d742c63f91c7bd">contains</a> (const E &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains the specified element.  <a href="#a9d1a9ed9c5c7ee9130d742c63f91c7bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a8fb3c07e7375fad25d7b9379c009f87d">containsAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this collection contains all of the elements in the specified collection.  <a href="#a8fb3c07e7375fad25d7b9379c009f87d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aab459b5018cb9f2f0efd90f1415c405b">equals</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the passed collection to this one, if they contain the same elements, i.e.  <a href="#aab459b5018cb9f2f0efd90f1415c405b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a52634c38931211d1935e409c23923805">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a679f08a5ca71cdfc31752c31afd728a8">remove</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single instance of the specified element from the collection.  <a href="#a679f08a5ca71cdfc31752c31afd728a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afaa8a997b2001dd3eac1393ab0ed24ca">removeAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all this collection's elements that are also contained in the specified collection (optional operation).  <a href="#afaa8a997b2001dd3eac1393ab0ed24ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9e7261248ccbbf2271773a027435037e">retainAll</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains only the elements in this collection that are contained in the specified collection (optional operation).  <a href="#a9e7261248ccbbf2271773a027435037e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ae2846f1693ccf81c5c935b389858209c">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this collection.  <a href="#ae2846f1693ccf81c5c935b389858209c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a00ef7324a7dd2436bbcf2efca83db88d">toArray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array containing all of the elements in this collection.  <a href="#a00ef7324a7dd2436bbcf2efca83db88d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a2014e3565818f0ba96696c81f78b3cda">iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a><br class="typebreak"/>
&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#acbe1af5153877a32f8417abdc4974b90">iterator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a737d8a95f14b1ced78223dd572cdba29">listIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ae547c429d5c4623747dfa19294767116">listIterator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ad150e4ca24ee4e89778d4261e9d31c54">listIterator</a> (int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt; E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#abc4804b5a7b11f0ace30337787e2ba15">listIterator</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a8adaf616d9b83c3bc9f748c20fa2692a">indexOf</a> (const E &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.  <a href="#a8adaf616d9b83c3bc9f748c20fa2692a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ab1bc60cf328e1b5e12b1f5cacea02eee">lastIndexOf</a> (const E &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.  <a href="#ab1bc60cf328e1b5e12b1f5cacea02eee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a335e703f5eaa0d9c5de377a0b275f9c2">get</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element contained at position passed.  <a href="#a335e703f5eaa0d9c5de377a0b275f9c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1155ffa7088e44b057e4525ecbc475ce">set</a> (int index, const E &amp;element)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the element at the specified position in this list with the specified element.  <a href="#a1155ffa7088e44b057e4525ecbc475ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9399a517142aaf482576e06db7a5e819">add</a> (int index, const E &amp;element)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the specified element at the specified position in this list.  <a href="#a9399a517142aaf482576e06db7a5e819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a620c28f8a7ee09881a0772f9abb24e71">addAll</a> (int index, const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all of the elements in the specified collection into this list at the specified position (optional operation).  <a href="#a620c28f8a7ee09881a0772f9abb24e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a09dc6cc12d27c0099ba772cb1d805d62">removeAt</a> (int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at the specified position in this list.  <a href="#a09dc6cc12d27c0099ba772cb1d805d62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a3e9aadb858a9ac5734cb92fe5f262b5b">toString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7ec6efcb0c6fcfa7f7ea144a3e928a97">addIfAbsent</a> (const E &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given value to the end of this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> if it is not already contained in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.  <a href="#a7ec6efcb0c6fcfa7f7ea144a3e928a97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">addAllAbsent</a> (const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;collection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every element in the given collection that is not already contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is added to the end of this collection.  <a href="#a030211025a0daf6450a8cdd29621f44b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aefce640c9f0a99bc17851c5ead5f59fd">lastIndexOf</a> (const E &amp;value, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches backwards through the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> for the given element starting at the index specified.  <a href="#aefce640c9f0a99bc17851c5ead5f59fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a28cea55f9fbddf929157a1186cd551f7">indexOf</a> (const E &amp;value, int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> starting from the specified index and returns the index of the first item in the list that is equal to the given value.  <a href="#a28cea55f9fbddf929157a1186cd551f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a6057a5c7d3843eefd2731e4f5a618283">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the object.  <a href="#a6057a5c7d3843eefd2731e4f5a618283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aef1ce4a7101e660b9f4016e3fe28958b">tryLock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_lock.html" title="A wrapper class around a given synchronization mechanism that provides automatic release upon destruc...">Lock</a> the object, if the lock is already held by another thread than this method returns false.  <a href="#aef1ce4a7101e660b9f4016e3fe28958b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a3f16177058f4033cf60af91c1d88faa1">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the object.  <a href="#a3f16177058f4033cf60af91c1d88faa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1f26546287ed7fdb8445270ef93706c9">wait</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a1f26546287ed7fdb8445270ef93706c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a6eeb031cbf9b77e148c8df406a3fbbb5">wait</a> (long long millisecs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#a6eeb031cbf9b77e148c8df406a3fbbb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aad6479087b6a17de9954b55a7d6f6f54">wait</a> (long long millisecs, int nanos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on a signal from this object, which is generated by a call to Notify.  <a href="#aad6479087b6a17de9954b55a7d6f6f54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a8a96fc4331aa1908c1400c5ade12cb9b">notify</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals a waiter on this object that it can now wake up and continue.  <a href="#a8a96fc4331aa1908c1400c5ade12cb9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a935ef769776ea3e5ef0784e15c7b9982">notifyAll</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the waiters on this object that it can now wake up and continue.  <a href="#a935ef769776ea3e5ef0784e15c7b9982"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a22e03cff6eefd0ba4ecad622291bdf7b">CopyOnWriteArraySet</a></td></tr>
</table>
<h3>template&lt;typename E&gt;<br/>
 class decaf::util::concurrent::CopyOnWriteArrayList&lt; E &gt;</h3>

<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a996887273387f18849afdc8699ff5e29"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::CopyOnWriteArrayList" ref="a996887273387f18849afdc8699ff5e29" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4a68e2e0f8d07a539860d664b384c32a"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::CopyOnWriteArrayList" ref="a4a68e2e0f8d07a539860d664b384c32a" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8914c5efccfb3fa2596fa13720c97fc"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::CopyOnWriteArrayList" ref="ac8914c5efccfb3fa2596fa13720c97fc" args="(const CopyOnWriteArrayList&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb8c490c2a3efcb7dae18f961139c802"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::CopyOnWriteArrayList" ref="afb8c490c2a3efcb7dae18f961139c802" args="(const E *array, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> </td>
          <td>(</td>
          <td class="paramtype">const E *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af2af8873e7860502b91c9a6f135144d3"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::~CopyOnWriteArrayList" ref="af2af8873e7860502b91c9a6f135144d3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::~<a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1348b8a92975ef48222727245f6f4474"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::add" ref="a1348b8a92975ef48222727245f6f4474" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection changed as a result of the call. </p>
<p>(Returns false if this collection does not permit duplicates and already contains the specified element.)</p>
<p>Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> classes should clearly specify in their documentation any restrictions on what elements may be added.</p>
<p>If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.</p>
<p>For non-pointer values, i.e. class instances or string's the object will be copied into the collection, thus the object must support being copied, must not hide the copy constructor and assignment operator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to add to this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the element was added to this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the element cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a3b1fb8d6d75a6a8de1096e2af59c93b7">decaf::util::Collection&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAllAbsent()</a>.</p>

</div>
</div>
<a class="anchor" id="a9399a517142aaf482576e06db7a5e819"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::add" ref="a9399a517142aaf482576e06db7a5e819" args="(int index, const E &amp;element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the specified element at the specified position in this list. </p>
<p>Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index at which the specified element is to be inserted. </td></tr>
    <tr><td class="paramname">element</td><td>The element to be inserted in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index is greater than size of the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>. </td></tr>
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the element cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#aa94d30576e0baee2263d7c757b4c0202">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abb7d73a4cd2d1eb5736d1b263ce10a0f"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::addAll" ref="abb7d73a4cd2d1eb5736d1b263ce10a0f" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::addAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds all of the elements in the specified collection to this collection. </p>
<p>The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are added to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this collection changed as a result of the call</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of an element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if an element cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#ab1c54b20c3818a358cc8243b78d32e0a">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a620c28f8a7ee09881a0772f9abb24e71"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::addAll" ref="a620c28f8a7ee09881a0772f9abb24e71" args="(int index, const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::addAll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts all of the elements in the specified collection into this list at the specified position (optional operation). </p>
<p>Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index at which to insert the first element from the specified collection </td></tr>
    <tr><td class="paramname">source</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> containing elements to be added to this list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this list changed as a result of the call</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index given is less than zero or greater than the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> size. </td></tr>
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the element cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#ac91967127f7728d7bc280e74db218eab">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a030211025a0daf6450a8cdd29621f44b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::addAllAbsent" ref="a030211025a0daf6450a8cdd29621f44b" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::addAllAbsent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every element in the given collection that is not already contained in this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is added to the end of this collection. </p>
<p>The order that the elements are added is ditacted by the order that the collection's iterator returns them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection whose elements are to be added if not already in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements that are added to this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ec6efcb0c6fcfa7f7ea144a3e928a97"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::addIfAbsent" ref="a7ec6efcb0c6fcfa7f7ea144a3e928a97" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::addIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the given value to the end of this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> if it is not already contained in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to be added if not already contained in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the element is added to this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7ad15476b1088cc4fb9d675686ebb1"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::clear" ref="a7e7ad15476b1088cc4fb9d675686ebb1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all of the elements from this collection (optional operation). </p>
<p>This collection will be empty after this method returns unless it throws an exception.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a2043e86d563eeb5ddca03093a57c9d1f">decaf::util::Collection&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a174136c43ddf0df59a7712d3e2a0198a">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d1a9ed9c5c7ee9130d742c63f91c7bd"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::contains" ref="a9d1a9ed9c5c7ee9130d742c63f91c7bd" args="(const E &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains the specified element. </p>
<p>More formally, returns true if and only if this collection contains at least one element e such that (value == NULL ? e == NULL : value == e ).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check for presence in the collection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is at least one of the elements in the collection</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a5c5d5c5afc33a49856fdcc68cb2998cd">decaf::util::Collection&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a8fb3c07e7375fad25d7b9379c009f87d">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::containsAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb3c07e7375fad25d7b9379c009f87d"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::containsAll" ref="a8fb3c07e7375fad25d7b9379c009f87d" args="(const Collection&lt; E &gt; &amp;collection) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::containsAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this collection contains all of the elements in the specified collection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> to compare to this one.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> contains pointers and the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> does not allow for NULL elements (optional check). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#ab15403655917022def98615388de363f">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad7f23a66e492777f92e0b8f7be6ab0b5"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::copy" ref="ad7f23a66e492777f92e0b8f7be6ab0b5" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renders this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> as a Copy of the given <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection to mirror.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the elements cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#afc7c92a7acb97d171cb9fbbeab7a02fa">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aab459b5018cb9f2f0efd90f1415c405b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::equals" ref="aab459b5018cb9f2f0efd90f1415c405b" args="(const Collection&lt; E &gt; &amp;collection) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares the passed collection to this one, if they contain the same elements, i.e. </p>
<p>all their elements are equivalent, then it returns true.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the Collections contain the same elements. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a4b5678a72e37e2d6939eafb3e91c92f0">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a335e703f5eaa0d9c5de377a0b275f9c2"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::get" ref="a335e703f5eaa0d9c5de377a0b275f9c2" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the element contained at position passed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value at index specified.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index given is less than zero or greater than the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> size. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#a7dcca9a1c0eba8f450b3ef6dce220424">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a28cea55f9fbddf929157a1186cd551f7"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::indexOf" ref="a28cea55f9fbddf929157a1186cd551f7" args="(const E &amp;value, int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::indexOf </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> starting from the specified index and returns the index of the first item in the list that is equal to the given value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to search for in the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> to begin the search from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index in the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> that matches the given element or -1 if not found.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the given index is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8adaf616d9b83c3bc9f748c20fa2692a"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::indexOf" ref="a8adaf616d9b83c3bc9f748c20fa2692a" args="(const E &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::indexOf </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. </p>
<p>More formally, returns the lowest index i such that get(i) == value, or -1 if there is no such index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to search for in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the first occurrence of the specified element in this list,</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#a94063f4634e8b023f2302c7fba9a57a8">decaf::util::List&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAllAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7ec6efcb0c6fcfa7f7ea144a3e928a97">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addIfAbsent()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a679f08a5ca71cdfc31752c31afd728a8">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::remove()</a>.</p>

</div>
</div>
<a class="anchor" id="a52634c38931211d1935e409c23923805"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::isEmpty" ref="a52634c38931211d1935e409c23923805" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this collection contains no elements. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#aefdd40e6bc9875cf50e2b7d5c10b94f7">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2014e3565818f0ba96696c81f78b3cda"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::iterator" ref="a2014e3565818f0ba96696c81f78b3cda" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator over a set of elements of type T. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a1bf9dd78d7826b61fb59901e29d59857">decaf::lang::Iterable&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aab459b5018cb9f2f0efd90f1415c405b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::equals()</a>.</p>

</div>
</div>
<a class="anchor" id="acbe1af5153877a32f8417abdc4974b90"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::iterator" ref="acbe1af5153877a32f8417abdc4974b90" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_iterator.html">decaf::util::Iterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classdecaf_1_1lang_1_1_iterable.html#a8df8d3e4976a76be399adea077c4edb2">decaf::lang::Iterable&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aefce640c9f0a99bc17851c5ead5f59fd"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::lastIndexOf" ref="aefce640c9f0a99bc17851c5ead5f59fd" args="(const E &amp;value, int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches backwards through the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> for the given element starting at the index specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to search for in the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the list to begin the search from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index in the list that matches the value given, or -1 if not found.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the given index is greater than or equal to the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1bc60cf328e1b5e12b1f5cacea02eee"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::lastIndexOf" ref="ab1bc60cf328e1b5e12b1f5cacea02eee" args="(const E &amp;value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. </p>
<p>More formally, returns the highest index i such that get(i) == value or -1 if there is no such index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to search for in this <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the last occurrence of the specified element in this list.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#ae52cdf903ea0c527e2b1dd0940bf413c">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a737d8a95f14b1ced78223dd572cdba29"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::listIterator" ref="a737d8a95f14b1ced78223dd572cdba29" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::listIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a list iterator over the elements in this list (in proper sequence). </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#af923b3cd17a7c2d38f375f30edda7b9f">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae547c429d5c4623747dfa19294767116"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::listIterator" ref="ae547c429d5c4623747dfa19294767116" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::listIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#aaf32e0050c3100aa9f74c6544c403ec8">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad150e4ca24ee4e89778d4261e9d31c54"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::listIterator" ref="ad150e4ca24ee4e89778d4261e9d31c54" args="(int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::listIterator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of first element to be returned from the list iterator (by a call to the next method).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list iterator of the elements in this list (in proper sequence), starting at the specified position in this list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index is out of range (index &lt; 0 || index &gt; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#ae2846f1693ccf81c5c935b389858209c" title="Returns the number of elements in this collection.">size()</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#ac11ec120b080b00cc6a8046e025f9f4d">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abc4804b5a7b11f0ace30337787e2ba15"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::listIterator" ref="abc4804b5a7b11f0ace30337787e2ba15" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdecaf_1_1util_1_1_list_iterator.html">ListIterator</a>&lt;E&gt;* <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::listIterator </td>
          <td>(</td>
          <td class="paramtype">int index&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#a03f77c8eccc6b59d85bd53c6df9d2d5a">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6057a5c7d3843eefd2731e4f5a618283"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::lock" ref="a6057a5c7d3843eefd2731e4f5a618283" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the object. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while locking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aeff8d806ec08a8ebef540fc059947c48">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a8a96fc4331aa1908c1400c5ade12cb9b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::notify" ref="a8a96fc4331aa1908c1400c5ade12cb9b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals a waiter on this object that it can now wake up and continue. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)...">Synchronizable</a> Object. </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while notifying one of the waiting threads. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#ad62b154e5f2709b5471b00da52d0ad0b">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a935ef769776ea3e5ef0784e15c7b9982"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::notifyAll" ref="a935ef769776ea3e5ef0784e15c7b9982" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::notifyAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signals the waiters on this object that it can now wake up and continue. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)...">Synchronizable</a> Object. </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while notifying the waiting threads. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aa3af140ed7eded4f7ff59833c0bc619a">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="af09264d0728faffc593f63f438f4b511"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::operator=" ref="af09264d0728faffc593f63f438f4b511" args="(const Collection&lt; E &gt; &amp;list)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt;E&gt;&amp; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a174136c43ddf0df59a7712d3e2a0198a"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::operator=" ref="a174136c43ddf0df59a7712d3e2a0198a" args="(const CopyOnWriteArrayList&lt; E &gt; &amp;list)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt;E&gt;&amp; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a679f08a5ca71cdfc31752c31afd728a8"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::remove" ref="a679f08a5ca71cdfc31752c31afd728a8" args="(const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a single instance of the specified element from the collection. </p>
<p>More formally, removes an element e such that (value == NULL ? e == NULL : value == e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The reference to the element to remove from this <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection was changed, false otherwise.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#ad40a3d5aacf68dc3dbc39c7069e16adb">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afaa8a997b2001dd3eac1393ab0ed24ca"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::removeAll" ref="afaa8a997b2001dd3eac1393ab0ed24ca" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all this collection's elements that are also contained in the specified collection (optional operation). </p>
<p>After this call returns, this collection will contain no elements in common with the specified collection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be removed from this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a19f125b379fea151cbd97213bc03f203">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a09dc6cc12d27c0099ba772cb1d805d62"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::removeAt" ref="a09dc6cc12d27c0099ba772cb1d805d62" args="(int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::removeAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the element at the specified position in this list. </p>
<p>Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- the index of the element to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the element previously at the specified position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index given is less than zero or greater than the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> size. </td></tr>
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#a20eb98b630cad600610a59b0480bdc52">decaf::util::List&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a679f08a5ca71cdfc31752c31afd728a8">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::remove()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e7261248ccbbf2271773a027435037e"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::retainAll" ref="a9e7261248ccbbf2271773a027435037e" args="(const Collection&lt; E &gt; &amp;collection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::retainAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdecaf_1_1util_1_1_collection.html">Collection</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retains only the elements in this collection that are contained in the specified collection (optional operation). </p>
<p>In other words, removes from this collection all of its elements that are not contained in the specified collection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> whose elements are to be retained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the collection changed as a result of this call.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a61b44f2112d99c6010d00fde6b4d1d09">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1155ffa7088e44b057e4525ecbc475ce"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::set" ref="a1155ffa7088e44b057e4525ecbc475ce" args="(int index, const E &amp;element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual E <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces the element at the specified position in this list with the specified element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to replace. </td></tr>
    <tr><td class="paramname">element</td><td>The element to be stored at the specified position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the element previously at the specified position.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the index given is less than zero or greater than the <a class="el" href="classdecaf_1_1util_1_1_list.html" title="An ordered collection (also known as a sequence).">List</a> size. </td></tr>
    <tr><td class="paramname">UnsupportedOperationExceptio</td><td>if this is an unmodifiable collection. </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the <a class="el" href="classdecaf_1_1util_1_1_collection.html" title="The root interface in the collection hierarchy.">Collection</a> is a container of pointers and does not allow NULL values. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if some property of the element prevents it from being added to this collection </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if the element cannot be added at this time due to insertion restrictions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_list.html#a04085b64a7b0001ccb37e791a913ec3c">decaf::util::List&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae2846f1693ccf81c5c935b389858209c"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::size" ref="ae2846f1693ccf81c5c935b389858209c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of elements in this collection. </p>
<p>If this collection contains more than Integer::MAX_VALUE elements, returns Integer::MAX_VALUE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements in this collection </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#aad34433902f20bd422f64b14f51998cf">decaf::util::Collection&lt; E &gt;</a>.</p>

<p>Referenced by <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1348b8a92975ef48222727245f6f4474">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::add()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#abb7d73a4cd2d1eb5736d1b263ce10a0f">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a030211025a0daf6450a8cdd29621f44b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addAllAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a7ec6efcb0c6fcfa7f7ea144a3e928a97">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::addIfAbsent()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afb8c490c2a3efcb7dae18f961139c802">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::CopyOnWriteArrayList()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#aab459b5018cb9f2f0efd90f1415c405b">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::equals()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#afaa8a997b2001dd3eac1393ab0ed24ca">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::removeAll()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a09dc6cc12d27c0099ba772cb1d805d62">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::removeAt()</a>, <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a9e7261248ccbbf2271773a027435037e">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::retainAll()</a>, and <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html#a1155ffa7088e44b057e4525ecbc475ce">decaf::util::concurrent::CopyOnWriteArrayList&lt; ServiceListener * &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="a00ef7324a7dd2436bbcf2efca83db88d"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::toArray" ref="a00ef7324a7dd2436bbcf2efca83db88d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;E&gt; <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::toArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array containing all of the elements in this collection. </p>
<p>If the collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.</p>
<p>This method acts as bridge between array-based and collection-based APIs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an array of the elements in this collection in the form of an STL vector. </dd></dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1_collection.html#a0ccad8d05b8af0304daab3b66765692d">decaf::util::Collection&lt; E &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3e9aadb858a9ac5734cb92fe5f262b5b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::toString" ref="a3e9aadb858a9ac5734cb92fe5f262b5b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aef1ce4a7101e660b9f4016e3fe28958b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::tryLock" ref="aef1ce4a7101e660b9f4016e3fe28958b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::tryLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_lock.html" title="A wrapper class around a given synchronization mechanism that provides automatic release upon destruc...">Lock</a> the object, if the lock is already held by another thread than this method returns false. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the lock was acquired, false if it is already held by another thread.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while locking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a6aa79e4c2590ec4387d7bb2b7d265c47">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a3f16177058f4033cf60af91c1d88faa1"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::unlock" ref="a3f16177058f4033cf60af91c1d88faa1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the object. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while unlocking the object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#aabb6c431936a7d4c9810a5f1a99bde21">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="aad6479087b6a17de9954b55a7d6f6f54"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::wait" ref="aad6479087b6a17de9954b55a7d6f6f54" args="(long long millisecs, int nanos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>millisecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling. This wait will timeout after the specified time interval. This method is similar to the one argument wait function except that it add a finer grained control over the amount of time that it waits by adding in the additional nanosecond argument.</p>
<p>NOTE: The ability to wait accurately at a nanosecond scale depends on the platform and OS that the Decaf API is running on, some systems do not provide an accurate enough clock to provide this level of granularity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>the time in milliseconds to wait, or WAIT_INIFINITE </td></tr>
    <tr><td class="paramname">nanos</td><td>additional time in nanoseconds with a range of 0-999999</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if an error occurs or the nanos argument is not in the range of [0-999999] </td></tr>
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)...">Synchronizable</a> Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a954b500f0e3cba3a366da91e210893ea">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a6eeb031cbf9b77e148c8df406a3fbbb5"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::wait" ref="a6eeb031cbf9b77e148c8df406a3fbbb5" args="(long long millisecs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>millisecs</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling. This wait will timeout after the specified time interval.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">millisecs</td><td>the time in milliseconds to wait, or WAIT_INIFINITE</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)...">Synchronizable</a> Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a84939d5f17b846ba0aeb5824ec6fff41">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<a class="anchor" id="a1f26546287ed7fdb8445270ef93706c9"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::wait" ref="a1f26546287ed7fdb8445270ef93706c9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">decaf::util::concurrent::CopyOnWriteArrayList</a>&lt; E &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits on a signal from this object, which is generated by a call to Notify. </p>
<p>Must have this object locked before calling.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">RuntimeException</td><td>if an error occurs while waiting on the object. </td></tr>
    <tr><td class="paramname">InterruptedException</td><td>if the wait is interrupted before it completes. </td></tr>
    <tr><td class="paramname">IllegalMonitorStateException</td><td>- if the current thread is not the owner of the the <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html" title="The interface for all synchronizable objects (that is, objects that can be locked and unlocked)...">Synchronizable</a> Object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_synchronizable.html#a2f7a5619b8800c295626983b9c7808a6">decaf::util::concurrent::Synchronizable</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a22e03cff6eefd0ba4ecad622291bdf7b"></a><!-- doxytag: member="decaf::util::concurrent::CopyOnWriteArrayList::CopyOnWriteArraySet" ref="a22e03cff6eefd0ba4ecad622291bdf7b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_set.html">CopyOnWriteArraySet</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/concurrent/<a class="el" href="_copy_on_write_array_list_8h_source.html">CopyOnWriteArrayList.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1concurrent.html">concurrent</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1concurrent_1_1_copy_on_write_array_list.html">CopyOnWriteArrayList</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
