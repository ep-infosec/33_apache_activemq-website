<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::util::zip::Inflater Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1util_1_1zip_1_1_inflater.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::util::zip::Inflater Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::util::zip::Inflater" -->
<p>This class uncompresses data that was compressed using the <em>DEFLATE</em> algorithm (see <a href="http://www.gzip.org/algorithm.txt">specification</a>).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_inflater_8h_source.html">src/main/decaf/util/zip/Inflater.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a833ae9e97a9ca862633a4fcf37d9e013">Inflater</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new decompressor.  <a href="#a833ae9e97a9ca862633a4fcf37d9e013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a45eec8aaddbd9dcd7097486b9c31fcbb">Inflater</a> (bool nowrap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new decompressor.  <a href="#a45eec8aaddbd9dcd7097486b9c31fcbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a48352d8620cea28a8bd42bc2f077cda1">~Inflater</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a4dbea69a2639272fb9944cc192b89a23">setInput</a> (const unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets input data for decompression.  <a href="#a4dbea69a2639272fb9944cc192b89a23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ac40e5a894622a25ba5c7595fd553cc63">setInput</a> (const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets input data for decompression.  <a href="#ac40e5a894622a25ba5c7595fd553cc63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a035129ee9cc7f29e1cd330ad393c95d2">setInput</a> (const std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets input data for decompression.  <a href="#a035129ee9cc7f29e1cd330ad393c95d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae618092112dfec418f0b29c62feae8b0">getRemaining</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of bytes remaining in the input buffer.  <a href="#ae618092112dfec418f0b29c62feae8b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a1ae3e50e69bdc19dae78db001f2b09ef">setDictionary</a> (const unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the preset dictionary to the given array of bytes.  <a href="#a1ae3e50e69bdc19dae78db001f2b09ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ab8184b786320407dbd04ec7dd0680b8b">setDictionary</a> (const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the preset dictionary to the given array of bytes.  <a href="#ab8184b786320407dbd04ec7dd0680b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a32525c85b3dd28d764e230d8f956996b">setDictionary</a> (const std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the preset dictionary to the given array of bytes.  <a href="#a32525c85b3dd28d764e230d8f956996b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ac3953d91341caf46a12d1b25bd9f6145">finish</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, indicates that decompression should end with the current contents of the input buffer.  <a href="#ac3953d91341caf46a12d1b25bd9f6145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a4dc4a67e5ab81488ad793988b715aef1">finished</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832">inflate</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompresses bytes into specified buffer.  <a href="#aeef6817ce2bac31e07f3647db345f832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ab14cc4def336ed0f41052edd54f7529b">inflate</a> (std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompresses bytes into specified buffer.  <a href="#ab14cc4def336ed0f41052edd54f7529b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a78ac94fe3978943effcae39ac0deabab">inflate</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompresses bytes into specified buffer.  <a href="#a78ac94fe3978943effcae39ac0deabab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aa43fcc6f59157a8e3a5ac9a87344ccfe">getBytesRead</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a66977a13239e7edc1016a4eaa3722dd3">getBytesWritten</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a2212d864b079105bdbd5ca3a6dcb5f2e">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets deflater so that a new set of input data can be processed.  <a href="#a2212d864b079105bdbd5ca3a6dcb5f2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a80f90d6f03e19eaccebfff580517cb0b">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the decompressor and discards any unprocessed input.  <a href="#a80f90d6f03e19eaccebfff580517cb0b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class uncompresses data that was compressed using the <em>DEFLATE</em> algorithm (see <a href="http://www.gzip.org/algorithm.txt">specification</a>). </p>
<p>Basically this class is part of the API to the stream based ZLIB compression library and is used as such by <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a> and its descendants. </p>
<p>The typical usage of a <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> outside this package consists of a specific call to one of its constructors before being passed to an instance of <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater_input_stream.html" title="A FilterInputStream that decompresses data read from the wrapped InputStream instance.">InflaterInputStream</a> </dd>
<dd>
<a class="el" href="classdecaf_1_1util_1_1zip_1_1_deflater.html" title="This class compresses data using the DEFLATE algorithm (see specification).">Deflater</a></dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a833ae9e97a9ca862633a4fcf37d9e013"></a><!-- doxytag: member="decaf::util::zip::Inflater::Inflater" ref="a833ae9e97a9ca862633a4fcf37d9e013" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::Inflater::Inflater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new decompressor. </p>
<p>This constructor defaults the inflater to use the ZLIB header and checksum fields. </p>

</div>
</div>
<a class="anchor" id="a45eec8aaddbd9dcd7097486b9c31fcbb"></a><!-- doxytag: member="decaf::util::zip::Inflater::Inflater" ref="a45eec8aaddbd9dcd7097486b9c31fcbb" args="(bool nowrap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decaf::util::zip::Inflater::Inflater </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nowrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new decompressor. </p>
<p>If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP.</p>
<p>Note: When using the 'nowrap' option it is also necessary to provide an extra "dummy" byte as input. This is required by the ZLIB native library in order to support certain optimizations. </p>

</div>
</div>
<a class="anchor" id="a48352d8620cea28a8bd42bc2f077cda1"></a><!-- doxytag: member="decaf::util::zip::Inflater::~Inflater" ref="a48352d8620cea28a8bd42bc2f077cda1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::util::zip::Inflater::~Inflater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a80f90d6f03e19eaccebfff580517cb0b"></a><!-- doxytag: member="decaf::util::zip::Inflater::end" ref="a80f90d6f03e19eaccebfff580517cb0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the decompressor and discards any unprocessed input. </p>
<p>This method should be called when the decompressor is no longer being used, but will also be called automatically by the destructor. Once this method is called, the behavior of the <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html" title="This class uncompresses data that was compressed using the DEFLATE algorithm (see specification)...">Inflater</a> object is undefined. </p>

</div>
</div>
<a class="anchor" id="ac3953d91341caf46a12d1b25bd9f6145"></a><!-- doxytag: member="decaf::util::zip::Inflater::finish" ref="ac3953d91341caf46a12d1b25bd9f6145" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When called, indicates that decompression should end with the current contents of the input buffer. </p>

</div>
</div>
<a class="anchor" id="a4dc4a67e5ab81488ad793988b715aef1"></a><!-- doxytag: member="decaf::util::zip::Inflater::finished" ref="a4dc4a67e5ab81488ad793988b715aef1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::zip::Inflater::finished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the end of the compressed data output stream has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="a96410f92ecbe1fed50095b302ccb45ad"></a><!-- doxytag: member="decaf::util::zip::Inflater::getAdler" ref="a96410f92ecbe1fed50095b302ccb45ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long decaf::util::zip::Inflater::getAdler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the ADLER-32 value of the uncompressed data.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa43fcc6f59157a8e3a5ac9a87344ccfe"></a><!-- doxytag: member="decaf::util::zip::Inflater::getBytesRead" ref="aa43fcc6f59157a8e3a5ac9a87344ccfe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long decaf::util::zip::Inflater::getBytesRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of compressed bytes input so far.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66977a13239e7edc1016a4eaa3722dd3"></a><!-- doxytag: member="decaf::util::zip::Inflater::getBytesWritten" ref="a66977a13239e7edc1016a4eaa3722dd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long decaf::util::zip::Inflater::getBytesWritten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of decompressed bytes output so far.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae618092112dfec418f0b29c62feae8b0"></a><!-- doxytag: member="decaf::util::zip::Inflater::getRemaining" ref="ae618092112dfec418f0b29c62feae8b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Inflater::getRemaining </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total number of bytes remaining in the input buffer. </p>
<p>This can be used to find out what bytes still remain in the input buffer after decompression has finished.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of bytes remaining in the input buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a78ac94fe3978943effcae39ac0deabab"></a><!-- doxytag: member="decaf::util::zip::Inflater::inflate" ref="a78ac94fe3978943effcae39ac0deabab" args="(std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Inflater::inflate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uncompresses bytes into specified buffer. </p>
<p>Returns actual number of bytes uncompressed. A return value of 0 indicates that <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput()</a> or <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary()</a> should be called in order to determine if more input data or a preset dictionary is required. In the latter case, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler()</a> can be used to get the Adler-32 value of the dictionary required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to write the compressed data to.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_data_format_exception.html">DataFormatException</a></td><td>if the compressed data format is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab14cc4def336ed0f41052edd54f7529b"></a><!-- doxytag: member="decaf::util::zip::Inflater::inflate" ref="ab14cc4def336ed0f41052edd54f7529b" args="(std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Inflater::inflate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uncompresses bytes into specified buffer. </p>
<p>Returns actual number of bytes uncompressed. A return value of 0 indicates that <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput()</a> or <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary()</a> should be called in order to determine if more input data or a preset dictionary is required. In the latter case, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler()</a> can be used to get the Adler-32 value of the dictionary required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to write the compressed data to. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start writing at. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of byte of data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_data_format_exception.html">DataFormatException</a></td><td>if the compressed data format is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeef6817ce2bac31e07f3647db345f832"></a><!-- doxytag: member="decaf::util::zip::Inflater::inflate" ref="aeef6817ce2bac31e07f3647db345f832" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decaf::util::zip::Inflater::inflate </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uncompresses bytes into specified buffer. </p>
<p>Returns actual number of bytes uncompressed. A return value of 0 indicates that <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput()</a> or <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary()</a> should be called in order to determine if more input data or a preset dictionary is required. In the latter case, <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler()</a> can be used to get the Adler-32 value of the dictionary required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to write the compressed data to. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed in. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start writing at. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of byte of data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_data_format_exception.html">DataFormatException</a></td><td>if the compressed data format is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6aef0adff0971bab47b019d26f59de6"></a><!-- doxytag: member="decaf::util::zip::Inflater::needsDictionary" ref="af6aef0adff0971bab47b019d26f59de6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::zip::Inflater::needsDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a preset dictionary is needed for decompression. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9533dcfdd5898c2fc5bbc523fa4a9fb"></a><!-- doxytag: member="decaf::util::zip::Inflater::needsInput" ref="ae9533dcfdd5898c2fc5bbc523fa4a9fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool decaf::util::zip::Inflater::needsInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the input data buffer is empty and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a4dbea69a2639272fb9944cc192b89a23" title="Sets input data for decompression.">setInput()</a> should be called in order to provide more input </dd></dl>

</div>
</div>
<a class="anchor" id="a2212d864b079105bdbd5ca3a6dcb5f2e"></a><!-- doxytag: member="decaf::util::zip::Inflater::reset" ref="a2212d864b079105bdbd5ca3a6dcb5f2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets deflater so that a new set of input data can be processed. </p>
<p>Keeps current decompression level and strategy settings.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8184b786320407dbd04ec7dd0680b8b"></a><!-- doxytag: member="decaf::util::zip::Inflater::setDictionary" ref="ab8184b786320407dbd04ec7dd0680b8b" args="(const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::setDictionary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the preset dictionary to the given array of bytes. </p>
<p>Should be called when <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832" title="Uncompresses bytes into specified buffer.">inflate()</a> returns 0 and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary()</a> returns true indicating that a preset dictionary is required. The method <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler()</a> can be used to get the Adler-32 value of the dictionary needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for decompression. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given dictionary doesn't match thre required dictionaries checksum value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ae3e50e69bdc19dae78db001f2b09ef"></a><!-- doxytag: member="decaf::util::zip::Inflater::setDictionary" ref="a1ae3e50e69bdc19dae78db001f2b09ef" args="(const unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::setDictionary </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the preset dictionary to the given array of bytes. </p>
<p>Should be called when <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832" title="Uncompresses bytes into specified buffer.">inflate()</a> returns 0 and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary()</a> returns true indicating that a preset dictionary is required. The method <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler()</a> can be used to get the Adler-32 value of the dictionary needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for decompression. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed in. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given dictionary doesn't match thre required dictionaries checksum value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32525c85b3dd28d764e230d8f956996b"></a><!-- doxytag: member="decaf::util::zip::Inflater::setDictionary" ref="a32525c85b3dd28d764e230d8f956996b" args="(const std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::setDictionary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the preset dictionary to the given array of bytes. </p>
<p>Should be called when <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#aeef6817ce2bac31e07f3647db345f832" title="Uncompresses bytes into specified buffer.">inflate()</a> returns 0 and <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#af6aef0adff0971bab47b019d26f59de6">needsDictionary()</a> returns true indicating that a preset dictionary is required. The method <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#a96410f92ecbe1fed50095b302ccb45ad">getAdler()</a> can be used to get the Adler-32 value of the dictionary needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given dictionary doesn't match the required dictionaries checksum value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dbea69a2639272fb9944cc192b89a23"></a><!-- doxytag: member="decaf::util::zip::Inflater::setInput" ref="a4dbea69a2639272fb9944cc192b89a23" args="(const unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::setInput </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets input data for decompression. </p>
<p>This should be called whenever <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput()</a> returns true indicating that more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for decompression. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer passed in. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if buffer is NULL. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac40e5a894622a25ba5c7595fd553cc63"></a><!-- doxytag: member="decaf::util::zip::Inflater::setInput" ref="ac40e5a894622a25ba5c7595fd553cc63" args="(const std::vector&lt; unsigned char &gt; &amp;buffer, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::setInput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets input data for decompression. </p>
<p>This should be called whenever <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput()</a> returns true indicating that more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for decompression. </td></tr>
    <tr><td class="paramname">offset</td><td>The position in the Buffer to start reading from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read from the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the offset + length &gt; size of the buffer. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a035129ee9cc7f29e1cd330ad393c95d2"></a><!-- doxytag: member="decaf::util::zip::Inflater::setInput" ref="a035129ee9cc7f29e1cd330ad393c95d2" args="(const std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decaf::util::zip::Inflater::setInput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets input data for decompression. </p>
<p>This should be called whenever <a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html#ae9533dcfdd5898c2fc5bbc523fa4a9fb">needsInput()</a> returns true indicating that more input data is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The Buffer to read in for decompression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if in the end state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/util/zip/<a class="el" href="_inflater_8h_source.html">Inflater.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1util_1_1zip.html">zip</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1util_1_1zip_1_1_inflater.html">Inflater</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
