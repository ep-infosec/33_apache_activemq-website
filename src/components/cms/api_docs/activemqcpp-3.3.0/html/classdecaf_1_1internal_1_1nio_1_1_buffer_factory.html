<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>activemq-cpp-3.3.0: decaf::internal::nio::BufferFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">activemq-cpp-3.3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>decaf::internal::nio::BufferFactory Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="decaf::internal::nio::BufferFactory" -->
<p>Factory class used by static methods in the <a class="el" href="namespacedecaf_1_1nio.html">decaf::nio</a> package to create the various default version of the NIO interfaces.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_buffer_factory_8h_source.html">src/main/decaf/internal/nio/BufferFactory.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a44589bb67396cb8f8b5938bdbd0bcd0b">~BufferFactory</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a81ca8266bd013b23e09253d53b3b0604">createByteBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new byte buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a81ca8266bd013b23e09253d53b3b0604"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#ac367fd1eaf75b62f48d81cdfa69ef38b">createByteBuffer</a> (unsigned char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new ByteBuffer.  <a href="#ac367fd1eaf75b62f48d81cdfa69ef38b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#aa299eac2edbc5bc9039958439be8a2a5">createByteBuffer</a> (std::vector&lt; unsigned char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Byte Vector in a ByteBuffer.  <a href="#aa299eac2edbc5bc9039958439be8a2a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a773d72f35d0ed7123c9e1776e61cfb4f">createCharBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new char buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a773d72f35d0ed7123c9e1776e61cfb4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a3c16867c4982251dcfda414f98f08780">createCharBuffer</a> (char *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new CharBuffer.  <a href="#a3c16867c4982251dcfda414f98f08780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a01c0c9ded98d3942a7bc7f334c2d69ab">createCharBuffer</a> (std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Byte Vector in a CharBuffer.  <a href="#a01c0c9ded98d3942a7bc7f334c2d69ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a91b903fc76e64ef59f728fb08b10458a">createDoubleBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new double buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a91b903fc76e64ef59f728fb08b10458a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a065486057caaab4e75f8bf536949ba13">createDoubleBuffer</a> (double *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new DoubleBuffer.  <a href="#a065486057caaab4e75f8bf536949ba13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a016dcf7bd76dd369efdf36bb5768e1b0">createDoubleBuffer</a> (std::vector&lt; double &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Double Vector in a DoubleBuffer.  <a href="#a016dcf7bd76dd369efdf36bb5768e1b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a91f5096f9aecd298f206efe41f44511c">createFloatBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new float buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a91f5096f9aecd298f206efe41f44511c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a090a447d5908e7fd25510a717441153a">createFloatBuffer</a> (float *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new FloatBuffer.  <a href="#a090a447d5908e7fd25510a717441153a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a534f43f7dc112d19135f60895bec4cc7">createFloatBuffer</a> (std::vector&lt; float &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Float Vector in a FloatBuffer.  <a href="#a534f43f7dc112d19135f60895bec4cc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a9e2a0d5d5d268f9406df68e7dd7c148b">createLongBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new long long buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a9e2a0d5d5d268f9406df68e7dd7c148b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#aa2ad4bffc68dae978d039ca2bb5ae510">createLongBuffer</a> (long long *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new LongBuffer.  <a href="#aa2ad4bffc68dae978d039ca2bb5ae510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a0a9605cfff316fa852ebecab999455be">createLongBuffer</a> (std::vector&lt; long long &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Long Vector in a LongBuffer.  <a href="#a0a9605cfff316fa852ebecab999455be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#ad3bad30ab070e85dd5d6757e2b2b8513">createIntBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new int buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#ad3bad30ab070e85dd5d6757e2b2b8513"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a8ce5f8877bb139772360ac92902c9372">createIntBuffer</a> (int *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new IntBuffer.  <a href="#a8ce5f8877bb139772360ac92902c9372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a74a0f97af31e266b8a08a455723a2e66">createIntBuffer</a> (std::vector&lt; int &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL int Vector in a IntBuffer.  <a href="#a74a0f97af31e266b8a08a455723a2e66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a2050beb72a66c46b9fbf7ef767c7e9ab">createShortBuffer</a> (int capacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new short buffer whose position will be zero its limit will be its capacity and its mark is not set.  <a href="#a2050beb72a66c46b9fbf7ef767c7e9ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#a1ac9871200d3ec5dac012015f50ec0a8">createShortBuffer</a> (short *buffer, int size, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed buffer with a new ShortBuffer.  <a href="#a1ac9871200d3ec5dac012015f50ec0a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html#af3ba803fe5baee34152fdce316e2651a">createShortBuffer</a> (std::vector&lt; short &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the passed STL Short Vector in a ShortBuffer.  <a href="#af3ba803fe5baee34152fdce316e2651a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Factory class used by static methods in the <a class="el" href="namespacedecaf_1_1nio.html">decaf::nio</a> package to create the various default version of the NIO interfaces. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a44589bb67396cb8f8b5938bdbd0bcd0b"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::~BufferFactory" ref="a44589bb67396cb8f8b5938bdbd0bcd0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual decaf::internal::nio::BufferFactory::~BufferFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a81ca8266bd013b23e09253d53b3b0604"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createByteBuffer" ref="a81ca8266bd013b23e09253d53b3b0604" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a>* decaf::internal::nio::BufferFactory::createByteBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new byte buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated ByteBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac367fd1eaf75b62f48d81cdfa69ef38b"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createByteBuffer" ref="ac367fd1eaf75b62f48d81cdfa69ef38b" args="(unsigned char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a>* decaf::internal::nio::BufferFactory::createByteBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new ByteBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new ByteBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa299eac2edbc5bc9039958439be8a2a5"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createByteBuffer" ref="aa299eac2edbc5bc9039958439be8a2a5" args="(std::vector&lt; unsigned char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_byte_buffer.html">decaf::nio::ByteBuffer</a>* decaf::internal::nio::BufferFactory::createByteBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL Byte Vector in a ByteBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new ByteBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a773d72f35d0ed7123c9e1776e61cfb4f"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createCharBuffer" ref="a773d72f35d0ed7123c9e1776e61cfb4f" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::BufferFactory::createCharBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new char buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated CharBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c16867c4982251dcfda414f98f08780"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createCharBuffer" ref="a3c16867c4982251dcfda414f98f08780" args="(char *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::BufferFactory::createCharBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new CharBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new CharBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01c0c9ded98d3942a7bc7f334c2d69ab"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createCharBuffer" ref="a01c0c9ded98d3942a7bc7f334c2d69ab" args="(std::vector&lt; char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_char_buffer.html">decaf::nio::CharBuffer</a>* decaf::internal::nio::BufferFactory::createCharBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL Byte Vector in a CharBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new CharBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a065486057caaab4e75f8bf536949ba13"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createDoubleBuffer" ref="a065486057caaab4e75f8bf536949ba13" args="(double *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::BufferFactory::createDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new DoubleBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new DoubleBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a016dcf7bd76dd369efdf36bb5768e1b0"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createDoubleBuffer" ref="a016dcf7bd76dd369efdf36bb5768e1b0" args="(std::vector&lt; double &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::BufferFactory::createDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL Double Vector in a DoubleBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new DoubleBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a91b903fc76e64ef59f728fb08b10458a"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createDoubleBuffer" ref="a91b903fc76e64ef59f728fb08b10458a" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_double_buffer.html">decaf::nio::DoubleBuffer</a>* decaf::internal::nio::BufferFactory::createDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new double buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated DoubleBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91f5096f9aecd298f206efe41f44511c"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createFloatBuffer" ref="a91f5096f9aecd298f206efe41f44511c" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::BufferFactory::createFloatBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new float buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated FloatBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a090a447d5908e7fd25510a717441153a"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createFloatBuffer" ref="a090a447d5908e7fd25510a717441153a" args="(float *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::BufferFactory::createFloatBuffer </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new FloatBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new FloatBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a534f43f7dc112d19135f60895bec4cc7"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createFloatBuffer" ref="a534f43f7dc112d19135f60895bec4cc7" args="(std::vector&lt; float &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_float_buffer.html">decaf::nio::FloatBuffer</a>* decaf::internal::nio::BufferFactory::createFloatBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL Float Vector in a FloatBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new FloatBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3bad30ab070e85dd5d6757e2b2b8513"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createIntBuffer" ref="ad3bad30ab070e85dd5d6757e2b2b8513" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::BufferFactory::createIntBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new int buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated IntBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74a0f97af31e266b8a08a455723a2e66"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createIntBuffer" ref="a74a0f97af31e266b8a08a455723a2e66" args="(std::vector&lt; int &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::BufferFactory::createIntBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL int Vector in a IntBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new IntBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ce5f8877bb139772360ac92902c9372"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createIntBuffer" ref="a8ce5f8877bb139772360ac92902c9372" args="(int *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_int_buffer.html">decaf::nio::IntBuffer</a>* decaf::internal::nio::BufferFactory::createIntBuffer </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new IntBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new IntBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a9605cfff316fa852ebecab999455be"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createLongBuffer" ref="a0a9605cfff316fa852ebecab999455be" args="(std::vector&lt; long long &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::BufferFactory::createLongBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long long &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL Long Vector in a LongBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new LongBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e2a0d5d5d268f9406df68e7dd7c148b"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createLongBuffer" ref="a9e2a0d5d5d268f9406df68e7dd7c148b" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::BufferFactory::createLongBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new long long buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>- the internal buffer's capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated DoubleBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2ad4bffc68dae978d039ca2bb5ae510"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createLongBuffer" ref="aa2ad4bffc68dae978d039ca2bb5ae510" args="(long long *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_long_buffer.html">decaf::nio::LongBuffer</a>* decaf::internal::nio::BufferFactory::createLongBuffer </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new LongBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new LongBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2050beb72a66c46b9fbf7ef767c7e9ab"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createShortBuffer" ref="a2050beb72a66c46b9fbf7ef767c7e9ab" args="(int capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::BufferFactory::createShortBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new short buffer whose position will be zero its limit will be its capacity and its mark is not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The internal buffer's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated ShortBuffer which the caller owns.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ac9871200d3ec5dac012015f50ec0a8"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createShortBuffer" ref="a1ac9871200d3ec5dac012015f50ec0a8" args="(short *buffer, int size, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::BufferFactory::createShortBuffer </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed buffer with a new ShortBuffer. </p>
<p>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be array.length, its position will be offset, its limit will be offset + length, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array that will back the new buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the specified buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the subarray to be used. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the subarray to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new ShortBuffer that is backed by buffer, caller owns the returned pointer.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the buffer given in Null. </td></tr>
    <tr><td class="paramname">IndexOutOfBoundsException</td><td>if the capacity specified is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3ba803fe5baee34152fdce316e2651a"></a><!-- doxytag: member="decaf::internal::nio::BufferFactory::createShortBuffer" ref="af3ba803fe5baee34152fdce316e2651a" args="(std::vector&lt; short &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdecaf_1_1nio_1_1_short_buffer.html">decaf::nio::ShortBuffer</a>* decaf::internal::nio::BufferFactory::createShortBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps the passed STL Short Vector in a ShortBuffer. </p>
<p>The new buffer will be backed by the given byte array; modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be buffer.size(), its position will be zero, and its mark will be undefined. Its backing array will be the given array, and its array offset will be zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vector that will back the new buffer, the vector must have been sized to the desired size already by calling vector.resize( N ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new DoubleBuffer that is backed by buffer, caller owns. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/main/decaf/internal/nio/<a class="el" href="_buffer_factory_8h_source.html">BufferFactory.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacedecaf.html">decaf</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal.html">internal</a>      </li>
      <li class="navelem"><a class="el" href="namespacedecaf_1_1internal_1_1nio.html">nio</a>      </li>
      <li class="navelem"><a class="el" href="classdecaf_1_1internal_1_1nio_1_1_buffer_factory.html">BufferFactory</a>      </li>
      <li class="footer">Generated on Tue Apr 12 2011 for activemq-cpp-3.3.0 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
